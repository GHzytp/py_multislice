<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>pyms.utils.numpy_utils API documentation</title>
<meta name="description" content="Utility functions for working with the numpy library." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyms.utils.numpy_utils</code></h1>
</header>
<section id="section-intro">
<p>Utility functions for working with the numpy library.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Utility functions for working with the numpy library.&#34;&#34;&#34;
import numpy as np
import torch
import copy


def ensure_array(input):
    &#34;&#34;&#34;Force a (potentially scalar) input to be an array.&#34;&#34;&#34;
    if hasattr(input, &#34;__len__&#34;) and not isinstance(input, str):
        return input
    else:
        return np.asarray([input])


def r_space_array(pixels, gridsize):
    &#34;&#34;&#34;
    Return the appropriately scaled 2D real space coordinates.

    Parameters
    -----------
    pixels : (2,) array_like
        Pixels in each dimension of a 2D array
    gridsize : (2,) array_like
        Dimensions of the array in real space units
    &#34;&#34;&#34;
    rspace = [np.fft.fftfreq(pixels[i], d=1 / gridsize[i]) for i in [0, 1]]
    return [
        np.broadcast_to(r, pixels) for r in [rspace[0][:, None], rspace[1][None, :]]
    ]


def q_space_array(pixels, gridsize):
    &#34;&#34;&#34;
    Return the appropriately scaled 2D reciprocal space coordinates.

    Parameters
    -----------
    pixels : (2,) array_like
        Pixels in each dimension of a 2D array
    gridsize : (2,) array_like
        Dimensions of the array in real space units
    &#34;&#34;&#34;
    qspace = [np.fft.fftfreq(pixels[i], d=gridsize[i] / pixels[i]) for i in [0, 1]]
    return [
        np.broadcast_to(q, pixels) for q in [qspace[0][:, None], qspace[1][None, :]]
    ]


def crop_window_to_flattened_indices(indices, shape):
    &#34;&#34;&#34;Map  y and x indices describing a cropping window to a flattened 1d array.&#34;&#34;&#34;
    return (
        indices[-1][None, :] % shape[-1]
        + (indices[-2][:, None] % shape[-2]) * shape[-1]
    ).ravel()


def crop_to_bandwidth_limit(
    array, limit=2 / 3, norm=&#34;conserve_L2&#34;, qspace_in=True, qspace_out=True
):
    &#34;&#34;&#34;
    Crop an array to its bandwidth limit (ie remove superfluous array entries).

    assumes that input array is in Fourier space with zeroth Fourier component
    in upper-left corner
    &#34;&#34;&#34;
    # New shape of final dimensions
    newshape = tuple([round(array.shape[-2 + i] * limit) for i in range(2)])

    return fourier_interpolate_2d(
        array, newshape, norm=norm, qspace_in=qspace_in, qspace_out=qspace_out
    )


def bandwidth_limit_array(arrayin, limit=2 / 3, qspace_in=True, qspace_out=True):
    &#34;&#34;&#34;
    Band-width limit an array in Fourier space.

    Band width limiting of the propagator and transmission functions is necessary
    in multislice to prevent &#34;aliasing&#34;, wrapping round of high-angle scattering
    due the periodic boundary conditions implicit in the multislice algorithm.
    See sec. 6.8 of &#34;Kirkland&#39;s Advanced Computing in Electron Microscopy&#34; for
    more detail.

    Parameters
    ----------
    arrayin : array_like (...,Ny,Nx)
        Array to be bandwidth limited.
    limit : float
        Bandwidth limit as a fraction of the maximum reciprocal space frequency
        of the array.
    qspace_in : bool, optional
        Set to True if the input array is in reciprocal space (default),
        False if not
    qspace_out : bool, optional
        Set to True for reciprocal space output (default), False for real-space
        output.
    Returns
    -------
    array : array_like (...,Ny,Nx)
        The bandwidth limit of the array
    &#34;&#34;&#34;
    # Transform array to real space if necessary
    if qspace_in:
        array = copy.deepcopy(arrayin)
    else:
        array = np.fft.fft2(arrayin)

    # Case where band-width limiting has been turned off
    if limit is not None:
        if isinstance(array, np.ndarray):
            pixelsize = array.shape[:2]
            array[
                (
                    np.square(np.fft.fftfreq(pixelsize[0]))[:, np.newaxis]
                    + np.square(np.fft.fftfreq(pixelsize[1]))[np.newaxis, :]
                )
                * (2 / limit) ** 2
                &gt;= 1
            ] = 0
        else:
            pixelsize = array.size()[:2]
            array[
                (
                    torch.from_numpy(np.fft.fftfreq(pixelsize[0]) ** 2).view(
                        pixelsize[0], 1
                    )
                    + torch.from_numpy(np.fft.fftfreq(pixelsize[1]) ** 2).view(
                        1, pixelsize[1]
                    )
                )
                * (2 / limit) ** 2
                &gt;= 1
            ] = 0

    if qspace_out:
        return array
    else:
        return np.fft.ifft2(array)


def Fourier_interpolation_masks(npiyin, npixin, npiyout, npixout):
    &#34;&#34;&#34;Calculate a mask of array entries to be included in Fourier interpolation.&#34;&#34;&#34;
    # Construct input and output fft grids
    qyin, qxin, qyout, qxout = [
        (np.fft.fftfreq(x, 1 / x)).astype(np.int)
        for x in [npiyin, npixin, npiyout, npixout]
    ]

    # Get maximum and minimum common reciprocal space coordinates
    minqy, maxqy = [
        max(np.amin(qyin), np.amin(qyout)),
        min(np.amax(qyin), np.amax(qyout)),
    ]
    minqx, maxqx = [
        max(np.amin(qxin), np.amin(qxout)),
        min(np.amax(qxin), np.amax(qxout)),
    ]

    # Make 2d grids
    qqxout, qqyout = np.meshgrid(qxout, qyout)
    qqxin, qqyin = np.meshgrid(qxin, qyin)

    # Make a masks of common Fourier components for input and output arrays
    maskin = np.logical_and(
        np.logical_and(qqxin &lt;= maxqx, qqxin &gt;= minqx),
        np.logical_and(qqyin &lt;= maxqy, qqyin &gt;= minqy),
    )

    maskout = np.logical_and(
        np.logical_and(qqxout &lt;= maxqx, qqxout &gt;= minqx),
        np.logical_and(qqyout &lt;= maxqy, qqyout &gt;= minqy),
    )

    return maskin, maskout


def renormalize(array, oldmin=None, oldmax=None, newmax=1.0, newmin=0.0):
    &#34;&#34;&#34;Rescales the array such that its maximum is newmax and its minimum is newmin.&#34;&#34;&#34;
    if oldmin is not None:
        min_ = oldmin
    else:
        min_ = array.min()

    if oldmax is not None:
        max_ = oldmax
    else:
        max_ = array.max()

    return (
        np.clip((array - min_) / (max_ - min_), 0.0, 1.0) * (newmax - newmin) + newmin
    )


def convolve(array1, array2, axes=None):
    &#34;&#34;&#34;
    Fourier convolution of two arrays over specified axes.

    array2 is broadcast to match array1 so axes refers to the dimensions of
    array1
    &#34;&#34;&#34;
    # input and output shape
    s = array1.shape
    # Broadcast array2 to match array1
    a2 = np.broadcast_to(array2, s)
    # Axes of transformation
    a = axes
    if a is not None:
        s = [s[i] for i in a]
    if np.iscomplexobj(array1) or np.iscomplexobj(a2):
        return np.fft.ifftn(np.fft.fftn(array1, s, a) * np.fft.fftn(a2, s, a), s, a)
    else:
        return np.fft.irfftn(np.fft.rfftn(array1, s, a) * np.fft.rfftn(a2, s, a), s, a)


def colorize(z, saturation=0.8, minlightness=0.0, maxlightness=0.5):
    &#34;&#34;&#34;
    Map a complex number to the hsl scale and output in RGB format.

    Parameters
    ----------
    z : complex, array_like
        Complex array to be plotted using hsl
    Saturation : float, optional
        (Uniform) saturation value of the hsl colormap
    minlightness, maxlightness : float, optional
        The amplitude of the complex array z will be mapped to the lightness of
        the output hsl map. These keyword arguments allow control over the range
        of lightness values in the map
    &#34;&#34;&#34;
    from colorsys import hls_to_rgb

    # Get phase an amplitude of complex array
    r = np.abs(z)
    arg = np.angle(z)

    # Calculate hue, lightness and saturation
    h = arg / (2 * np.pi)
    ell = renormalize(r, newmin=minlightness, newmax=maxlightness)
    s = saturation

    # Convert HLS format to RGB format
    c = np.vectorize(hls_to_rgb)(h, ell, s)  # --&gt; tuple
    # Convert to numpy array
    c = np.array(c)  # --&gt;
    # Array has shape (3,n,m), but we need (n,m,3) for output, range needs to be
    # from 0 to 256
    c = (c.swapaxes(0, 2) * 256).astype(np.uint8)
    return c


def fourier_interpolate_2d(
    ain, shapeout, norm=&#34;conserve_val&#34;, qspace_in=False, qspace_out=False
):
    &#34;&#34;&#34;
    Perfom fourier interpolation on array ain so that its shape matches shapeout.

    Arguments
    ---------
    ain : (...,Ny,Nx) array_like
        Input numpy array
    shapeout : int (2,) , array_like
        Desired shape of output array
    norm : str, optional  {&#39;conserve_val&#39;,&#39;conserve_norm&#39;,&#39;conserve_L1&#39;}
        Normalization of output. If &#39;conserve_val&#39; then array values are preserved
        if &#39;conserve_norm&#39; L2 norm is conserved under interpolation and if
        &#39;conserve_L1&#39; L1 norm is conserved under interpolation
    qspace_in : bool, optional
        Set to True if the input array is in reciprocal space, False if not (default).
        Be careful with setting this to True for a non-complex array.
    qspace_out : bool, optional
        Set to True for reciprocal space output, False for real-space output (default).
    &#34;&#34;&#34;
    # Import required FFT functions
    from numpy.fft import fft2

    # Make input complex
    aout = np.zeros(np.shape(ain)[:-2] + tuple(shapeout), dtype=np.complex)

    # Get input dimensions
    npiyin, npixin = np.shape(ain)[-2:]
    npiyout, npixout = shapeout

    # Get Fourier interpolation masks
    maskin, maskout = Fourier_interpolation_masks(npiyin, npixin, npiyout, npixout)

    if qspace_in:
        a = np.asarray(ain, dtype=np.complex)
    else:
        a = fft2(np.asarray(ain, dtype=np.complex))

    # Now transfer over Fourier coefficients from input to output array
    aout[..., maskout] = a[..., maskin]

    # Fourier transform result with appropriate normalization
    if norm == &#34;conserve_val&#34;:
        aout *= np.prod(shapeout) / np.prod(np.shape(ain)[-2:])
    elif norm == &#34;conserve_norm&#34;:
        aout *= np.sqrt(np.prod(shapeout) / np.prod(np.shape(ain)[-2:]))

    if not qspace_out:
        aout = np.fft.ifftn(aout, axes=[-2, -1])

    # Return correct array data type
    if not np.iscomplexobj(ain):
        return np.real(aout)
    else:
        return aout


def oned_shift(N, shift, pixel_units=True):
    &#34;&#34;&#34;
    Construct a one-dimensional shift array.

    Parameters
    ----------
    N     -- Number of pixels in the shift array
    shift -- Amount of shift to be achieved (default units of pixels)

    Keyword arguments
    ----------
    pixel_units -- Pass True if shift is to be units of pixels, False for
                   fraction of the array
    &#34;&#34;&#34;
    # Create the Fourier space pixel coordinates of the shift array
    shiftarray = (np.arange(N) + N // 2) % N - N // 2

    # Conversion necessary if the shift is in units of pixels, and not fractions
    # of the array
    if pixel_units:
        shiftarray = shiftarray / N

    # The shift array is given mathematically as e^(-2pi i k Delta x) and this
    # is what is returned.
    return np.exp(-2 * np.pi * 1j * shiftarray * shift)


def fourier_shift(arrayin, shift, qspacein=False, qspaceout=False, pixel_units=True):
    &#34;&#34;&#34;
    Shifts a 2d array using the Fourier shift theorem.

    Parameters
    ----------
    arrayin -- Array to be Fourier shifted
    shift   -- Shift in units of pixels (pass pixel_units = False for shift
               to be in units of fraction of the array size)

    Keyword arguments
    ----------
    qspacein    -- Pass True if arrayin is in Fourier space
    qspaceout   -- Pass True for Fourier space output, False (default) for
                   real space output
    pixel_units -- Pass True if shift is to be units of pixels, False for
                   fraction of the array
    &#34;&#34;&#34;
    # Construct shift array
    shifty, shiftx = [
        oned_shift(arrayin.shape[-2 + i], shift[i], pixel_units) for i in range(2)
    ]

    # Now Fourier transform array and apply shift
    real = not np.iscomplexobj(arrayin)

    if real:
        array = np.asarray(arrayin, dtype=np.complex)
    else:
        array = arrayin

    if not qspacein:
        array = np.fft.fft2(array)

    array = shiftx[np.newaxis, :] * shifty[:, np.newaxis] * array

    if not qspaceout:
        array = np.fft.ifft2(array)

    if real:
        return np.real(array)
    else:
        return array


def add_noise(arrayin, Total_counts):
    &#34;&#34;&#34;
    Add Poisson counting noise to simulated data.

    Parameters
    ----------
    arrayin : array_like
        Array giving the fraction of Total_counts that is expected at each pixel
        in the array.
    Total_counts : float
        Total number of electron counts expected over the array.
    &#34;&#34;&#34;
    return np.random.poisson(arrayin * Total_counts)


def crop(arrayin, shapeout):
    &#34;&#34;&#34;
    Crop the last two dimensions of arrayin to grid size shapeout.

    For entries of shapeout which are larger than the shape of the input array,
    perform zero-padding.

    Parameters
    ----------
    arrayin : (...,Ny,Nx) array_like
        Array to be cropped or zero-padded.
    shapeout : (2,) array_like
        Desired output shape of the final two dimensions of arrayin
    &#34;&#34;&#34;
    # Number of dimensions in input array
    ndim = arrayin.ndim

    # Number of dimensions not covered by shapeout (ie not to be cropped)
    nUntouched = ndim - 2

    # Shape of output array
    shapeout_ = arrayin.shape[:nUntouched] + tuple(shapeout)

    arrayout = np.zeros(shapeout_, dtype=arrayin.dtype)

    y, x = arrayin.shape[-2:]
    y_, x_ = shapeout[-2:]

    def indices(y, y_):
        if y &gt; y_:
            # Crop in y dimension
            y1, y2 = [(y - y_) // 2, (y + y_) // 2]
            y1_, y2_ = [0, y_]
        else:
            # Zero pad in y dimension
            y1, y2 = [0, y]
            y1_, y2_ = [(y_ - y) // 2, (y + y_) // 2]
        return y1, y2, y1_, y2_

    y1, y2, y1_, y2_ = indices(y, y_)
    x1, x2, x1_, x2_ = indices(x, x_)

    arrayout[..., y1_:y2_, x1_:x2_] = arrayin[..., y1:y2, x1:x2]
    return arrayout


def Gaussian(sigma, gridshape, rsize, theta=0):
    r&#34;&#34;&#34;
    Calculate a normalized 2D Gaussian function.

    Notes
    -----
    Functional form
    .. math:: 1 / \sqrt { 2 \pi \sigma }  e^{ - ( x^2 + y^2 ) / 2 / \sigma^2 }

    Parameters
    ----------
    sigma : float or (2,) array_like
        The standard deviation of the Gaussian function, if an array is provided
        then the first two entries will give the y and x standard deviation of
        the Gaussian.
    gridshape : (2,) array_like
        Number of pixels in the grid.
    rsize : (2,) array_like
        Size of the grid in units of length
    theta : float, optional
        Angle of the two dimensional Gaussian function.
    &#34;&#34;&#34;
    if isinstance(sigma, (list, tuple, np.ndarray)):
        sigmay, sigmax = sigma[:2]
    else:
        sigmax = sigma
        sigmay = sigma
    grid = r_space_array(gridshape, rsize)
    a = np.cos(theta) ** 2 / (2 * sigmax ** 2) + np.sin(theta) ** 2 / (2 * sigmay ** 2)
    b = -np.sin(2 * theta) / (4 * sigmax ** 2) + np.sin(2 * theta) / (4 * sigmay ** 2)
    c = np.sin(theta) ** 2 / (2 * sigmax ** 2) + np.cos(theta) ** 2 / (2 * sigmay ** 2)
    gaussian = np.exp(
        -(a * grid[1] ** 2 + 2 * b * grid[0] * grid[1] + c * grid[0] ** 2)
    )
    return gaussian / np.sum(gaussian)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyms.utils.numpy_utils.Fourier_interpolation_masks"><code class="name flex">
<span>def <span class="ident">Fourier_interpolation_masks</span></span>(<span>npiyin, npixin, npiyout, npixout)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a mask of array entries to be included in Fourier interpolation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Fourier_interpolation_masks(npiyin, npixin, npiyout, npixout):
    &#34;&#34;&#34;Calculate a mask of array entries to be included in Fourier interpolation.&#34;&#34;&#34;
    # Construct input and output fft grids
    qyin, qxin, qyout, qxout = [
        (np.fft.fftfreq(x, 1 / x)).astype(np.int)
        for x in [npiyin, npixin, npiyout, npixout]
    ]

    # Get maximum and minimum common reciprocal space coordinates
    minqy, maxqy = [
        max(np.amin(qyin), np.amin(qyout)),
        min(np.amax(qyin), np.amax(qyout)),
    ]
    minqx, maxqx = [
        max(np.amin(qxin), np.amin(qxout)),
        min(np.amax(qxin), np.amax(qxout)),
    ]

    # Make 2d grids
    qqxout, qqyout = np.meshgrid(qxout, qyout)
    qqxin, qqyin = np.meshgrid(qxin, qyin)

    # Make a masks of common Fourier components for input and output arrays
    maskin = np.logical_and(
        np.logical_and(qqxin &lt;= maxqx, qqxin &gt;= minqx),
        np.logical_and(qqyin &lt;= maxqy, qqyin &gt;= minqy),
    )

    maskout = np.logical_and(
        np.logical_and(qqxout &lt;= maxqx, qqxout &gt;= minqx),
        np.logical_and(qqyout &lt;= maxqy, qqyout &gt;= minqy),
    )

    return maskin, maskout</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.Gaussian"><code class="name flex">
<span>def <span class="ident">Gaussian</span></span>(<span>sigma, gridshape, rsize, theta=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a normalized 2D Gaussian function.</p>
<h2 id="notes">Notes</h2>
<p>Functional form
[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>sigma</code></strong> :&ensp;<code>float</code> or <code>(2,) array_like</code></dt>
<dd>The standard deviation of the Gaussian function, if an array is provided
then the first two entries will give the y and x standard deviation of
the Gaussian.</dd>
<dt><strong><code>gridshape</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Number of pixels in the grid.</dd>
<dt><strong><code>rsize</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Size of the grid in units of length</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Angle of the two dimensional Gaussian function.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Gaussian(sigma, gridshape, rsize, theta=0):
    r&#34;&#34;&#34;
    Calculate a normalized 2D Gaussian function.

    Notes
    -----
    Functional form
    .. math:: 1 / \sqrt { 2 \pi \sigma }  e^{ - ( x^2 + y^2 ) / 2 / \sigma^2 }

    Parameters
    ----------
    sigma : float or (2,) array_like
        The standard deviation of the Gaussian function, if an array is provided
        then the first two entries will give the y and x standard deviation of
        the Gaussian.
    gridshape : (2,) array_like
        Number of pixels in the grid.
    rsize : (2,) array_like
        Size of the grid in units of length
    theta : float, optional
        Angle of the two dimensional Gaussian function.
    &#34;&#34;&#34;
    if isinstance(sigma, (list, tuple, np.ndarray)):
        sigmay, sigmax = sigma[:2]
    else:
        sigmax = sigma
        sigmay = sigma
    grid = r_space_array(gridshape, rsize)
    a = np.cos(theta) ** 2 / (2 * sigmax ** 2) + np.sin(theta) ** 2 / (2 * sigmay ** 2)
    b = -np.sin(2 * theta) / (4 * sigmax ** 2) + np.sin(2 * theta) / (4 * sigmay ** 2)
    c = np.sin(theta) ** 2 / (2 * sigmax ** 2) + np.cos(theta) ** 2 / (2 * sigmay ** 2)
    gaussian = np.exp(
        -(a * grid[1] ** 2 + 2 * b * grid[0] * grid[1] + c * grid[0] ** 2)
    )
    return gaussian / np.sum(gaussian)</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.add_noise"><code class="name flex">
<span>def <span class="ident">add_noise</span></span>(<span>arrayin, Total_counts)</span>
</code></dt>
<dd>
<div class="desc"><p>Add Poisson counting noise to simulated data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arrayin</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Array giving the fraction of Total_counts that is expected at each pixel
in the array.</dd>
<dt><strong><code>Total_counts</code></strong> :&ensp;<code>float</code></dt>
<dd>Total number of electron counts expected over the array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_noise(arrayin, Total_counts):
    &#34;&#34;&#34;
    Add Poisson counting noise to simulated data.

    Parameters
    ----------
    arrayin : array_like
        Array giving the fraction of Total_counts that is expected at each pixel
        in the array.
    Total_counts : float
        Total number of electron counts expected over the array.
    &#34;&#34;&#34;
    return np.random.poisson(arrayin * Total_counts)</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.bandwidth_limit_array"><code class="name flex">
<span>def <span class="ident">bandwidth_limit_array</span></span>(<span>arrayin, limit=0.6666666666666666, qspace_in=True, qspace_out=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Band-width limit an array in Fourier space.</p>
<p>Band width limiting of the propagator and transmission functions is necessary
in multislice to prevent "aliasing", wrapping round of high-angle scattering
due the periodic boundary conditions implicit in the multislice algorithm.
See sec. 6.8 of "Kirkland's Advanced Computing in Electron Microscopy" for
more detail.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arrayin</code></strong> :&ensp;<code>array_like (&hellip;,Ny,Nx)</code></dt>
<dd>Array to be bandwidth limited.</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code>float</code></dt>
<dd>Bandwidth limit as a fraction of the maximum reciprocal space frequency
of the array.</dd>
<dt><strong><code>qspace_in</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set to True if the input array is in reciprocal space (default),
False if not</dd>
<dt><strong><code>qspace_out</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set to True for reciprocal space output (default), False for real-space
output.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>array_like (&hellip;,Ny,Nx)</code></dt>
<dd>The bandwidth limit of the array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bandwidth_limit_array(arrayin, limit=2 / 3, qspace_in=True, qspace_out=True):
    &#34;&#34;&#34;
    Band-width limit an array in Fourier space.

    Band width limiting of the propagator and transmission functions is necessary
    in multislice to prevent &#34;aliasing&#34;, wrapping round of high-angle scattering
    due the periodic boundary conditions implicit in the multislice algorithm.
    See sec. 6.8 of &#34;Kirkland&#39;s Advanced Computing in Electron Microscopy&#34; for
    more detail.

    Parameters
    ----------
    arrayin : array_like (...,Ny,Nx)
        Array to be bandwidth limited.
    limit : float
        Bandwidth limit as a fraction of the maximum reciprocal space frequency
        of the array.
    qspace_in : bool, optional
        Set to True if the input array is in reciprocal space (default),
        False if not
    qspace_out : bool, optional
        Set to True for reciprocal space output (default), False for real-space
        output.
    Returns
    -------
    array : array_like (...,Ny,Nx)
        The bandwidth limit of the array
    &#34;&#34;&#34;
    # Transform array to real space if necessary
    if qspace_in:
        array = copy.deepcopy(arrayin)
    else:
        array = np.fft.fft2(arrayin)

    # Case where band-width limiting has been turned off
    if limit is not None:
        if isinstance(array, np.ndarray):
            pixelsize = array.shape[:2]
            array[
                (
                    np.square(np.fft.fftfreq(pixelsize[0]))[:, np.newaxis]
                    + np.square(np.fft.fftfreq(pixelsize[1]))[np.newaxis, :]
                )
                * (2 / limit) ** 2
                &gt;= 1
            ] = 0
        else:
            pixelsize = array.size()[:2]
            array[
                (
                    torch.from_numpy(np.fft.fftfreq(pixelsize[0]) ** 2).view(
                        pixelsize[0], 1
                    )
                    + torch.from_numpy(np.fft.fftfreq(pixelsize[1]) ** 2).view(
                        1, pixelsize[1]
                    )
                )
                * (2 / limit) ** 2
                &gt;= 1
            ] = 0

    if qspace_out:
        return array
    else:
        return np.fft.ifft2(array)</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.colorize"><code class="name flex">
<span>def <span class="ident">colorize</span></span>(<span>z, saturation=0.8, minlightness=0.0, maxlightness=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Map a complex number to the hsl scale and output in RGB format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>complex, array_like</code></dt>
<dd>Complex array to be plotted using hsl</dd>
<dt><strong><code>Saturation</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>(Uniform) saturation value of the hsl colormap</dd>
<dt><strong><code>minlightness</code></strong>, <strong><code>maxlightness</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The amplitude of the complex array z will be mapped to the lightness of
the output hsl map. These keyword arguments allow control over the range
of lightness values in the map</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def colorize(z, saturation=0.8, minlightness=0.0, maxlightness=0.5):
    &#34;&#34;&#34;
    Map a complex number to the hsl scale and output in RGB format.

    Parameters
    ----------
    z : complex, array_like
        Complex array to be plotted using hsl
    Saturation : float, optional
        (Uniform) saturation value of the hsl colormap
    minlightness, maxlightness : float, optional
        The amplitude of the complex array z will be mapped to the lightness of
        the output hsl map. These keyword arguments allow control over the range
        of lightness values in the map
    &#34;&#34;&#34;
    from colorsys import hls_to_rgb

    # Get phase an amplitude of complex array
    r = np.abs(z)
    arg = np.angle(z)

    # Calculate hue, lightness and saturation
    h = arg / (2 * np.pi)
    ell = renormalize(r, newmin=minlightness, newmax=maxlightness)
    s = saturation

    # Convert HLS format to RGB format
    c = np.vectorize(hls_to_rgb)(h, ell, s)  # --&gt; tuple
    # Convert to numpy array
    c = np.array(c)  # --&gt;
    # Array has shape (3,n,m), but we need (n,m,3) for output, range needs to be
    # from 0 to 256
    c = (c.swapaxes(0, 2) * 256).astype(np.uint8)
    return c</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.convolve"><code class="name flex">
<span>def <span class="ident">convolve</span></span>(<span>array1, array2, axes=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Fourier convolution of two arrays over specified axes.</p>
<p>array2 is broadcast to match array1 so axes refers to the dimensions of
array1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convolve(array1, array2, axes=None):
    &#34;&#34;&#34;
    Fourier convolution of two arrays over specified axes.

    array2 is broadcast to match array1 so axes refers to the dimensions of
    array1
    &#34;&#34;&#34;
    # input and output shape
    s = array1.shape
    # Broadcast array2 to match array1
    a2 = np.broadcast_to(array2, s)
    # Axes of transformation
    a = axes
    if a is not None:
        s = [s[i] for i in a]
    if np.iscomplexobj(array1) or np.iscomplexobj(a2):
        return np.fft.ifftn(np.fft.fftn(array1, s, a) * np.fft.fftn(a2, s, a), s, a)
    else:
        return np.fft.irfftn(np.fft.rfftn(array1, s, a) * np.fft.rfftn(a2, s, a), s, a)</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.crop"><code class="name flex">
<span>def <span class="ident">crop</span></span>(<span>arrayin, shapeout)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop the last two dimensions of arrayin to grid size shapeout.</p>
<p>For entries of shapeout which are larger than the shape of the input array,
perform zero-padding.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arrayin</code></strong> :&ensp;<code>(&hellip;,Ny,Nx) array_like</code></dt>
<dd>Array to be cropped or zero-padded.</dd>
<dt><strong><code>shapeout</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Desired output shape of the final two dimensions of arrayin</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop(arrayin, shapeout):
    &#34;&#34;&#34;
    Crop the last two dimensions of arrayin to grid size shapeout.

    For entries of shapeout which are larger than the shape of the input array,
    perform zero-padding.

    Parameters
    ----------
    arrayin : (...,Ny,Nx) array_like
        Array to be cropped or zero-padded.
    shapeout : (2,) array_like
        Desired output shape of the final two dimensions of arrayin
    &#34;&#34;&#34;
    # Number of dimensions in input array
    ndim = arrayin.ndim

    # Number of dimensions not covered by shapeout (ie not to be cropped)
    nUntouched = ndim - 2

    # Shape of output array
    shapeout_ = arrayin.shape[:nUntouched] + tuple(shapeout)

    arrayout = np.zeros(shapeout_, dtype=arrayin.dtype)

    y, x = arrayin.shape[-2:]
    y_, x_ = shapeout[-2:]

    def indices(y, y_):
        if y &gt; y_:
            # Crop in y dimension
            y1, y2 = [(y - y_) // 2, (y + y_) // 2]
            y1_, y2_ = [0, y_]
        else:
            # Zero pad in y dimension
            y1, y2 = [0, y]
            y1_, y2_ = [(y_ - y) // 2, (y + y_) // 2]
        return y1, y2, y1_, y2_

    y1, y2, y1_, y2_ = indices(y, y_)
    x1, x2, x1_, x2_ = indices(x, x_)

    arrayout[..., y1_:y2_, x1_:x2_] = arrayin[..., y1:y2, x1:x2]
    return arrayout</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.crop_to_bandwidth_limit"><code class="name flex">
<span>def <span class="ident">crop_to_bandwidth_limit</span></span>(<span>array, limit=0.6666666666666666, norm='conserve_L2', qspace_in=True, qspace_out=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop an array to its bandwidth limit (ie remove superfluous array entries).</p>
<p>assumes that input array is in Fourier space with zeroth Fourier component
in upper-left corner</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop_to_bandwidth_limit(
    array, limit=2 / 3, norm=&#34;conserve_L2&#34;, qspace_in=True, qspace_out=True
):
    &#34;&#34;&#34;
    Crop an array to its bandwidth limit (ie remove superfluous array entries).

    assumes that input array is in Fourier space with zeroth Fourier component
    in upper-left corner
    &#34;&#34;&#34;
    # New shape of final dimensions
    newshape = tuple([round(array.shape[-2 + i] * limit) for i in range(2)])

    return fourier_interpolate_2d(
        array, newshape, norm=norm, qspace_in=qspace_in, qspace_out=qspace_out
    )</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.crop_window_to_flattened_indices"><code class="name flex">
<span>def <span class="ident">crop_window_to_flattened_indices</span></span>(<span>indices, shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Map
y and x indices describing a cropping window to a flattened 1d array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop_window_to_flattened_indices(indices, shape):
    &#34;&#34;&#34;Map  y and x indices describing a cropping window to a flattened 1d array.&#34;&#34;&#34;
    return (
        indices[-1][None, :] % shape[-1]
        + (indices[-2][:, None] % shape[-2]) * shape[-1]
    ).ravel()</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.ensure_array"><code class="name flex">
<span>def <span class="ident">ensure_array</span></span>(<span>input)</span>
</code></dt>
<dd>
<div class="desc"><p>Force a (potentially scalar) input to be an array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_array(input):
    &#34;&#34;&#34;Force a (potentially scalar) input to be an array.&#34;&#34;&#34;
    if hasattr(input, &#34;__len__&#34;) and not isinstance(input, str):
        return input
    else:
        return np.asarray([input])</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.fourier_interpolate_2d"><code class="name flex">
<span>def <span class="ident">fourier_interpolate_2d</span></span>(<span>ain, shapeout, norm='conserve_val', qspace_in=False, qspace_out=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Perfom fourier interpolation on array ain so that its shape matches shapeout.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>ain</code></strong> :&ensp;<code>(&hellip;,Ny,Nx) array_like</code></dt>
<dd>Input numpy array</dd>
<dt><strong><code>shapeout</code></strong> :&ensp;<code>int (2,) , array_like</code></dt>
<dd>Desired shape of output array</dd>
<dt><strong><code>norm</code></strong> :&ensp;<code>str</code>, optional
<code>{'conserve_val','conserve_norm','conserve_L1'}</code></dt>
<dd>Normalization of output. If 'conserve_val' then array values are preserved
if 'conserve_norm' L2 norm is conserved under interpolation and if
'conserve_L1' L1 norm is conserved under interpolation</dd>
<dt><strong><code>qspace_in</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set to True if the input array is in reciprocal space, False if not (default).
Be careful with setting this to True for a non-complex array.</dd>
<dt><strong><code>qspace_out</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set to True for reciprocal space output, False for real-space output (default).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fourier_interpolate_2d(
    ain, shapeout, norm=&#34;conserve_val&#34;, qspace_in=False, qspace_out=False
):
    &#34;&#34;&#34;
    Perfom fourier interpolation on array ain so that its shape matches shapeout.

    Arguments
    ---------
    ain : (...,Ny,Nx) array_like
        Input numpy array
    shapeout : int (2,) , array_like
        Desired shape of output array
    norm : str, optional  {&#39;conserve_val&#39;,&#39;conserve_norm&#39;,&#39;conserve_L1&#39;}
        Normalization of output. If &#39;conserve_val&#39; then array values are preserved
        if &#39;conserve_norm&#39; L2 norm is conserved under interpolation and if
        &#39;conserve_L1&#39; L1 norm is conserved under interpolation
    qspace_in : bool, optional
        Set to True if the input array is in reciprocal space, False if not (default).
        Be careful with setting this to True for a non-complex array.
    qspace_out : bool, optional
        Set to True for reciprocal space output, False for real-space output (default).
    &#34;&#34;&#34;
    # Import required FFT functions
    from numpy.fft import fft2

    # Make input complex
    aout = np.zeros(np.shape(ain)[:-2] + tuple(shapeout), dtype=np.complex)

    # Get input dimensions
    npiyin, npixin = np.shape(ain)[-2:]
    npiyout, npixout = shapeout

    # Get Fourier interpolation masks
    maskin, maskout = Fourier_interpolation_masks(npiyin, npixin, npiyout, npixout)

    if qspace_in:
        a = np.asarray(ain, dtype=np.complex)
    else:
        a = fft2(np.asarray(ain, dtype=np.complex))

    # Now transfer over Fourier coefficients from input to output array
    aout[..., maskout] = a[..., maskin]

    # Fourier transform result with appropriate normalization
    if norm == &#34;conserve_val&#34;:
        aout *= np.prod(shapeout) / np.prod(np.shape(ain)[-2:])
    elif norm == &#34;conserve_norm&#34;:
        aout *= np.sqrt(np.prod(shapeout) / np.prod(np.shape(ain)[-2:]))

    if not qspace_out:
        aout = np.fft.ifftn(aout, axes=[-2, -1])

    # Return correct array data type
    if not np.iscomplexobj(ain):
        return np.real(aout)
    else:
        return aout</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.fourier_shift"><code class="name flex">
<span>def <span class="ident">fourier_shift</span></span>(<span>arrayin, shift, qspacein=False, qspaceout=False, pixel_units=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Shifts a 2d array using the Fourier shift theorem.</p>
<h2 id="parameters">Parameters</h2>
<p>arrayin &ndash; Array to be Fourier shifted
shift
&ndash; Shift in units of pixels (pass pixel_units = False for shift
to be in units of fraction of the array size)</p>
<h2 id="keyword-arguments">Keyword Arguments</h2>
<p>qspacein
&ndash; Pass True if arrayin is in Fourier space
qspaceout
&ndash; Pass True for Fourier space output, False (default) for
real space output
pixel_units &ndash; Pass True if shift is to be units of pixels, False for
fraction of the array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fourier_shift(arrayin, shift, qspacein=False, qspaceout=False, pixel_units=True):
    &#34;&#34;&#34;
    Shifts a 2d array using the Fourier shift theorem.

    Parameters
    ----------
    arrayin -- Array to be Fourier shifted
    shift   -- Shift in units of pixels (pass pixel_units = False for shift
               to be in units of fraction of the array size)

    Keyword arguments
    ----------
    qspacein    -- Pass True if arrayin is in Fourier space
    qspaceout   -- Pass True for Fourier space output, False (default) for
                   real space output
    pixel_units -- Pass True if shift is to be units of pixels, False for
                   fraction of the array
    &#34;&#34;&#34;
    # Construct shift array
    shifty, shiftx = [
        oned_shift(arrayin.shape[-2 + i], shift[i], pixel_units) for i in range(2)
    ]

    # Now Fourier transform array and apply shift
    real = not np.iscomplexobj(arrayin)

    if real:
        array = np.asarray(arrayin, dtype=np.complex)
    else:
        array = arrayin

    if not qspacein:
        array = np.fft.fft2(array)

    array = shiftx[np.newaxis, :] * shifty[:, np.newaxis] * array

    if not qspaceout:
        array = np.fft.ifft2(array)

    if real:
        return np.real(array)
    else:
        return array</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.oned_shift"><code class="name flex">
<span>def <span class="ident">oned_shift</span></span>(<span>N, shift, pixel_units=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a one-dimensional shift array.</p>
<h2 id="parameters">Parameters</h2>
<p>N
&ndash; Number of pixels in the shift array
shift &ndash; Amount of shift to be achieved (default units of pixels)</p>
<h2 id="keyword-arguments">Keyword Arguments</h2>
<p>pixel_units &ndash; Pass True if shift is to be units of pixels, False for
fraction of the array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def oned_shift(N, shift, pixel_units=True):
    &#34;&#34;&#34;
    Construct a one-dimensional shift array.

    Parameters
    ----------
    N     -- Number of pixels in the shift array
    shift -- Amount of shift to be achieved (default units of pixels)

    Keyword arguments
    ----------
    pixel_units -- Pass True if shift is to be units of pixels, False for
                   fraction of the array
    &#34;&#34;&#34;
    # Create the Fourier space pixel coordinates of the shift array
    shiftarray = (np.arange(N) + N // 2) % N - N // 2

    # Conversion necessary if the shift is in units of pixels, and not fractions
    # of the array
    if pixel_units:
        shiftarray = shiftarray / N

    # The shift array is given mathematically as e^(-2pi i k Delta x) and this
    # is what is returned.
    return np.exp(-2 * np.pi * 1j * shiftarray * shift)</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.q_space_array"><code class="name flex">
<span>def <span class="ident">q_space_array</span></span>(<span>pixels, gridsize)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the appropriately scaled 2D reciprocal space coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixels</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Pixels in each dimension of a 2D array</dd>
<dt><strong><code>gridsize</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Dimensions of the array in real space units</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def q_space_array(pixels, gridsize):
    &#34;&#34;&#34;
    Return the appropriately scaled 2D reciprocal space coordinates.

    Parameters
    -----------
    pixels : (2,) array_like
        Pixels in each dimension of a 2D array
    gridsize : (2,) array_like
        Dimensions of the array in real space units
    &#34;&#34;&#34;
    qspace = [np.fft.fftfreq(pixels[i], d=gridsize[i] / pixels[i]) for i in [0, 1]]
    return [
        np.broadcast_to(q, pixels) for q in [qspace[0][:, None], qspace[1][None, :]]
    ]</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.r_space_array"><code class="name flex">
<span>def <span class="ident">r_space_array</span></span>(<span>pixels, gridsize)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the appropriately scaled 2D real space coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixels</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Pixels in each dimension of a 2D array</dd>
<dt><strong><code>gridsize</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Dimensions of the array in real space units</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def r_space_array(pixels, gridsize):
    &#34;&#34;&#34;
    Return the appropriately scaled 2D real space coordinates.

    Parameters
    -----------
    pixels : (2,) array_like
        Pixels in each dimension of a 2D array
    gridsize : (2,) array_like
        Dimensions of the array in real space units
    &#34;&#34;&#34;
    rspace = [np.fft.fftfreq(pixels[i], d=1 / gridsize[i]) for i in [0, 1]]
    return [
        np.broadcast_to(r, pixels) for r in [rspace[0][:, None], rspace[1][None, :]]
    ]</code></pre>
</details>
</dd>
<dt id="pyms.utils.numpy_utils.renormalize"><code class="name flex">
<span>def <span class="ident">renormalize</span></span>(<span>array, oldmin=None, oldmax=None, newmax=1.0, newmin=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Rescales the array such that its maximum is newmax and its minimum is newmin.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def renormalize(array, oldmin=None, oldmax=None, newmax=1.0, newmin=0.0):
    &#34;&#34;&#34;Rescales the array such that its maximum is newmax and its minimum is newmin.&#34;&#34;&#34;
    if oldmin is not None:
        min_ = oldmin
    else:
        min_ = array.min()

    if oldmax is not None:
        max_ = oldmax
    else:
        max_ = array.max()

    return (
        np.clip((array - min_) / (max_ - min_), 0.0, 1.0) * (newmax - newmin) + newmin
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyms.utils" href="index.html">pyms.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyms.utils.numpy_utils.Fourier_interpolation_masks" href="#pyms.utils.numpy_utils.Fourier_interpolation_masks">Fourier_interpolation_masks</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.Gaussian" href="#pyms.utils.numpy_utils.Gaussian">Gaussian</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.add_noise" href="#pyms.utils.numpy_utils.add_noise">add_noise</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.bandwidth_limit_array" href="#pyms.utils.numpy_utils.bandwidth_limit_array">bandwidth_limit_array</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.colorize" href="#pyms.utils.numpy_utils.colorize">colorize</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.convolve" href="#pyms.utils.numpy_utils.convolve">convolve</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.crop" href="#pyms.utils.numpy_utils.crop">crop</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.crop_to_bandwidth_limit" href="#pyms.utils.numpy_utils.crop_to_bandwidth_limit">crop_to_bandwidth_limit</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.crop_window_to_flattened_indices" href="#pyms.utils.numpy_utils.crop_window_to_flattened_indices">crop_window_to_flattened_indices</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.ensure_array" href="#pyms.utils.numpy_utils.ensure_array">ensure_array</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.fourier_interpolate_2d" href="#pyms.utils.numpy_utils.fourier_interpolate_2d">fourier_interpolate_2d</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.fourier_shift" href="#pyms.utils.numpy_utils.fourier_shift">fourier_shift</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.oned_shift" href="#pyms.utils.numpy_utils.oned_shift">oned_shift</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.q_space_array" href="#pyms.utils.numpy_utils.q_space_array">q_space_array</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.r_space_array" href="#pyms.utils.numpy_utils.r_space_array">r_space_array</a></code></li>
<li><code><a title="pyms.utils.numpy_utils.renormalize" href="#pyms.utils.numpy_utils.renormalize">renormalize</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>