<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>pyms.structure_routines API documentation</title>
<meta name="description" content="The structures module â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyms.structure_routines</code></h1>
</header>
<section id="section-intro">
<p>The structures module.</p>
<p>A collection of functions and classes for reading in and manipulating structures
and creating potential arrays for multislice simulation.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The structures module.

A collection of functions and classes for reading in and manipulating structures
and creating potential arrays for multislice simulation.
&#34;&#34;&#34;
import itertools
import ase
import numpy as np
import torch
import matplotlib.pyplot as plt
import copy
from re import split, match
from os.path import splitext
from .atomic_scattering_params import e_scattering_factors, atomic_symbol
from .Probe import wavev, relativistic_mass_correction
from .utils.numpy_utils import bandwidth_limit_array, q_space_array, ensure_array
from .utils.torch_utils import sinc, torch_c_exp, get_device, cx_from_numpy


def remove_common_factors(nums):
    &#34;&#34;&#34;Remove common divisible factors from a set of numbers.&#34;&#34;&#34;
    nums = np.asarray(nums, dtype=np.int)
    g_ = np.gcd.reduce(nums)
    while g_ &gt; 1:
        nums //= g_
        g_ = np.gcd.reduce(nums)
    return nums


def psuedo_rational_tiling(dim1, dim2, EPS):
    &#34;&#34;&#34;
    Calculate the psuedo-rational tiling for matching objects of different dimensions.

    For two dimensions, dim1 and dim2, work out the multiplicative
    tiling so that those dimensions might be matched to within error EPS.
    &#34;&#34;&#34;
    if np.any([dim1 == 0, dim2 == 0]):
        return 1, 1
    tile1 = int(np.round(np.abs(dim2 / dim1) / EPS))
    tile2 = int(np.round(1 / EPS))
    return remove_common_factors([tile1, tile2])


def Xray_scattering_factor(Z, gsq, units=&#34;A&#34;):
    &#34;&#34;&#34;
    Calculate the X-ray scattering factor for atom with atomic number Z.

    Parameters
    ----------
    Z : int
        Atomic number of atom of interest.
    gsq : float or array_like
        Reciprocal space value(s) in Angstrom squared at which to evaluate the
        X-ray scattering factor.
    units : string, optional
        Units in which to calculate X-ray scattering factor, can be &#39;A&#39; for
        Angstrom, or &#39;VA&#39; for volt-Angstrom.
    &#34;&#34;&#34;
    # Bohr radius in Angstrom
    a0 = 0.529177
    # gsq = g**2
    return Z - 2 * np.pi ** 2 * a0 * gsq * electron_scattering_factor(
        Z, gsq, units=units
    )


def electron_scattering_factor(Z, gsq, units=&#34;VA&#34;):
    &#34;&#34;&#34;
    Calculate the electron scattering factor for atom with atomic number Z.

    Parameters
    ----------
    Z : int
        Atomic number of atom of interest.
    gsq : float or array_like
        Reciprocal space value(s) in Angstrom squared at which to evaluate the
        electron scattering factor.
    units : string, optional
        Units in which to calculate electron scattering factor, can be &#39;A&#39; for
        Angstrom, or &#39;VA&#39; for volt-Angstrom.
    &#34;&#34;&#34;
    ai = e_scattering_factors[Z - 1, 0:10:2]
    bi = e_scattering_factors[Z - 1, 1:10:2]

    # Planck&#39;s constant in kg Angstrom/s
    h = 6.62607004e-24
    # Electron rest mass in kg
    me = 9.10938356e-31
    # Electron charge in Coulomb
    qe = 1.60217662e-19

    fe = np.zeros_like(gsq)

    for i in range(5):
        fe += ai[i] * (2 + bi[i] * gsq) / (1 + bi[i] * gsq) ** 2

    # Result can be returned in units of Volt Angstrom (&#39;VA&#39;) or Angstrom (&#39;A&#39;)
    if units == &#34;VA&#34;:
        return h ** 2 / (2 * np.pi * me * qe) * fe
    elif units == &#34;A&#34;:
        return fe


def calculate_scattering_factors(gridshape, gridsize, elements):
    &#34;&#34;&#34;Calculate the electron scattering factors on a reciprocal space grid.

    Parameters
    ----------
    gridshape : (2,) array_like
        pixel size of the grid
    gridsize : (2,) array_like
        Lateral real space sizing of the grid in Angstrom
    elements : (M,) array_like
        List of elements for which electron scattering factors are required

    Returns
    -------
    fe : (M, *gridshape)
        Array of electron scattering factors in reciprocal space for each
        element
    &#34;&#34;&#34;
    # Get reciprocal space array
    g = q_space_array(gridshape, gridsize)
    gsq = np.square(g[0]) + np.square(g[1])

    # Initialise scattering factor array
    fe = np.zeros((len(elements), *gridshape), dtype=np.float32)

    # Loop over unique elements
    for ielement, element in enumerate(elements):
        fe[ielement, :, :] = electron_scattering_factor(element, gsq)

    return fe


def find_equivalent_sites(positions, EPS=1e-3):
    &#34;&#34;&#34;Find equivalent atomic sites in a list of atomic positions object.

    This function is used to detect two atoms sharing the same postions (are
    with EPS of each other) with fractional occupancy, and return an index of
    these equivalent sites.
    &#34;&#34;&#34;
    # Import  the pair-wise distance function from scipy
    from scipy.spatial.distance import pdist

    natoms = positions.shape[0]
    # Calculate pairwise distance between each atomic site
    distance_matrix = pdist(positions)

    # Initialize index of equivalent sites (initially assume all sites are
    # independent)
    equivalent_sites = np.arange(natoms, dtype=np.int)

    # Find equivalent sites
    equiv = distance_matrix &lt; EPS

    # If there are equivalent sites correct the index of equivalent sites
    if np.any(equiv):
        # Masking function to get indices from distance_matrix
        iu = np.mask_indices(natoms, np.triu, 1)

        # Get a list of equivalent sites
        sites = np.nonzero(equiv)[0]
        for site in sites:
            # Use the masking function to
            equivalent_sites[iu[1][site]] = iu[0][site]
    return equivalent_sites


def interaction_constant(E, units=&#34;rad/VA&#34;):
    &#34;&#34;&#34;
    Calculate the electron interaction constant, sigma.

    The electron interaction constant converts electrostatic potential (in V
    Angstrom) to radians. Units of this constant are rad/(V Angstrom).  See
    Eq. (2.5) in Kirkland&#39;s Advanced Computing in electron microscopy.
    &#34;&#34;&#34;
    # Planck&#39;s constant in kg Angstrom /s
    h = 6.62607004e-24
    # Electron rest mass in kg
    me = 9.10938356e-31
    # Electron charge in Coulomb
    qe = 1.60217662e-19
    # Electron wave number (reciprocal of wavelength) in Angstrom
    k0 = wavev(E)
    # Relativistic electron mass correction
    gamma = relativistic_mass_correction(E)
    if units == &#34;rad/VA&#34;:
        return 2 * np.pi * gamma * me * qe / k0 / h / h
    elif units == &#34;rad/A&#34;:
        return gamma / k0


def change_of_basis(coords, newuc, olduc):
    &#34;&#34;&#34;Change of basis for structure unit cell.&#34;&#34;&#34;
    return np.mod(coords[:, :3] @ olduc @ np.linalg.inv(newuc), 1.0)


def rot_matrix(theta, u=np.asarray([0, 0, 1], dtype=np.float)):
    &#34;&#34;&#34;
    Generate a 3D rotational matrix.

    Parameters
    ----------
    theta : float
        Angle of rotation in radians
    u : (3,) array_like
        Axis of rotation
    &#34;&#34;&#34;
    from numpy import sin, cos

    c = cos(theta)
    s = sin(theta)
    ux, uy, uz = u / np.linalg.norm(u)
    R = np.zeros((3, 3))
    R[0, :] = [
        c + ux * ux * (1 - c),
        ux * uy * (1 - c) - uz * s,
        ux * uz * (1 - c) + uy * s,
    ]
    R[1, :] = [
        uy * uz * (1 - c) + uz * s,
        c + uy * uy * (1 - c),
        uy * uz * (1 - c) - ux * s,
    ]
    R[2, :] = [
        uz * ux * (1 - c) - uy * s,
        uz * uy * (1 - c) + ux * s,
        c + uz * uz * (1 - c),
    ]
    return R


class structure:
    &#34;&#34;&#34;
    Class for simulation objects.

    Elements in a structure object:
    unitcell :
        An array containing the side lengths of the orthorhombic unit cell
    atoms :
        An array of dimensions total number of atoms by 6 which for each atom
        contains the fractional cooordinates within the unit cell for each atom
        in the first three entries, the atomic number in the fourth entry,
        the atomic occupancy (not yet implemented in the multislice) in the
        fifth entry and mean squared atomic displacement in the sixth entry
    Title :
        Short description of the object of output purposes
    &#34;&#34;&#34;

    def __init__(self, unitcell, atoms, dwf, occ=None, Title=&#34;&#34;, EPS=1e-2):
        &#34;&#34;&#34;Initialize a simulation object with necessary variables.&#34;&#34;&#34;
        self.unitcell = np.asarray(unitcell)
        natoms = np.asarray(atoms).shape[0]

        if occ is None:
            occ = np.ones(natoms)

        self.atoms = np.concatenate(
            [atoms, occ.reshape(natoms, 1), np.asarray(dwf).reshape(natoms, 1)], axis=1
        )
        self.Title = Title

        # Up till now unitcell can be a 3 x 3 matrix with rows describing the
        # unit cell edges. If this is the case we need to make sure that the
        # unit cell is orthorhombic and find an orthorhombic tiling if this it
        # is not orthorhombic
        if self.unitcell.ndim &gt; 1:
            # Check to see if unit cell is orthorhombic
            ortho = np.abs(np.sum(self.unitcell) - np.trace(self.unitcell)) &lt; EPS

            if ortho:
                # If unit cell is orthorhombic then extract unit cell
                # dimension
                self.unitcell = np.diag(self.unitcell)
            else:
                # If not orthorhombic attempt psuedo rational tiling
                self.orthorhombic_supercell(EPS=EPS)

        # Check if there is any fractional occupancy of atom sites in
        # the sample
        self.fractional_occupancy = np.any(np.abs(self.atoms[:, 4] - 1.0) &gt; 1e-3)

    @classmethod
    def fromfile(
        cls,
        fnam,
        temperature_factor_units=&#34;ums&#34;,
        atomic_coordinates=&#34;fractional&#34;,
        EPS=1e-2,
        T=None,
    ):
        &#34;&#34;&#34;
        Read in a simulation object from a structure file.

        Appropriate structure files include *.p1 files, which is outputted by
        the vesta software:

        K. Momma and F. Izumi, &#34;VESTA 3 for three-dimensional visualization of
        crystal, volumetric and morphology data,&#34; J. Appl. Crystallogr., 44,
        1272-1276 (2011).

        or a *.xyz file in the standard of the prismatic software

        Parameters
        ----------
        fnam : string
            Filepath of the structure file
        temperature_factor_units : string,optional
            Units of the Debye-Waller temperature factors in the structure file
            appropriate inputs are B (crystallographic temperature factor),
            urms (root mean squared displacement) and ums (mean squared
            displacement, the default)
        atomic_coordinates : string, optional
            Units of the atomic coordinates can be &#34;fractional&#34; or &#34;cartesian&#34;
        EPS : float,optional
            Tolerance for procedures such as psuedo-rational tiling for
            non-orthorhombic crystal unit cells
        T : (3,3) array_like or None
            An optional transformation matrix to be applied to the unit cell
            and the atomic coordinates
        &#34;&#34;&#34;
        f = open(fnam, &#34;r&#34;)

        ext = splitext(fnam)[1].lower()

        # Read title
        Title = f.readline().strip()

        if ext == &#34;.p1&#34;:

            # I have no idea what the second line in the p1 file format means
            # so ignore it
            f.readline()

            # Get unit cell vector - WARNING assume an orthorhombic unit cell
            unitcell = np.loadtxt(f, max_rows=3, dtype=np.float)

            # Get the atomic symbol of each element
            atomtypes = np.loadtxt(f, max_rows=1, dtype=str, ndmin=1)  # noqa

            # Get the number of atoms of each type
            natoms = np.loadtxt(f, max_rows=1, dtype=int, ndmin=1)

            # Skip empty line
            f.readline()

            # Total number of atoms
            totnatoms = np.sum(natoms)
            # Intialize array containing atomic information
            atoms = np.zeros((totnatoms, 6))
            dwf = np.zeros((totnatoms,))
            occ = np.zeros((totnatoms,))

            for i in range(totnatoms):
                atominfo = split(r&#34;\s+&#34;, f.readline().strip())[:6]
                # First three entries are the atomic coordinates
                atoms[i, :3] = np.asarray(atominfo[:3], dtype=np.float)
                # Fourth entry is the atomic symbol
                atoms[i, 3] = atomic_symbol.index(
                    match(&#34;([A-Za-z]+)&#34;, atominfo[3]).group(0)
                )
                # Final entries are the fractional occupancy and the temperature
                # (Debye-Waller) factor
                occ[i] = atominfo[4]
                dwf[i] = atominfo[5]

        elif ext == &#34;.xyz&#34;:
            # Read in unit cell dimensions
            unitcell = np.asarray(
                [float(x) for x in split(r&#34;\s+&#34;, f.readline().strip())[:3]]
            )

            atoms = []
            for line in f:

                # Look for end of file marker
                if line.strip() == &#34;-1&#34;:
                    break
                # Otherwise parse line
                atoms.append(
                    np.array([float(x) for x in split(r&#34;\s+&#34;, line.strip())[:6]])
                )

            # Now stack all atoms into numpy array
            atoms_ = np.stack(atoms, axis=0)

            # Rearrange columns of numpy array to match standard
            totnatoms = atoms_.shape[0]
            atoms = np.zeros((totnatoms, 4))
            # Atomic coordinates
            atoms[:, :3] = atoms_[:, 1:4]
            # Atomic numbers (Z)
            atoms[:, 3] = atoms_[:, 0]
            # Fractional occupancy and Debye-Waller (temperature) factor
            dwf = atoms_[:, 5]
            occ = atoms_[:, 4]
        else:
            print(&#34;File extension: {0} not recognized&#34;.format(ext))
            return None

        # Close file
        f.close()

        # If temperature factors are given in any other format than mean square
        # (ums) convert to mean square. Acceptable formats are crystallographic
        # temperature factor B and root mean square (urms) displacements
        if temperature_factor_units == &#34;B&#34;:
            dwf *= 1 / (8 * np.pi ** 2)
        elif temperature_factor_units == &#34;urms&#34;:
            dwf = dwf ** 2
        elif temperature_factor_units == &#34;ums&#34;:
            pass
        else:
            raise ValueError(&#34;Unrecognized temperature factor units&#34;)

        # If necessary, Convert atomic positions to fractional coordinates
        if atomic_coordinates == &#34;cartesian&#34;:
            atoms[:, :3] /= unitcell[:3][np.newaxis, :]
            atoms[:, :3] = atoms[:, :3] % 1.0

        if T is not None:
            # Transform atoms to cartesian basis and then apply transformation
            # matrix
            atoms[:, :3] = (T @ unitcell @ atoms[:, :3].T).T

            # Apply transformation matrix to unit-cell
            unitcell = unitcell @ T.T

            # Apply inverse of unit cell
            atoms[:, :3] = (np.linalg.inv(unitcell) @ atoms[:, :3].T).T

        return cls(unitcell, atoms[:, :4], dwf, occ, Title, EPS=EPS)

    @classmethod
    def from_ase_cluster(cls, asecell, occupancy=None, Title=&#34;&#34;, dwf=None):
        &#34;&#34;&#34;Initialize from Atomic Simulation Environment (ASE) cluster object.&#34;&#34;&#34;
        unitcell = asecell.cell[:]
        natoms = asecell.numbers.shape[0]
        atoms = np.concatenate(
            [
                asecell.cell.scaled_positions(asecell.positions),
                asecell.numbers.reshape(natoms, 1),
            ],
            axis=1,
        )
        if occupancy is None:
            occ = np.ones(natoms)
        if dwf is None:
            dwf = np.ones(natoms) * 3 / np.pi ** 2 / 8
        return cls(unitcell, atoms, dwf, occ, Title)

    def to_ase_atoms(self):
        &#34;&#34;&#34;Convert structure to Atomic Simulation Environment (ASE) atoms object.&#34;&#34;&#34;
        scaled_positions = self.atoms[:, :3]
        numbers = self.atoms[:, 3].astype(np.int)
        cell = self.unitcell
        pbc = [True, True, True]
        return ase.Atoms(
            scaled_positions=scaled_positions, numbers=numbers, cell=cell, pbc=pbc
        )

    def orthorhombic_supercell(self, EPS=1e-2):
        &#34;&#34;&#34;
        Create an orthorhombic supercell from a monoclinic crystal unit cell.

        If not orthorhombic attempt psuedo rational tiling of general
        monoclinic structure. Assumes that the self.unitcell matrix is lower
        triangular.
        &#34;&#34;&#34;
        if not np.abs(np.dot(self.unitcell[0], self.unitcell[1])) &lt; EPS:
            tiley, tilex = psuedo_rational_tiling(*self.unitcell[0:2, 0], EPS)

            # Make deepcopy of old unit cell

            olduc = copy.deepcopy(self.unitcell)

            # Tile out atoms
            self.tile(tiley, tilex, 1)

            # Calculate size of old unit cell under tiling
            olduc = np.asarray([tiley, tilex, 1])[:, np.newaxis] * olduc

            self.unitcell = copy.deepcopy(olduc)
            self.unitcell[1, 0] = 0.0

            # Now calculate fractional coordinates in new orthorhombic cell
            self.atoms[:, :3] = change_of_basis(self.atoms[:, :3], self.unitcell, olduc)
        else:
            self.unitcell[0, 1:] = 0.0
            self.unitcell[1, ::2] = 0.0

        # Now tile crystal in x and y
        tilez1, tiley = psuedo_rational_tiling(*self.unitcell[::-2, 0], EPS)
        tilez2, tilex = psuedo_rational_tiling(*self.unitcell[3:0:-1, 1], EPS)
        tilez = remove_common_factors([tilez1, tilez2, tilez1 * tilez2])[-1]
        tiley *= tilez // tilez1
        tilex *= tilez // tilez2

        olduc = copy.deepcopy(self.unitcell)

        # Tile out atoms
        self.tile(tiley, tilex, tilez)

        # Calculate size of old unit cell under tiling

        olduc = np.asarray([tiley, tilex, tilez])[:, np.newaxis] * olduc

        self.unitcell = copy.deepcopy(olduc)
        self.unitcell[2, 0:2] = 0.0

        # Now calculate fractional coordinates in new orthorhombic cell
        self.atoms[:, :3] = np.mod(
            self.atoms[:, :3] @ olduc @ np.linalg.inv(self.unitcell), 1.0
        )
        self.unitcell = np.diag(self.unitcell)

        # Check for negative values of self.unitcell and rectify
        for i in range(3):
            if self.unitcell[i] &lt; 0:
                self.atoms[:, i] = (1.0 - self.atoms[:, i]) % 1.0
        self.unitcell = np.abs(self.unitcell)

    def quickplot(
        self, atomscale=None, cmap=plt.get_cmap(&#34;Dark2&#34;), block=True, colors=None
    ):
        &#34;&#34;&#34;
        Make a quick 3D scatter plot of the atomic sites within the structure.

        For more detailed visualization output the structure file to a file format
        readable by the Vesta software using output_vesta_xtl
        &#34;&#34;&#34;
        from mpl_toolkits.mplot3d import Axes3D  # NOQA

        if atomscale is None:
            atomscale = 1e-3 * np.amax(self.unitcell)

        fig = plt.figure()
        ax = fig.add_subplot(111, projection=&#34;3d&#34;)

        if colors is None:
            colors = cmap(self.atoms[:, 3] / np.amax(self.atoms[:, 3]))
        sizes = self.atoms[:, 3] * atomscale

        ax.scatter(
            *[self.atoms[:, i] * self.unitcell[i] for i in [1, 0, 2]], c=colors, s=sizes
        )

        ax.set_xlim3d(0.0, self.unitcell[1])
        ax.set_ylim3d(top=0.0, bottom=self.unitcell[0])
        ax.set_zlim3d(top=0.0, bottom=self.unitcell[2])
        ax.set_xlabel(&#34;x&#34;)
        ax.set_ylabel(&#34;y&#34;)
        ax.set_zlabel(&#34;z&#34;)

        plt.show(block=block)
        return fig

    def output_vesta_xtl(self, fnam):
        &#34;&#34;&#34;Output an .xtl file which is viewable by the vesta software.

        See K. Momma and F. Izumi, &#34;VESTA 3 for three-dimensional visualization
        of crystal, volumetric and morphology data,&#34; J. Appl. Crystallogr., 44,
        1272-1276 (2011).

        Warning: Vesta xtl files do not contain fractional occupancy information
        &#34;&#34;&#34;
        f = open(splitext(fnam)[0] + &#34;.xtl&#34;, &#34;w&#34;)
        f.write(&#34;TITLE &#34; + self.Title + &#34;\n CELL \n&#34;)
        f.write(&#34;  {0:.5f} {1:.5f} {2:.5f} 90 90 90\n&#34;.format(*self.unitcell))
        f.write(&#34;SYMMETRY NUMBER 1\n SYMMETRY LABEL  P1\n ATOMS \n&#34;)
        f.write(&#34;NAME         X           Y           Z&#34; + &#34;\n&#34;)
        for i in range(self.atoms.shape[0]):
            f.write(
                &#34;{0} {1:.4f} {2:.4f} {3:.4f}\n&#34;.format(
                    atomic_symbol[int(self.atoms[i, 3])], *self.atoms[i, :3]
                )
            )
        f.write(&#34;EOF&#34;)
        f.close()

    def output_xyz(
        self, fnam, atomic_coordinates=&#34;cartesian&#34;, temperature_factor_units=&#34;sqrturms&#34;
    ):
        &#34;&#34;&#34;
        Output an .xyz structure file.

        This is the input format used by Kirkland&#39;s EM codes and the prismatic
        software.
        &#34;&#34;&#34;
        f = open(splitext(fnam)[0] + &#34;.xyz&#34;, &#34;w&#34;)
        f.write(self.Title + &#34;\n {0:.4f} {1:.4f} {2:.4f}\n&#34;.format(*self.unitcell))

        if atomic_coordinates == &#34;cartesian&#34;:
            coords = self.atoms[:, :3] * self.unitcell
        else:
            coords = self.atoms[:, :3]

        # If temperature factors are given as B then convert to urms
        if temperature_factor_units == &#34;B&#34;:
            DWFs = self.atoms[:, 5] * 8 * np.pi ** 2
        elif temperature_factor_units == &#34;sqrturms&#34;:
            DWFs = np.sqrt(self.atoms[:, 5])

        for coord, atom, DWF in zip(coords, self.atoms, DWFs):
            f.write(
                &#34;{0:d} {1:.4f} {2:.4f} {3:.4f} {4:.2f}  {5:.3f}\n&#34;.format(
                    int(atom[3]), *coord, atom[4], DWF
                )
            )
        f.write(&#34;-1&#34;)
        f.close()

    def make_potential(
        self,
        pixels,
        subslices=[1.0],
        tiling=[1, 1],
        displacements=True,
        fractional_occupancy=True,
        fe=None,
        device=None,
        dtype=torch.float32,
        seed=None,
    ):
        &#34;&#34;&#34;
        Generate the projected potential of the structure.

        Calculate the projected electrostatic potential for a structure on a
        pixel grid with dimensions specified by pixels. Subslicing the unit
        cell is achieved by passing an array subslices that contains as its
        entries the depths at which each subslice should be terminated in units
        of fractional coordinates. Tiling of the unit cell (often necessary to
        make a sufficiently large simulation grid to fit the probe) is achieved
        by passing the tiling factors in the array tiling.

        Parameters
        ----------
        pixels: int, (2,) array_like
            The pixel size of the grid on which to calculate the projected
            potentials
        subslices: float, array_like, optional
            An array containing the depths at which each slice ends as a fraction
            of the simulation unit-cell
        tiling: int, (2,) array_like, optional
            Tiling of the simulation object (often necessary to  make a
            sufficiently large simulation grid to fit the probe)
        displacements: bool, optional
            Pass displacements = False to turn off random displacements of the
            atoms due to thermal motion
        fractional_occupancy: bool, optional
            Pass fractional_occupancy = False to turn off fractional occupancy
            of atomic sites
        fe: float, array_like
            An array containing the electron scattering factors for the elements
            in the structure as calculated by the function
            calculate_scattering_factors, can be passed to save recalculating
            each time new potentials are generated
        device: torch.device
            Allows the user to control which device the calculations will occur
            on
        dtype: torch.dtype
            Controls the data-type of the output
        seed: int
            Seed for random number generator for atomic displacements.
        &#34;&#34;&#34;
        # Initialize device cuda if available, CPU if no cuda is available
        device = get_device(device)

        # Ensure pixels is integer
        pixels_ = [int(x) for x in pixels]

        # Seed random number generator for displacements
        if seed is not None:
            torch.manual_seed(seed)

        tiling_ = np.asarray(tiling[:2])
        gsize = np.asarray(self.unitcell[:2]) * tiling_
        psize = np.asarray(pixels_)

        pixperA = np.asarray(pixels_) / np.asarray(self.unitcell[:2]) / tiling_

        # Get a list of unique atomic elements
        elements = list(set(np.asarray(self.atoms[:, 3], dtype=np.int)))

        # Get number of unique atomic elements
        nelements = len(elements)
        nsubslices = len(subslices)
        # Build list of equivalent sites if Fractional occupancy is to be
        # taken into account
        if fractional_occupancy and self.fractional_occupancy:
            equivalent_sites = find_equivalent_sites(self.atoms[:, :3], EPS=1e-3)

        # FDES method
        # Intialize potential array
        P = torch.zeros(
            np.prod([nelements, nsubslices, *pixels_, 2]), device=device, dtype=dtype
        )

        # Construct a map of which atom corresponds to which slice
        islice = np.zeros((self.atoms.shape[0]), dtype=np.int)
        slice_stride = np.prod(pixels_) * 2
        # if nsubslices &gt; 1:
        # Finds which slice atom can be found in
        # WARNING Assumes that the slices list ends with 1.0 and is in
        # ascending order
        for i in range(nsubslices):
            zmin = 0 if i == 0 else subslices[i - 1]
            atoms_in_slice = (self.atoms[:, 2] % 1.0 &gt;= zmin) &amp; (
                self.atoms[:, 2] % 1.0 &lt; subslices[i]
            )
            islice[atoms_in_slice] = i * slice_stride
        islice = torch.from_numpy(islice).type(torch.long).to(device)
        # else:
        #     islice = 0
        # Make map a pytorch Tensor

        # Construct a map of which atom corresponds to which element
        element_stride = nsubslices * slice_stride
        ielement = torch.tensor(
            [
                element_stride * elements.index(int(self.atoms[iatom, 3]))
                for iatom in range(self.atoms.shape[0])
            ],
            dtype=torch.long,
            device=device,
        )

        if displacements:
            # Generate thermal displacements
            urms = torch.tensor(
                np.sqrt(self.atoms[:, 5])[:, np.newaxis] * pixperA[np.newaxis, :],
                dtype=P.dtype,
                device=device,
            ).view(self.atoms.shape[0], 2)

        # FDES algorithm implemented using the pytorch scatter_add function,
        # which takes a list of numbers and adds them to a corresponding list
        # of coordinates
        for tile in range(tiling[0] * tiling[1]):
            # For these atomic coordinates (in fractional coordinates) convert
            # to pixel coordinates
            posn = (
                (
                    self.atoms[:, :2]
                    + np.asarray([tile % tiling[0], tile // tiling[0]])[np.newaxis, :]
                )
                / tiling_
                * psize
            )
            posn = torch.from_numpy(posn).to(device).type(P.dtype)

            if displacements:

                # Add displacement sampled from normal distribution to account
                # for atomic thermal motion
                disp = (
                    torch.randn(self.atoms.shape[0], 2, dtype=P.dtype, device=device)
                    * urms
                )

                # If using fractional occupancy force atoms occupying equivalent
                # sites to have the same displacement
                if fractional_occupancy and self.fractional_occupancy:
                    disp = disp[equivalent_sites, :]

                posn[:, :2] += disp

            yc = (
                torch.remainder(torch.ceil(posn[:, 0]).type(torch.long), pixels_[0])
                * pixels_[1]
                * 2
            )
            yf = (
                torch.remainder(torch.floor(posn[:, 0]).type(torch.long), pixels_[0])
                * pixels_[1]
                * 2
            )
            xc = (
                torch.remainder(torch.ceil(posn[:, 1]).type(torch.long), pixels_[1]) * 2
            )
            xf = (
                torch.remainder(torch.floor(posn[:, 1]).type(torch.long), pixels_[1])
                * 2
            )

            yh = torch.remainder(posn[:, 0], 1.0)
            yl = 1.0 - yh
            xh = torch.remainder(posn[:, 1], 1.0)
            xl = 1.0 - xh

            # Account for fractional occupancy of atomic sites if requested
            if fractional_occupancy and self.fractional_occupancy:
                xh *= torch.from_numpy(self.atoms[:, 4]).type(P.dtype).to(device)
                xl *= torch.from_numpy(self.atoms[:, 4]).type(P.dtype).to(device)

            # Each pixel is set to the overlap of a shifted rectangle in that pixel
            P.scatter_add_(0, ielement + islice + yc + xc, yh * xh)
            P.scatter_add_(0, ielement + islice + yc + xf, yh * xl)
            P.scatter_add_(0, ielement + islice + yf + xc, yl * xh)
            P.scatter_add_(0, ielement + islice + yf + xf, yl * xl)

        # Now view potential as a 4D array for next bit
        P = P.view(nelements, nsubslices, *pixels_, 2)

        # FFT potential to reciprocal space
        for i in range(P.shape[0]):
            for j in range(P.shape[1]):
                P[i, j] = torch.fft(P[i, j], signal_ndim=2)

        # Make sinc functions with appropriate singleton dimensions for pytorch
        # broadcasting /gridsize[0]*pixels_[0] /gridsize[1]*pixels_[1]
        sincy = (
            sinc(torch.from_numpy(np.fft.fftfreq(pixels_[0])))
            .view([1, 1, pixels_[0], 1, 1])
            .to(device)
            .type(P.dtype)
        )
        sincx = (
            sinc(torch.from_numpy(np.fft.fftfreq(pixels_[1])))
            .view([1, 1, 1, pixels_[1], 1])
            .to(device)
            .type(P.dtype)
        )
        # #Divide by sinc functions
        P /= sincy
        P /= sincx

        # Option to precalculate scattering factors and pass to program which
        # saves computation for
        if fe is None:
            fe_ = calculate_scattering_factors(psize, gsize, elements)
        else:
            fe_ = fe

        # Convolve with electron scattering factors using Fourier convolution theorem
        P *= torch.from_numpy(fe_).view(nelements, 1, *pixels_, 1).to(device)

        norm = np.prod(pixels_) / np.prod(self.unitcell[:2]) / np.prod(tiling)
        # Add atoms together
        P = norm * torch.sum(P, dim=0)

        # Only return real part
        return torch.ifft(P, signal_ndim=2)[..., 0]

    def make_transmission_functions(
        self,
        pixels,
        eV,
        subslices=[1.0],
        tiling=[1, 1],
        fe=None,
        displacements=True,
        fftout=True,
        dtype=None,
        device=None,
        fractional_occupancy=True,
        seed=None,
        bandwidth_limit=2 / 3,
    ):
        &#34;&#34;&#34;
        Make the transmission functions for the simulation object.

        Transmission functions are the exponential of the specimen electrostatic
        potential scaled by the interaction constant for electrons, sigma. These
        are used to model scattering by a thin slice of the object in the
        multislice algorithm

        Parameters:
        -----------
        pixels : array_like
            Output pixel grid
        eV : float
            Probe accelerating voltage in electron-volts
        subslices : array_like, optional
            An array containing the depths at which each slice ends as a fraction
            of the simulation unit-cell, used for simulation objects thicker
            than typical multislice slicing (about 2 Angstrom)
        tiling : array_like,optional
            Repeat tiling of the simulation object
        fe: array_like,optional
            An array containing the electron scattering factors for the elements
            in the simulation object as calculated by the function
            calculate_scattering_factors
        &#34;&#34;&#34;
        # Make the specimen electrostatic potential
        T = self.make_potential(
            pixels,
            subslices,
            tiling,
            fe=fe,
            displacements=displacements,
            device=device,
            dtype=dtype,
            fractional_occupancy=fractional_occupancy,
            seed=seed,
        )

        # Now take the complex exponential of the electrostatic potential
        # scaled by the electron interaction constant
        T = torch.fft(torch_c_exp(interaction_constant(eV) * T), signal_ndim=2)

        # Band-width limit the transmission function, see Earl Kirkland&#39;s book
        # for an discussion of why this is necessary
        for i in range(T.shape[0]):
            T[i] = bandwidth_limit_array(T[i], bandwidth_limit)

        if fftout:
            return torch.ifft(T, signal_ndim=2)
        return T

    def generate_slicing_figure(self, slices, show=True):
        &#34;&#34;&#34;
        Generate slicing figure.

        Generate a slicing figure that to aid in setting up the slicing
        of the sample for multislice algorithm. This will show where each of the
        slices end for a chosen slicing relative to the atoms. To minimize
        errors, the atoms should sit as close to the top of the slice as possible.

        Parameters
        ----------
        slices: array_like, float
            An array containing the depths at which each slice ends as a fraction
            of the simulation unit-cell
        &#34;&#34;&#34;
        fig, ax = plt.subplots(ncols=2, figsize=(8, 4))

        coords = self.atoms[:, :3] * self.unitcell[None, :]
        # Projection down the x-axis
        for i in range(2):
            ax[i].plot(coords[:, i], coords[:, 2], &#34;bo&#34;, label=&#34;Atoms&#34;)
            for j, slice_ in enumerate(slices):
                if j == 0:
                    label = &#34;Slices&#34;
                else:
                    label = &#34;_&#34;
                ax[i].plot(
                    [0, self.unitcell[i]],
                    [slice_ * self.unitcell[2], slice_ * self.unitcell[2]],
                    &#34;r--&#34;,
                    label=label,
                )
            ax[i].set_xlim([0, self.unitcell[i]])
            ax[i].set_xlabel([&#34;y&#34;, &#34;x&#34;][i])
            ax[i].set_ylim([self.unitcell[2], 0])
            ax[i].set_ylabel(&#34;z&#34;)
            ax[i].set_title(&#34;View down {0} axis&#34;.format([&#34;x&#34;, &#34;y&#34;][i]))
        ax[0].legend()
        if show:
            plt.show(block=True)
        return fig

    def rotate(self, theta, axis, origin=[0.5, 0.5, 0.5]):
        &#34;&#34;&#34;
        Rotate simulation object an amount an angle theta (in radians) about axis.

        Parameters
        ----------
        theta: float
            Angle to rotate simulation object by in radians
        axis: array_like
            Axis about which to rotate simulation object eg [0,0,1]

        Keyword arguments
        ------------------
        origin : array_like, optional
            Origin (in fractional coordinates) about which to rotate simulation
            object eg [0.5, 0.5, 0.5]
        &#34;&#34;&#34;
        new = copy.deepcopy(self)

        # Make rotation matrix, R, and  the point about which we rotate, O
        R = rot_matrix(theta, axis)
        origin_ = np.asarray(origin) * self.unitcell

        # Get atomic coordinates in cartesian (not fractional coordinates)
        new.atoms[:, :3] = self.atoms[:, :3] * self.unitcell[np.newaxis, :]

        # Apply rotation matrix to each atom coordinate
        new.atoms[:, :3] = (new.atoms[:, :3] - origin_) @ R + origin_

        # Apply rotation matrix to cell vertices
        vertices = (
            np.asarray([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]])
            * self.unitcell
            - origin_
        ) @ R + origin_

        # Get new unit cell from maximum range of unit cell vertices
        origin_ = np.amin(vertices, axis=0)
        new.unitcell = np.ptp(vertices, axis=0)

        # Convert atoms back into fractional coordinates in new unit cell
        new.atoms[:, :3] = ((new.atoms[:, :3] - origin_) / new.unitcell) % 1.0

        # Return rotated structure
        return new

    def rot90(self, k=1, axes=(0, 1)):
        &#34;&#34;&#34;
        Rotates a structure by 90 degrees in the plane specified by axes.

        Rotation direction is from the first towards the second axis.

        Parameters
        ----------
        k : integer, optional
            Number of times the structure is rotated by 90 degrees.
        axes: (2,) array_like
            The array is rotated in the plane defined by the axes.
            Axes must be different.
        &#34;&#34;&#34;
        # Much of the following is adapted from the numpy.rot90 function
        axes = tuple(axes)
        if len(axes) != 2:
            raise ValueError(&#34;len(axes) must be 2.&#34;)

        k %= 4

        if k == 0:
            # Do nothing
            return
        if k == 2:
            # Reflect in both axes
            self.reflect(axes)
            return

        axes_list = np.arange(0, 3)
        (axes_list[axes[0]], axes_list[axes[1]]) = (
            axes_list[axes[1]],
            axes_list[axes[0]],
        )

        if k == 1:
            self.reflect([axes[1]])
            self.transpose(axes_list)
        else:
            # k == 3
            self.transpose(axes_list)
            self.reflect([axes[1]])

        return self

    def transpose(self, axes):
        &#34;&#34;&#34;Transpose the axes of a simulation object.&#34;&#34;&#34;
        self.atoms[:, :3] = self.atoms[:, axes]
        self.unitcell = self.unitcell[axes]
        return self

    def tile(self, x=1, y=1, z=1):
        &#34;&#34;&#34;Make a repeat unit tiling of the simulation object.&#34;&#34;&#34;
        # Make copy of original structure
        # new = copy.deepcopy(self)

        tiling = np.asarray([x, y, z], dtype=np.int)

        # Get atoms in unit cell
        natoms = self.atoms.shape[0]

        # Initialize new atom list
        newatoms = np.zeros((natoms * x * y * z, 6))

        # Calculate new unit cell size
        self.unitcell = self.unitcell * np.asarray([x, y, z])

        # tile out the integer amounts
        from itertools import product

        for j, k, l in product(*[np.arange(int(i)) for i in [x, y, z]]):

            # Calculate origin of this particular tile
            origin = np.asarray([j, k, l])

            # Calculate index of this particular tile
            indx = j * int(y) * int(z) + k * int(z) + l

            # Add new atoms to unit cell
            newatoms[indx * natoms : (indx + 1) * natoms, :3] = (
                self.atoms[:, :3] + origin[np.newaxis, :]
            ) / tiling[np.newaxis, :]

            # Copy other information about atoms
            newatoms[indx * natoms : (indx + 1) * natoms, 3:] = self.atoms[:, 3:]
        self.atoms = newatoms
        return self

    def concatenate(self, other, axis=2, side=1, eps=1e-2):
        &#34;&#34;&#34;
        Concatenate two simulation objects.

        Adds other simulation object to the current object. other is added to
        the bottom (top being z =0) routine will attempt to tile objects to
        match dimensions.

        Parameters:
        other : structure class
            Object that will be concatenated onto the other object.
        axis : int, optional
            Axis along which the two structures will be joined.
        side : int, optional
            Determines which side the other structure will be added onto the
            first structure. If side == 0 the structures will be added onto each
            other at the origin, if side == 1 the structures will be added onto
            each other at the end.
        eps : float, optional
            Fractional tolerance of the psuedo rational tiling to make the
            structure dimensions perpendicular to the beam direction match.
        &#34;&#34;&#34;
        # Make deep copies of the structure object and the slice this is so
        # that these objects remain untouched by the operation of this function
        new = copy.deepcopy(self)
        other_ = copy.deepcopy(other)

        tile1, tile2 = [np.ones(3, dtype=np.int) for i in range(2)]

        # Check if the two slices are the same size and
        # tile accordingly
        for ax in range(3):
            # If this axis is the concatenation axis, then it&#39;s not necessary
            # that the structures are the same size
            if ax == axis:
                continue
            # Calculate the psuedo-rational tiling
            if self.unitcell[ax] &lt; other.unitcell[ax]:
                tile1[ax], tile2[ax] = psuedo_rational_tiling(
                    self.unitcell[ax], other.unitcell[ax], eps
                )
            else:
                tile2[ax], tile1[ax] = psuedo_rational_tiling(
                    other.unitcell[ax], self.unitcell[ax], eps
                )

            tile1[ax], tile2[ax] = psuedo_rational_tiling(
                self.unitcell[ax], other.unitcell[ax], eps
            )

        new = new.tile(*tile1)
        tiled_zdim = new.unitcell[axis]
        other_ = other_.tile(*tile2)

        # Update the thickness of the resulting structure object.
        new.unitcell[axis] = tiled_zdim + other_.unitcell[axis]

        # Adjust fractional coordinates of atoms, multiply by old unitcell
        # size to transform into cartesian coordinates and then divide by
        # the old unitcell size to transform into fractional coordinates
        # in the new basis
        new.atoms[:, axis] *= tiled_zdim / new.unitcell[axis]
        other_.atoms[:, axis] *= other_.unitcell[axis] / new.unitcell[axis]

        # Adjust the coordinates of the new or old atoms depending on which
        # side the new structure is to be added.
        if side == 0:
            new.atoms[:, axis] += other_.unitcell[axis] / new.unitcell[axis]
        else:
            other_.atoms[:, axis] += self.unitcell[axis] / new.unitcell[axis]

        # Concatenate adjusted atomic coordinates
        new.atoms = np.concatenate([new.atoms, other_.atoms], axis=0)

        # Concatenate titles
        new.Title = self.Title + &#34; and &#34; + other.Title

        return new

    def reflect(self, axes):
        &#34;&#34;&#34;Reflect structure in each of the axes enumerated in list axes.&#34;&#34;&#34;
        for ax in axes:
            self.atoms[:, ax] = (1 - self.atoms[:, ax]) % 1.0
        return self

    def resize(self, fraction, axis):
        &#34;&#34;&#34;
        Resize (either crop or pad with vacuum) the simulation object.

        Resize the simulation object ranging such that the new axis runs from
        fraction[iax,0] to fraction[iax,1] on specified axis iax, slice_frac is
        in units of fractional coordinates. If fraction[iax,0] is &lt; 0 then
        additional vacuum will be added, if &gt; 0 then parts of the sample will
        be removed for axis[iax]. Likewise if fraction[iax,1] is &gt; 1 then
        additional vacuum will be added, if &lt; 1 then parts of the sample will
        be removed for axis[iax].

        Parameters
        ----------
        fraction : (nax,2) array_like
            Describes the size of the new simulation object as a fraction of
            old simulation object dimensions.
        axis : int or (nax,) array_like
            The axes of the simulation object that wil lbe resized

        Returns
        -------
        New structure : pyms.structure object
            The resized structure object
        &#34;&#34;&#34;
        ax = ensure_array(axis)
        frac = ensure_array(fraction)
        if np.asarray(frac).ndim &lt; 2:
            frac = [frac]

        # Work out which atoms will stay in the sliced structure
        mask = np.ones((self.atoms.shape[0],), dtype=np.bool)
        for a, f in zip(ax, frac):
            atomsin = np.logical_and(self.atoms[:, a] &gt;= f[0], self.atoms[:, a] &lt;= f[1])
            mask = np.logical_and(atomsin, mask)

        # Make a copy of the structure
        new = copy.deepcopy(self)

        # Put remaining atoms back in
        new.atoms = self.atoms[mask, :]

        # Origin for atomic coordinates
        origin = np.zeros((3))

        for a, f in zip(ax, frac):
            # Adjust unit cell dimensions
            new.unitcell[a] = (f[1] - f[0]) * self.unitcell[a]

            # Adjust origin of atomic coordinates
            origin[a] = f[0]

        new.atoms[:, :3] = (new.atoms[:, :3] - origin) * self.unitcell / new.unitcell

        # Return modified structure
        return new

    def cshift(self, shift, axis):
        &#34;&#34;&#34;
        Circular shift routine.

        Shift the atoms within the simulation cell an amount shift in fractional
        coordinates along specified axis (or axes if both shift and axis are
        array_like).

        Parameters
        ----------
        shift : array_like or int
            Amount in fractional coordinates to shift (each) axis.
        axis : array_like or int
            Axis or list of axes to apply shift(s) to.
        &#34;&#34;&#34;

        def _cshift(atoms, x, ax):
            atoms[:, ax % 3] = np.mod(atoms[:, ax % 3] + x, 1.0)
            return atoms

        if hasattr(axis, &#34;__len__&#34;):
            for x, ax in zip(shift, axis):
                self.atoms = _cshift(self.atoms, x, ax)
        else:
            self.atoms = _cshift(self.atoms, shift, axis)

        return self


class layered_structure_transmission_function:
    &#34;&#34;&#34;
    A class that mimics multislice transmission functions for a layered object.

    Useful for performing multislice calculations of heterostructures (epitaxially
    layered cystalline structures).
    &#34;&#34;&#34;

    def __init__(
        self,
        gridshape,
        eV,
        structures,
        nslices,
        subslices,
        tilings=None,
        kwargs={},
        nT=5,
        dtype=torch.float32,
        device=None,
        specimen_tilt=[0, 0],
    ):
        &#34;&#34;&#34;
        Generate a layered structure transmission function object.

        This function assumes that the lateral (x and y) cell sizes of the
        structures are identical,

        Input
        -----
        structures : (N,) array_like of pyms.Structure objects
            The input structures for which the transmission functions for a
            layered structure will be calculated.
        nslices : int (N,) array_like
            The number of units of each structure in the multilayer
        subslices : array_like (N,) of array_like
            Multislice subslicing for each object in the multilayer structure

        Returns
        -----
        self : layered_structure_transmission_function object
            This will behave like a normal transmission function array, if
            T = layered_structure_transmission_function(...,[structure1,structure2 etc])
            then T[0,islice,...] will return a transmission function from whichever
            structure islice happens to be in. T.Propagator[islice] returns the
            relevant multislice propagator
        &#34;&#34;&#34;
        self.dtype = dtype
        self.device = get_device(device)
        self.nslicestot = np.sum(nslices)
        self.structures = structures

        if tilings is None:
            tilings = len(structures) * [[1, 1]]

        self.Ts = []
        self.nT = nT
        self.gridshape = gridshape
        self.tilings = tilings
        self.eV = eV
        self.specimen_tilt = specimen_tilt
        self.unitcell = np.zeros(3)
        self.unitcell[:2] = structures[0].unitcell[:2]  # * np.asarray(tilings[0])
        self.unitcell[2] = np.sum(
            [struc.unitcell[2] * nslice for struc, nslice in zip(structures, nslices)]
        )
        args = [gridshape, eV]

        # Like every Melbourne restaurant, within the slab structure we do things
        # a little differently: since the number of subslices can be different
        # for each structure we have to store the transmission functions for
        #  each structure in a list so the indexing of self.Ts is
        # self.Ts[istructure][iT][isubslice], the __get_item__ method
        # makes indexing this synthetic object consistent with standard practice
        for structure, subslices_, tiling in zip(structures, subslices, tilings):
            self.Ts.append(
                torch.stack(
                    [
                        structure.make_transmission_functions(
                            *args,
                            subslices=subslices_,
                            tiling=tiling,
                            **kwargs,
                            device=self.device,
                            dtype=self.dtype,
                        )
                        for i in range(nT)
                    ]
                )
            )

        self.slicemap = list(
            itertools.chain(
                *[len(subslices[i]) * n * [i] for i, n in enumerate(nslices)]
            )
        )
        nsubslices = [len(subslice) for subslice in subslices]
        self.subslicemap = list(
            itertools.chain(
                *[
                    (np.arange(nsubslices[i] * n) % nsubslices[i]).tolist()
                    for i, n in enumerate(nslices)
                ]
            )
        )
        self.N = len(self.slicemap)
        self.subslices = []
        T = 0
        # Calculate the fractional depth of every subslice in the new synthetic
        # structure.
        for subslices_, slices, struct in zip(subslices, nslices, structures):
            for i in range(slices):
                self.subslices += (
                    (np.asarray(subslices_) * struct.unitcell[2] + T) / self.unitcell[2]
                ).tolist()
                T = T + struct.unitcell[2]

        # Mimics the shape property of a numpy array
        self.shape = (self.nT, self.N, *self.gridshape, 2)
        self.Propagator = layered_structure_propagators(
            self, subslices, propkwargs={&#34;tilt&#34;: specimen_tilt}
        )

    def dim(self):
        &#34;&#34;&#34;Return the array dimension of the synthetic array.&#34;&#34;&#34;
        return 4

    def __getitem__(self, ind):
        &#34;&#34;&#34;
        __getitem__ method for the transmission function synthetic array.

        This enables the transmission function object to mimic a standard
        transmission function numpy or torch.Tensor array
        &#34;&#34;&#34;
        it, islice = ind[:2]

        # First get the proper slice and subslice, self.Ts is a list object
        # with each entry containing the transmission functions for that
        # structure
        if isinstance(islice, int) or np.issubdtype(
            np.asarray(islice).dtype, np.integer
        ):
            T = self.Ts[self.slicemap[islice]][:, self.subslicemap[islice]]
        elif isinstance(islice, slice):
            islice_ = np.arange(*islice.indices(self.N))
            T = torch.stack(
                [self.Ts[self.slicemap[j]][:, self.subslicemap[j]] for j in islice_],
                axis=1,
            )
        else:
            raise TypeError(&#34;Invalid argument type.&#34;)

        if isinstance(it, int) or np.issubdtype(np.asarray(it).dtype, np.integer):
            return T[it]
        elif isinstance(it, slice):
            it_ = np.arange(*it.indices(self.nT))
            return T[it_]
        else:
            raise TypeError(&#34;Invalid argument type.&#34;)


class layered_structure_propagators:
    &#34;&#34;&#34;
    A class that mimics multislice propagators for a layered object.

    Complements layered_transmission_function
    &#34;&#34;&#34;

    def __init__(self, layered_T, subslices, propkwargs={}):
        &#34;&#34;&#34;
        Generate a layered structure multislice propagator function object.

        This function assumes that the lateral (x and y) cell sizes of the
        structures are identical,

        Input
        -----
        T : layered_structure_transmission_function object
            This should contain all the neccessary information about the layered
            object to generate the propagators

        Keyword arguements:
        -------------------
        propkwargs : dict
            Keyword arguements to pass onto make_propagator function

        Returns
        -----
        self : layered_structure_propagators object
            This will behave like a normal propagator array, if
            P = layered_structure_propagators(T)
            then P[islice,...] will return a transmission function from whichever
            structure islice happens to be in.
        &#34;&#34;&#34;
        from .py_multislice import make_propagators

        self.rsizes = [
            copy.deepcopy(struc.unitcell * np.asarray(t + [1]))
            for struc, t in zip(layered_T.structures, layered_T.tilings)
        ]

        self.Ps = [
            cx_from_numpy(
                make_propagators(layered_T.gridshape, r, layered_T.eV, s, **propkwargs),
                layered_T.dtype,
                layered_T.device,
            )
            for s, r in zip(subslices, self.rsizes)
        ]
        self.slicemap = layered_T.slicemap
        self.subslicemap = layered_T.subslicemap
        # Mimics the shape property of a numpy array
        self.shape = (layered_T.nslicestot, *layered_T.gridshape, 2)
        self.ndim = 4

    def dim(self):
        &#34;&#34;&#34;Return the array dimension of the synthetic array.&#34;&#34;&#34;
        return 4

    def __getitem__(self, islice):
        &#34;&#34;&#34;
        __getitem__ method for the propagator synthetic array.

        This enables the propagator object to mimic a standard propagator numpy
        or torch.Tensor array
        &#34;&#34;&#34;
        if isinstance(islice, int) or np.issubdtype(
            np.asarray(islice).dtype, np.integer
        ):
            return self.Ps[self.slicemap[islice]][self.subslicemap[islice]]
        elif isinstance(islice, slice):
            islice_ = np.arange(*islice.indices(len(self.slicemap)))
            return torch.stack(
                [self.Ps[self.slicemap[j]][self.subslicemap[j]] for j in islice_]
            )
        else:
            raise TypeError(&#34;Invalid argument type.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyms.structure_routines.Xray_scattering_factor"><code class="name flex">
<span>def <span class="ident">Xray_scattering_factor</span></span>(<span>Z, gsq, units='A')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the X-ray scattering factor for atom with atomic number Z.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>int</code></dt>
<dd>Atomic number of atom of interest.</dd>
<dt><strong><code>gsq</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Reciprocal space value(s) in Angstrom squared at which to evaluate the
X-ray scattering factor.</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Units in which to calculate X-ray scattering factor, can be 'A' for
Angstrom, or 'VA' for volt-Angstrom.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Xray_scattering_factor(Z, gsq, units=&#34;A&#34;):
    &#34;&#34;&#34;
    Calculate the X-ray scattering factor for atom with atomic number Z.

    Parameters
    ----------
    Z : int
        Atomic number of atom of interest.
    gsq : float or array_like
        Reciprocal space value(s) in Angstrom squared at which to evaluate the
        X-ray scattering factor.
    units : string, optional
        Units in which to calculate X-ray scattering factor, can be &#39;A&#39; for
        Angstrom, or &#39;VA&#39; for volt-Angstrom.
    &#34;&#34;&#34;
    # Bohr radius in Angstrom
    a0 = 0.529177
    # gsq = g**2
    return Z - 2 * np.pi ** 2 * a0 * gsq * electron_scattering_factor(
        Z, gsq, units=units
    )</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.calculate_scattering_factors"><code class="name flex">
<span>def <span class="ident">calculate_scattering_factors</span></span>(<span>gridshape, gridsize, elements)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the electron scattering factors on a reciprocal space grid.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gridshape</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>pixel size of the grid</dd>
<dt><strong><code>gridsize</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Lateral real space sizing of the grid in Angstrom</dd>
<dt><strong><code>elements</code></strong> :&ensp;<code>(M,) array_like</code></dt>
<dd>List of elements for which electron scattering factors are required</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fe</code></strong> :&ensp;<code>(M, *gridshape)</code></dt>
<dd>Array of electron scattering factors in reciprocal space for each
element</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_scattering_factors(gridshape, gridsize, elements):
    &#34;&#34;&#34;Calculate the electron scattering factors on a reciprocal space grid.

    Parameters
    ----------
    gridshape : (2,) array_like
        pixel size of the grid
    gridsize : (2,) array_like
        Lateral real space sizing of the grid in Angstrom
    elements : (M,) array_like
        List of elements for which electron scattering factors are required

    Returns
    -------
    fe : (M, *gridshape)
        Array of electron scattering factors in reciprocal space for each
        element
    &#34;&#34;&#34;
    # Get reciprocal space array
    g = q_space_array(gridshape, gridsize)
    gsq = np.square(g[0]) + np.square(g[1])

    # Initialise scattering factor array
    fe = np.zeros((len(elements), *gridshape), dtype=np.float32)

    # Loop over unique elements
    for ielement, element in enumerate(elements):
        fe[ielement, :, :] = electron_scattering_factor(element, gsq)

    return fe</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.change_of_basis"><code class="name flex">
<span>def <span class="ident">change_of_basis</span></span>(<span>coords, newuc, olduc)</span>
</code></dt>
<dd>
<div class="desc"><p>Change of basis for structure unit cell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_of_basis(coords, newuc, olduc):
    &#34;&#34;&#34;Change of basis for structure unit cell.&#34;&#34;&#34;
    return np.mod(coords[:, :3] @ olduc @ np.linalg.inv(newuc), 1.0)</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.electron_scattering_factor"><code class="name flex">
<span>def <span class="ident">electron_scattering_factor</span></span>(<span>Z, gsq, units='VA')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the electron scattering factor for atom with atomic number Z.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>int</code></dt>
<dd>Atomic number of atom of interest.</dd>
<dt><strong><code>gsq</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Reciprocal space value(s) in Angstrom squared at which to evaluate the
electron scattering factor.</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Units in which to calculate electron scattering factor, can be 'A' for
Angstrom, or 'VA' for volt-Angstrom.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def electron_scattering_factor(Z, gsq, units=&#34;VA&#34;):
    &#34;&#34;&#34;
    Calculate the electron scattering factor for atom with atomic number Z.

    Parameters
    ----------
    Z : int
        Atomic number of atom of interest.
    gsq : float or array_like
        Reciprocal space value(s) in Angstrom squared at which to evaluate the
        electron scattering factor.
    units : string, optional
        Units in which to calculate electron scattering factor, can be &#39;A&#39; for
        Angstrom, or &#39;VA&#39; for volt-Angstrom.
    &#34;&#34;&#34;
    ai = e_scattering_factors[Z - 1, 0:10:2]
    bi = e_scattering_factors[Z - 1, 1:10:2]

    # Planck&#39;s constant in kg Angstrom/s
    h = 6.62607004e-24
    # Electron rest mass in kg
    me = 9.10938356e-31
    # Electron charge in Coulomb
    qe = 1.60217662e-19

    fe = np.zeros_like(gsq)

    for i in range(5):
        fe += ai[i] * (2 + bi[i] * gsq) / (1 + bi[i] * gsq) ** 2

    # Result can be returned in units of Volt Angstrom (&#39;VA&#39;) or Angstrom (&#39;A&#39;)
    if units == &#34;VA&#34;:
        return h ** 2 / (2 * np.pi * me * qe) * fe
    elif units == &#34;A&#34;:
        return fe</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.find_equivalent_sites"><code class="name flex">
<span>def <span class="ident">find_equivalent_sites</span></span>(<span>positions, EPS=0.001)</span>
</code></dt>
<dd>
<div class="desc"><p>Find equivalent atomic sites in a list of atomic positions object.</p>
<p>This function is used to detect two atoms sharing the same postions (are
with EPS of each other) with fractional occupancy, and return an index of
these equivalent sites.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_equivalent_sites(positions, EPS=1e-3):
    &#34;&#34;&#34;Find equivalent atomic sites in a list of atomic positions object.

    This function is used to detect two atoms sharing the same postions (are
    with EPS of each other) with fractional occupancy, and return an index of
    these equivalent sites.
    &#34;&#34;&#34;
    # Import  the pair-wise distance function from scipy
    from scipy.spatial.distance import pdist

    natoms = positions.shape[0]
    # Calculate pairwise distance between each atomic site
    distance_matrix = pdist(positions)

    # Initialize index of equivalent sites (initially assume all sites are
    # independent)
    equivalent_sites = np.arange(natoms, dtype=np.int)

    # Find equivalent sites
    equiv = distance_matrix &lt; EPS

    # If there are equivalent sites correct the index of equivalent sites
    if np.any(equiv):
        # Masking function to get indices from distance_matrix
        iu = np.mask_indices(natoms, np.triu, 1)

        # Get a list of equivalent sites
        sites = np.nonzero(equiv)[0]
        for site in sites:
            # Use the masking function to
            equivalent_sites[iu[1][site]] = iu[0][site]
    return equivalent_sites</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.interaction_constant"><code class="name flex">
<span>def <span class="ident">interaction_constant</span></span>(<span>E, units='rad/VA')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the electron interaction constant, sigma.</p>
<p>The electron interaction constant converts electrostatic potential (in V
Angstrom) to radians. Units of this constant are rad/(V Angstrom).
See
Eq. (2.5) in Kirkland's Advanced Computing in electron microscopy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interaction_constant(E, units=&#34;rad/VA&#34;):
    &#34;&#34;&#34;
    Calculate the electron interaction constant, sigma.

    The electron interaction constant converts electrostatic potential (in V
    Angstrom) to radians. Units of this constant are rad/(V Angstrom).  See
    Eq. (2.5) in Kirkland&#39;s Advanced Computing in electron microscopy.
    &#34;&#34;&#34;
    # Planck&#39;s constant in kg Angstrom /s
    h = 6.62607004e-24
    # Electron rest mass in kg
    me = 9.10938356e-31
    # Electron charge in Coulomb
    qe = 1.60217662e-19
    # Electron wave number (reciprocal of wavelength) in Angstrom
    k0 = wavev(E)
    # Relativistic electron mass correction
    gamma = relativistic_mass_correction(E)
    if units == &#34;rad/VA&#34;:
        return 2 * np.pi * gamma * me * qe / k0 / h / h
    elif units == &#34;rad/A&#34;:
        return gamma / k0</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.psuedo_rational_tiling"><code class="name flex">
<span>def <span class="ident">psuedo_rational_tiling</span></span>(<span>dim1, dim2, EPS)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the psuedo-rational tiling for matching objects of different dimensions.</p>
<p>For two dimensions, dim1 and dim2, work out the multiplicative
tiling so that those dimensions might be matched to within error EPS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def psuedo_rational_tiling(dim1, dim2, EPS):
    &#34;&#34;&#34;
    Calculate the psuedo-rational tiling for matching objects of different dimensions.

    For two dimensions, dim1 and dim2, work out the multiplicative
    tiling so that those dimensions might be matched to within error EPS.
    &#34;&#34;&#34;
    if np.any([dim1 == 0, dim2 == 0]):
        return 1, 1
    tile1 = int(np.round(np.abs(dim2 / dim1) / EPS))
    tile2 = int(np.round(1 / EPS))
    return remove_common_factors([tile1, tile2])</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.remove_common_factors"><code class="name flex">
<span>def <span class="ident">remove_common_factors</span></span>(<span>nums)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove common divisible factors from a set of numbers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_common_factors(nums):
    &#34;&#34;&#34;Remove common divisible factors from a set of numbers.&#34;&#34;&#34;
    nums = np.asarray(nums, dtype=np.int)
    g_ = np.gcd.reduce(nums)
    while g_ &gt; 1:
        nums //= g_
        g_ = np.gcd.reduce(nums)
    return nums</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.rot_matrix"><code class="name flex">
<span>def <span class="ident">rot_matrix</span></span>(<span>theta, u=array([0., 0., 1.]))</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a 3D rotational matrix.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>Angle of rotation in radians</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>(3,) array_like</code></dt>
<dd>Axis of rotation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rot_matrix(theta, u=np.asarray([0, 0, 1], dtype=np.float)):
    &#34;&#34;&#34;
    Generate a 3D rotational matrix.

    Parameters
    ----------
    theta : float
        Angle of rotation in radians
    u : (3,) array_like
        Axis of rotation
    &#34;&#34;&#34;
    from numpy import sin, cos

    c = cos(theta)
    s = sin(theta)
    ux, uy, uz = u / np.linalg.norm(u)
    R = np.zeros((3, 3))
    R[0, :] = [
        c + ux * ux * (1 - c),
        ux * uy * (1 - c) - uz * s,
        ux * uz * (1 - c) + uy * s,
    ]
    R[1, :] = [
        uy * uz * (1 - c) + uz * s,
        c + uy * uy * (1 - c),
        uy * uz * (1 - c) - ux * s,
    ]
    R[2, :] = [
        uz * ux * (1 - c) - uy * s,
        uz * uy * (1 - c) + ux * s,
        c + uz * uz * (1 - c),
    ]
    return R</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyms.structure_routines.layered_structure_propagators"><code class="flex name class">
<span>class <span class="ident">layered_structure_propagators</span></span>
<span>(</span><span>layered_T, subslices, propkwargs={})</span>
</code></dt>
<dd>
<div class="desc"><p>A class that mimics multislice propagators for a layered object.</p>
<p>Complements layered_transmission_function</p>
<p>Generate a layered structure multislice propagator function object.</p>
<p>This function assumes that the lateral (x and y) cell sizes of the
structures are identical,</p>
<h2 id="input">Input</h2>
<p>T : layered_structure_transmission_function object
This should contain all the neccessary information about the layered
object to generate the propagators</p>
<h2 id="keyword-arguements">Keyword arguements:</h2>
<p>propkwargs : dict
Keyword arguements to pass onto make_propagator function</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>self</code></strong> :&ensp;<code><a title="pyms.structure_routines.layered_structure_propagators" href="#pyms.structure_routines.layered_structure_propagators">layered_structure_propagators</a> object</code></dt>
<dd>This will behave like a normal propagator array, if
P = layered_structure_propagators(T)
then P[islice,&hellip;] will return a transmission function from whichever
structure islice happens to be in.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class layered_structure_propagators:
    &#34;&#34;&#34;
    A class that mimics multislice propagators for a layered object.

    Complements layered_transmission_function
    &#34;&#34;&#34;

    def __init__(self, layered_T, subslices, propkwargs={}):
        &#34;&#34;&#34;
        Generate a layered structure multislice propagator function object.

        This function assumes that the lateral (x and y) cell sizes of the
        structures are identical,

        Input
        -----
        T : layered_structure_transmission_function object
            This should contain all the neccessary information about the layered
            object to generate the propagators

        Keyword arguements:
        -------------------
        propkwargs : dict
            Keyword arguements to pass onto make_propagator function

        Returns
        -----
        self : layered_structure_propagators object
            This will behave like a normal propagator array, if
            P = layered_structure_propagators(T)
            then P[islice,...] will return a transmission function from whichever
            structure islice happens to be in.
        &#34;&#34;&#34;
        from .py_multislice import make_propagators

        self.rsizes = [
            copy.deepcopy(struc.unitcell * np.asarray(t + [1]))
            for struc, t in zip(layered_T.structures, layered_T.tilings)
        ]

        self.Ps = [
            cx_from_numpy(
                make_propagators(layered_T.gridshape, r, layered_T.eV, s, **propkwargs),
                layered_T.dtype,
                layered_T.device,
            )
            for s, r in zip(subslices, self.rsizes)
        ]
        self.slicemap = layered_T.slicemap
        self.subslicemap = layered_T.subslicemap
        # Mimics the shape property of a numpy array
        self.shape = (layered_T.nslicestot, *layered_T.gridshape, 2)
        self.ndim = 4

    def dim(self):
        &#34;&#34;&#34;Return the array dimension of the synthetic array.&#34;&#34;&#34;
        return 4

    def __getitem__(self, islice):
        &#34;&#34;&#34;
        __getitem__ method for the propagator synthetic array.

        This enables the propagator object to mimic a standard propagator numpy
        or torch.Tensor array
        &#34;&#34;&#34;
        if isinstance(islice, int) or np.issubdtype(
            np.asarray(islice).dtype, np.integer
        ):
            return self.Ps[self.slicemap[islice]][self.subslicemap[islice]]
        elif isinstance(islice, slice):
            islice_ = np.arange(*islice.indices(len(self.slicemap)))
            return torch.stack(
                [self.Ps[self.slicemap[j]][self.subslicemap[j]] for j in islice_]
            )
        else:
            raise TypeError(&#34;Invalid argument type.&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyms.structure_routines.layered_structure_propagators.dim"><code class="name flex">
<span>def <span class="ident">dim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the array dimension of the synthetic array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dim(self):
    &#34;&#34;&#34;Return the array dimension of the synthetic array.&#34;&#34;&#34;
    return 4</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyms.structure_routines.layered_structure_transmission_function"><code class="flex name class">
<span>class <span class="ident">layered_structure_transmission_function</span></span>
<span>(</span><span>gridshape, eV, structures, nslices, subslices, tilings=None, kwargs={}, nT=5, dtype=torch.float32, device=None, specimen_tilt=[0, 0])</span>
</code></dt>
<dd>
<div class="desc"><p>A class that mimics multislice transmission functions for a layered object.</p>
<p>Useful for performing multislice calculations of heterostructures (epitaxially
layered cystalline structures).</p>
<p>Generate a layered structure transmission function object.</p>
<p>This function assumes that the lateral (x and y) cell sizes of the
structures are identical,</p>
<h2 id="input">Input</h2>
<p>structures : (N,) array_like of pyms.Structure objects
The input structures for which the transmission functions for a
layered structure will be calculated.
nslices : int (N,) array_like
The number of units of each structure in the multilayer
subslices : array_like (N,) of array_like
Multislice subslicing for each object in the multilayer structure</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>self</code></strong> :&ensp;<code><a title="pyms.structure_routines.layered_structure_transmission_function" href="#pyms.structure_routines.layered_structure_transmission_function">layered_structure_transmission_function</a> object</code></dt>
<dd>This will behave like a normal transmission function array, if
T = layered_structure_transmission_function(&hellip;,[structure1,structure2 etc])
then T[0,islice,&hellip;] will return a transmission function from whichever
structure islice happens to be in. T.Propagator[islice] returns the
relevant multislice propagator</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class layered_structure_transmission_function:
    &#34;&#34;&#34;
    A class that mimics multislice transmission functions for a layered object.

    Useful for performing multislice calculations of heterostructures (epitaxially
    layered cystalline structures).
    &#34;&#34;&#34;

    def __init__(
        self,
        gridshape,
        eV,
        structures,
        nslices,
        subslices,
        tilings=None,
        kwargs={},
        nT=5,
        dtype=torch.float32,
        device=None,
        specimen_tilt=[0, 0],
    ):
        &#34;&#34;&#34;
        Generate a layered structure transmission function object.

        This function assumes that the lateral (x and y) cell sizes of the
        structures are identical,

        Input
        -----
        structures : (N,) array_like of pyms.Structure objects
            The input structures for which the transmission functions for a
            layered structure will be calculated.
        nslices : int (N,) array_like
            The number of units of each structure in the multilayer
        subslices : array_like (N,) of array_like
            Multislice subslicing for each object in the multilayer structure

        Returns
        -----
        self : layered_structure_transmission_function object
            This will behave like a normal transmission function array, if
            T = layered_structure_transmission_function(...,[structure1,structure2 etc])
            then T[0,islice,...] will return a transmission function from whichever
            structure islice happens to be in. T.Propagator[islice] returns the
            relevant multislice propagator
        &#34;&#34;&#34;
        self.dtype = dtype
        self.device = get_device(device)
        self.nslicestot = np.sum(nslices)
        self.structures = structures

        if tilings is None:
            tilings = len(structures) * [[1, 1]]

        self.Ts = []
        self.nT = nT
        self.gridshape = gridshape
        self.tilings = tilings
        self.eV = eV
        self.specimen_tilt = specimen_tilt
        self.unitcell = np.zeros(3)
        self.unitcell[:2] = structures[0].unitcell[:2]  # * np.asarray(tilings[0])
        self.unitcell[2] = np.sum(
            [struc.unitcell[2] * nslice for struc, nslice in zip(structures, nslices)]
        )
        args = [gridshape, eV]

        # Like every Melbourne restaurant, within the slab structure we do things
        # a little differently: since the number of subslices can be different
        # for each structure we have to store the transmission functions for
        #  each structure in a list so the indexing of self.Ts is
        # self.Ts[istructure][iT][isubslice], the __get_item__ method
        # makes indexing this synthetic object consistent with standard practice
        for structure, subslices_, tiling in zip(structures, subslices, tilings):
            self.Ts.append(
                torch.stack(
                    [
                        structure.make_transmission_functions(
                            *args,
                            subslices=subslices_,
                            tiling=tiling,
                            **kwargs,
                            device=self.device,
                            dtype=self.dtype,
                        )
                        for i in range(nT)
                    ]
                )
            )

        self.slicemap = list(
            itertools.chain(
                *[len(subslices[i]) * n * [i] for i, n in enumerate(nslices)]
            )
        )
        nsubslices = [len(subslice) for subslice in subslices]
        self.subslicemap = list(
            itertools.chain(
                *[
                    (np.arange(nsubslices[i] * n) % nsubslices[i]).tolist()
                    for i, n in enumerate(nslices)
                ]
            )
        )
        self.N = len(self.slicemap)
        self.subslices = []
        T = 0
        # Calculate the fractional depth of every subslice in the new synthetic
        # structure.
        for subslices_, slices, struct in zip(subslices, nslices, structures):
            for i in range(slices):
                self.subslices += (
                    (np.asarray(subslices_) * struct.unitcell[2] + T) / self.unitcell[2]
                ).tolist()
                T = T + struct.unitcell[2]

        # Mimics the shape property of a numpy array
        self.shape = (self.nT, self.N, *self.gridshape, 2)
        self.Propagator = layered_structure_propagators(
            self, subslices, propkwargs={&#34;tilt&#34;: specimen_tilt}
        )

    def dim(self):
        &#34;&#34;&#34;Return the array dimension of the synthetic array.&#34;&#34;&#34;
        return 4

    def __getitem__(self, ind):
        &#34;&#34;&#34;
        __getitem__ method for the transmission function synthetic array.

        This enables the transmission function object to mimic a standard
        transmission function numpy or torch.Tensor array
        &#34;&#34;&#34;
        it, islice = ind[:2]

        # First get the proper slice and subslice, self.Ts is a list object
        # with each entry containing the transmission functions for that
        # structure
        if isinstance(islice, int) or np.issubdtype(
            np.asarray(islice).dtype, np.integer
        ):
            T = self.Ts[self.slicemap[islice]][:, self.subslicemap[islice]]
        elif isinstance(islice, slice):
            islice_ = np.arange(*islice.indices(self.N))
            T = torch.stack(
                [self.Ts[self.slicemap[j]][:, self.subslicemap[j]] for j in islice_],
                axis=1,
            )
        else:
            raise TypeError(&#34;Invalid argument type.&#34;)

        if isinstance(it, int) or np.issubdtype(np.asarray(it).dtype, np.integer):
            return T[it]
        elif isinstance(it, slice):
            it_ = np.arange(*it.indices(self.nT))
            return T[it_]
        else:
            raise TypeError(&#34;Invalid argument type.&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyms.structure_routines.layered_structure_transmission_function.dim"><code class="name flex">
<span>def <span class="ident">dim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the array dimension of the synthetic array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dim(self):
    &#34;&#34;&#34;Return the array dimension of the synthetic array.&#34;&#34;&#34;
    return 4</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyms.structure_routines.structure"><code class="flex name class">
<span>class <span class="ident">structure</span></span>
<span>(</span><span>unitcell, atoms, dwf, occ=None, Title='', EPS=0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for simulation objects.</p>
<p>Elements in a structure object:
unitcell :
An array containing the side lengths of the orthorhombic unit cell
atoms :
An array of dimensions total number of atoms by 6 which for each atom
contains the fractional cooordinates within the unit cell for each atom
in the first three entries, the atomic number in the fourth entry,
the atomic occupancy (not yet implemented in the multislice) in the
fifth entry and mean squared atomic displacement in the sixth entry
Title :
Short description of the object of output purposes</p>
<p>Initialize a simulation object with necessary variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class structure:
    &#34;&#34;&#34;
    Class for simulation objects.

    Elements in a structure object:
    unitcell :
        An array containing the side lengths of the orthorhombic unit cell
    atoms :
        An array of dimensions total number of atoms by 6 which for each atom
        contains the fractional cooordinates within the unit cell for each atom
        in the first three entries, the atomic number in the fourth entry,
        the atomic occupancy (not yet implemented in the multislice) in the
        fifth entry and mean squared atomic displacement in the sixth entry
    Title :
        Short description of the object of output purposes
    &#34;&#34;&#34;

    def __init__(self, unitcell, atoms, dwf, occ=None, Title=&#34;&#34;, EPS=1e-2):
        &#34;&#34;&#34;Initialize a simulation object with necessary variables.&#34;&#34;&#34;
        self.unitcell = np.asarray(unitcell)
        natoms = np.asarray(atoms).shape[0]

        if occ is None:
            occ = np.ones(natoms)

        self.atoms = np.concatenate(
            [atoms, occ.reshape(natoms, 1), np.asarray(dwf).reshape(natoms, 1)], axis=1
        )
        self.Title = Title

        # Up till now unitcell can be a 3 x 3 matrix with rows describing the
        # unit cell edges. If this is the case we need to make sure that the
        # unit cell is orthorhombic and find an orthorhombic tiling if this it
        # is not orthorhombic
        if self.unitcell.ndim &gt; 1:
            # Check to see if unit cell is orthorhombic
            ortho = np.abs(np.sum(self.unitcell) - np.trace(self.unitcell)) &lt; EPS

            if ortho:
                # If unit cell is orthorhombic then extract unit cell
                # dimension
                self.unitcell = np.diag(self.unitcell)
            else:
                # If not orthorhombic attempt psuedo rational tiling
                self.orthorhombic_supercell(EPS=EPS)

        # Check if there is any fractional occupancy of atom sites in
        # the sample
        self.fractional_occupancy = np.any(np.abs(self.atoms[:, 4] - 1.0) &gt; 1e-3)

    @classmethod
    def fromfile(
        cls,
        fnam,
        temperature_factor_units=&#34;ums&#34;,
        atomic_coordinates=&#34;fractional&#34;,
        EPS=1e-2,
        T=None,
    ):
        &#34;&#34;&#34;
        Read in a simulation object from a structure file.

        Appropriate structure files include *.p1 files, which is outputted by
        the vesta software:

        K. Momma and F. Izumi, &#34;VESTA 3 for three-dimensional visualization of
        crystal, volumetric and morphology data,&#34; J. Appl. Crystallogr., 44,
        1272-1276 (2011).

        or a *.xyz file in the standard of the prismatic software

        Parameters
        ----------
        fnam : string
            Filepath of the structure file
        temperature_factor_units : string,optional
            Units of the Debye-Waller temperature factors in the structure file
            appropriate inputs are B (crystallographic temperature factor),
            urms (root mean squared displacement) and ums (mean squared
            displacement, the default)
        atomic_coordinates : string, optional
            Units of the atomic coordinates can be &#34;fractional&#34; or &#34;cartesian&#34;
        EPS : float,optional
            Tolerance for procedures such as psuedo-rational tiling for
            non-orthorhombic crystal unit cells
        T : (3,3) array_like or None
            An optional transformation matrix to be applied to the unit cell
            and the atomic coordinates
        &#34;&#34;&#34;
        f = open(fnam, &#34;r&#34;)

        ext = splitext(fnam)[1].lower()

        # Read title
        Title = f.readline().strip()

        if ext == &#34;.p1&#34;:

            # I have no idea what the second line in the p1 file format means
            # so ignore it
            f.readline()

            # Get unit cell vector - WARNING assume an orthorhombic unit cell
            unitcell = np.loadtxt(f, max_rows=3, dtype=np.float)

            # Get the atomic symbol of each element
            atomtypes = np.loadtxt(f, max_rows=1, dtype=str, ndmin=1)  # noqa

            # Get the number of atoms of each type
            natoms = np.loadtxt(f, max_rows=1, dtype=int, ndmin=1)

            # Skip empty line
            f.readline()

            # Total number of atoms
            totnatoms = np.sum(natoms)
            # Intialize array containing atomic information
            atoms = np.zeros((totnatoms, 6))
            dwf = np.zeros((totnatoms,))
            occ = np.zeros((totnatoms,))

            for i in range(totnatoms):
                atominfo = split(r&#34;\s+&#34;, f.readline().strip())[:6]
                # First three entries are the atomic coordinates
                atoms[i, :3] = np.asarray(atominfo[:3], dtype=np.float)
                # Fourth entry is the atomic symbol
                atoms[i, 3] = atomic_symbol.index(
                    match(&#34;([A-Za-z]+)&#34;, atominfo[3]).group(0)
                )
                # Final entries are the fractional occupancy and the temperature
                # (Debye-Waller) factor
                occ[i] = atominfo[4]
                dwf[i] = atominfo[5]

        elif ext == &#34;.xyz&#34;:
            # Read in unit cell dimensions
            unitcell = np.asarray(
                [float(x) for x in split(r&#34;\s+&#34;, f.readline().strip())[:3]]
            )

            atoms = []
            for line in f:

                # Look for end of file marker
                if line.strip() == &#34;-1&#34;:
                    break
                # Otherwise parse line
                atoms.append(
                    np.array([float(x) for x in split(r&#34;\s+&#34;, line.strip())[:6]])
                )

            # Now stack all atoms into numpy array
            atoms_ = np.stack(atoms, axis=0)

            # Rearrange columns of numpy array to match standard
            totnatoms = atoms_.shape[0]
            atoms = np.zeros((totnatoms, 4))
            # Atomic coordinates
            atoms[:, :3] = atoms_[:, 1:4]
            # Atomic numbers (Z)
            atoms[:, 3] = atoms_[:, 0]
            # Fractional occupancy and Debye-Waller (temperature) factor
            dwf = atoms_[:, 5]
            occ = atoms_[:, 4]
        else:
            print(&#34;File extension: {0} not recognized&#34;.format(ext))
            return None

        # Close file
        f.close()

        # If temperature factors are given in any other format than mean square
        # (ums) convert to mean square. Acceptable formats are crystallographic
        # temperature factor B and root mean square (urms) displacements
        if temperature_factor_units == &#34;B&#34;:
            dwf *= 1 / (8 * np.pi ** 2)
        elif temperature_factor_units == &#34;urms&#34;:
            dwf = dwf ** 2
        elif temperature_factor_units == &#34;ums&#34;:
            pass
        else:
            raise ValueError(&#34;Unrecognized temperature factor units&#34;)

        # If necessary, Convert atomic positions to fractional coordinates
        if atomic_coordinates == &#34;cartesian&#34;:
            atoms[:, :3] /= unitcell[:3][np.newaxis, :]
            atoms[:, :3] = atoms[:, :3] % 1.0

        if T is not None:
            # Transform atoms to cartesian basis and then apply transformation
            # matrix
            atoms[:, :3] = (T @ unitcell @ atoms[:, :3].T).T

            # Apply transformation matrix to unit-cell
            unitcell = unitcell @ T.T

            # Apply inverse of unit cell
            atoms[:, :3] = (np.linalg.inv(unitcell) @ atoms[:, :3].T).T

        return cls(unitcell, atoms[:, :4], dwf, occ, Title, EPS=EPS)

    @classmethod
    def from_ase_cluster(cls, asecell, occupancy=None, Title=&#34;&#34;, dwf=None):
        &#34;&#34;&#34;Initialize from Atomic Simulation Environment (ASE) cluster object.&#34;&#34;&#34;
        unitcell = asecell.cell[:]
        natoms = asecell.numbers.shape[0]
        atoms = np.concatenate(
            [
                asecell.cell.scaled_positions(asecell.positions),
                asecell.numbers.reshape(natoms, 1),
            ],
            axis=1,
        )
        if occupancy is None:
            occ = np.ones(natoms)
        if dwf is None:
            dwf = np.ones(natoms) * 3 / np.pi ** 2 / 8
        return cls(unitcell, atoms, dwf, occ, Title)

    def to_ase_atoms(self):
        &#34;&#34;&#34;Convert structure to Atomic Simulation Environment (ASE) atoms object.&#34;&#34;&#34;
        scaled_positions = self.atoms[:, :3]
        numbers = self.atoms[:, 3].astype(np.int)
        cell = self.unitcell
        pbc = [True, True, True]
        return ase.Atoms(
            scaled_positions=scaled_positions, numbers=numbers, cell=cell, pbc=pbc
        )

    def orthorhombic_supercell(self, EPS=1e-2):
        &#34;&#34;&#34;
        Create an orthorhombic supercell from a monoclinic crystal unit cell.

        If not orthorhombic attempt psuedo rational tiling of general
        monoclinic structure. Assumes that the self.unitcell matrix is lower
        triangular.
        &#34;&#34;&#34;
        if not np.abs(np.dot(self.unitcell[0], self.unitcell[1])) &lt; EPS:
            tiley, tilex = psuedo_rational_tiling(*self.unitcell[0:2, 0], EPS)

            # Make deepcopy of old unit cell

            olduc = copy.deepcopy(self.unitcell)

            # Tile out atoms
            self.tile(tiley, tilex, 1)

            # Calculate size of old unit cell under tiling
            olduc = np.asarray([tiley, tilex, 1])[:, np.newaxis] * olduc

            self.unitcell = copy.deepcopy(olduc)
            self.unitcell[1, 0] = 0.0

            # Now calculate fractional coordinates in new orthorhombic cell
            self.atoms[:, :3] = change_of_basis(self.atoms[:, :3], self.unitcell, olduc)
        else:
            self.unitcell[0, 1:] = 0.0
            self.unitcell[1, ::2] = 0.0

        # Now tile crystal in x and y
        tilez1, tiley = psuedo_rational_tiling(*self.unitcell[::-2, 0], EPS)
        tilez2, tilex = psuedo_rational_tiling(*self.unitcell[3:0:-1, 1], EPS)
        tilez = remove_common_factors([tilez1, tilez2, tilez1 * tilez2])[-1]
        tiley *= tilez // tilez1
        tilex *= tilez // tilez2

        olduc = copy.deepcopy(self.unitcell)

        # Tile out atoms
        self.tile(tiley, tilex, tilez)

        # Calculate size of old unit cell under tiling

        olduc = np.asarray([tiley, tilex, tilez])[:, np.newaxis] * olduc

        self.unitcell = copy.deepcopy(olduc)
        self.unitcell[2, 0:2] = 0.0

        # Now calculate fractional coordinates in new orthorhombic cell
        self.atoms[:, :3] = np.mod(
            self.atoms[:, :3] @ olduc @ np.linalg.inv(self.unitcell), 1.0
        )
        self.unitcell = np.diag(self.unitcell)

        # Check for negative values of self.unitcell and rectify
        for i in range(3):
            if self.unitcell[i] &lt; 0:
                self.atoms[:, i] = (1.0 - self.atoms[:, i]) % 1.0
        self.unitcell = np.abs(self.unitcell)

    def quickplot(
        self, atomscale=None, cmap=plt.get_cmap(&#34;Dark2&#34;), block=True, colors=None
    ):
        &#34;&#34;&#34;
        Make a quick 3D scatter plot of the atomic sites within the structure.

        For more detailed visualization output the structure file to a file format
        readable by the Vesta software using output_vesta_xtl
        &#34;&#34;&#34;
        from mpl_toolkits.mplot3d import Axes3D  # NOQA

        if atomscale is None:
            atomscale = 1e-3 * np.amax(self.unitcell)

        fig = plt.figure()
        ax = fig.add_subplot(111, projection=&#34;3d&#34;)

        if colors is None:
            colors = cmap(self.atoms[:, 3] / np.amax(self.atoms[:, 3]))
        sizes = self.atoms[:, 3] * atomscale

        ax.scatter(
            *[self.atoms[:, i] * self.unitcell[i] for i in [1, 0, 2]], c=colors, s=sizes
        )

        ax.set_xlim3d(0.0, self.unitcell[1])
        ax.set_ylim3d(top=0.0, bottom=self.unitcell[0])
        ax.set_zlim3d(top=0.0, bottom=self.unitcell[2])
        ax.set_xlabel(&#34;x&#34;)
        ax.set_ylabel(&#34;y&#34;)
        ax.set_zlabel(&#34;z&#34;)

        plt.show(block=block)
        return fig

    def output_vesta_xtl(self, fnam):
        &#34;&#34;&#34;Output an .xtl file which is viewable by the vesta software.

        See K. Momma and F. Izumi, &#34;VESTA 3 for three-dimensional visualization
        of crystal, volumetric and morphology data,&#34; J. Appl. Crystallogr., 44,
        1272-1276 (2011).

        Warning: Vesta xtl files do not contain fractional occupancy information
        &#34;&#34;&#34;
        f = open(splitext(fnam)[0] + &#34;.xtl&#34;, &#34;w&#34;)
        f.write(&#34;TITLE &#34; + self.Title + &#34;\n CELL \n&#34;)
        f.write(&#34;  {0:.5f} {1:.5f} {2:.5f} 90 90 90\n&#34;.format(*self.unitcell))
        f.write(&#34;SYMMETRY NUMBER 1\n SYMMETRY LABEL  P1\n ATOMS \n&#34;)
        f.write(&#34;NAME         X           Y           Z&#34; + &#34;\n&#34;)
        for i in range(self.atoms.shape[0]):
            f.write(
                &#34;{0} {1:.4f} {2:.4f} {3:.4f}\n&#34;.format(
                    atomic_symbol[int(self.atoms[i, 3])], *self.atoms[i, :3]
                )
            )
        f.write(&#34;EOF&#34;)
        f.close()

    def output_xyz(
        self, fnam, atomic_coordinates=&#34;cartesian&#34;, temperature_factor_units=&#34;sqrturms&#34;
    ):
        &#34;&#34;&#34;
        Output an .xyz structure file.

        This is the input format used by Kirkland&#39;s EM codes and the prismatic
        software.
        &#34;&#34;&#34;
        f = open(splitext(fnam)[0] + &#34;.xyz&#34;, &#34;w&#34;)
        f.write(self.Title + &#34;\n {0:.4f} {1:.4f} {2:.4f}\n&#34;.format(*self.unitcell))

        if atomic_coordinates == &#34;cartesian&#34;:
            coords = self.atoms[:, :3] * self.unitcell
        else:
            coords = self.atoms[:, :3]

        # If temperature factors are given as B then convert to urms
        if temperature_factor_units == &#34;B&#34;:
            DWFs = self.atoms[:, 5] * 8 * np.pi ** 2
        elif temperature_factor_units == &#34;sqrturms&#34;:
            DWFs = np.sqrt(self.atoms[:, 5])

        for coord, atom, DWF in zip(coords, self.atoms, DWFs):
            f.write(
                &#34;{0:d} {1:.4f} {2:.4f} {3:.4f} {4:.2f}  {5:.3f}\n&#34;.format(
                    int(atom[3]), *coord, atom[4], DWF
                )
            )
        f.write(&#34;-1&#34;)
        f.close()

    def make_potential(
        self,
        pixels,
        subslices=[1.0],
        tiling=[1, 1],
        displacements=True,
        fractional_occupancy=True,
        fe=None,
        device=None,
        dtype=torch.float32,
        seed=None,
    ):
        &#34;&#34;&#34;
        Generate the projected potential of the structure.

        Calculate the projected electrostatic potential for a structure on a
        pixel grid with dimensions specified by pixels. Subslicing the unit
        cell is achieved by passing an array subslices that contains as its
        entries the depths at which each subslice should be terminated in units
        of fractional coordinates. Tiling of the unit cell (often necessary to
        make a sufficiently large simulation grid to fit the probe) is achieved
        by passing the tiling factors in the array tiling.

        Parameters
        ----------
        pixels: int, (2,) array_like
            The pixel size of the grid on which to calculate the projected
            potentials
        subslices: float, array_like, optional
            An array containing the depths at which each slice ends as a fraction
            of the simulation unit-cell
        tiling: int, (2,) array_like, optional
            Tiling of the simulation object (often necessary to  make a
            sufficiently large simulation grid to fit the probe)
        displacements: bool, optional
            Pass displacements = False to turn off random displacements of the
            atoms due to thermal motion
        fractional_occupancy: bool, optional
            Pass fractional_occupancy = False to turn off fractional occupancy
            of atomic sites
        fe: float, array_like
            An array containing the electron scattering factors for the elements
            in the structure as calculated by the function
            calculate_scattering_factors, can be passed to save recalculating
            each time new potentials are generated
        device: torch.device
            Allows the user to control which device the calculations will occur
            on
        dtype: torch.dtype
            Controls the data-type of the output
        seed: int
            Seed for random number generator for atomic displacements.
        &#34;&#34;&#34;
        # Initialize device cuda if available, CPU if no cuda is available
        device = get_device(device)

        # Ensure pixels is integer
        pixels_ = [int(x) for x in pixels]

        # Seed random number generator for displacements
        if seed is not None:
            torch.manual_seed(seed)

        tiling_ = np.asarray(tiling[:2])
        gsize = np.asarray(self.unitcell[:2]) * tiling_
        psize = np.asarray(pixels_)

        pixperA = np.asarray(pixels_) / np.asarray(self.unitcell[:2]) / tiling_

        # Get a list of unique atomic elements
        elements = list(set(np.asarray(self.atoms[:, 3], dtype=np.int)))

        # Get number of unique atomic elements
        nelements = len(elements)
        nsubslices = len(subslices)
        # Build list of equivalent sites if Fractional occupancy is to be
        # taken into account
        if fractional_occupancy and self.fractional_occupancy:
            equivalent_sites = find_equivalent_sites(self.atoms[:, :3], EPS=1e-3)

        # FDES method
        # Intialize potential array
        P = torch.zeros(
            np.prod([nelements, nsubslices, *pixels_, 2]), device=device, dtype=dtype
        )

        # Construct a map of which atom corresponds to which slice
        islice = np.zeros((self.atoms.shape[0]), dtype=np.int)
        slice_stride = np.prod(pixels_) * 2
        # if nsubslices &gt; 1:
        # Finds which slice atom can be found in
        # WARNING Assumes that the slices list ends with 1.0 and is in
        # ascending order
        for i in range(nsubslices):
            zmin = 0 if i == 0 else subslices[i - 1]
            atoms_in_slice = (self.atoms[:, 2] % 1.0 &gt;= zmin) &amp; (
                self.atoms[:, 2] % 1.0 &lt; subslices[i]
            )
            islice[atoms_in_slice] = i * slice_stride
        islice = torch.from_numpy(islice).type(torch.long).to(device)
        # else:
        #     islice = 0
        # Make map a pytorch Tensor

        # Construct a map of which atom corresponds to which element
        element_stride = nsubslices * slice_stride
        ielement = torch.tensor(
            [
                element_stride * elements.index(int(self.atoms[iatom, 3]))
                for iatom in range(self.atoms.shape[0])
            ],
            dtype=torch.long,
            device=device,
        )

        if displacements:
            # Generate thermal displacements
            urms = torch.tensor(
                np.sqrt(self.atoms[:, 5])[:, np.newaxis] * pixperA[np.newaxis, :],
                dtype=P.dtype,
                device=device,
            ).view(self.atoms.shape[0], 2)

        # FDES algorithm implemented using the pytorch scatter_add function,
        # which takes a list of numbers and adds them to a corresponding list
        # of coordinates
        for tile in range(tiling[0] * tiling[1]):
            # For these atomic coordinates (in fractional coordinates) convert
            # to pixel coordinates
            posn = (
                (
                    self.atoms[:, :2]
                    + np.asarray([tile % tiling[0], tile // tiling[0]])[np.newaxis, :]
                )
                / tiling_
                * psize
            )
            posn = torch.from_numpy(posn).to(device).type(P.dtype)

            if displacements:

                # Add displacement sampled from normal distribution to account
                # for atomic thermal motion
                disp = (
                    torch.randn(self.atoms.shape[0], 2, dtype=P.dtype, device=device)
                    * urms
                )

                # If using fractional occupancy force atoms occupying equivalent
                # sites to have the same displacement
                if fractional_occupancy and self.fractional_occupancy:
                    disp = disp[equivalent_sites, :]

                posn[:, :2] += disp

            yc = (
                torch.remainder(torch.ceil(posn[:, 0]).type(torch.long), pixels_[0])
                * pixels_[1]
                * 2
            )
            yf = (
                torch.remainder(torch.floor(posn[:, 0]).type(torch.long), pixels_[0])
                * pixels_[1]
                * 2
            )
            xc = (
                torch.remainder(torch.ceil(posn[:, 1]).type(torch.long), pixels_[1]) * 2
            )
            xf = (
                torch.remainder(torch.floor(posn[:, 1]).type(torch.long), pixels_[1])
                * 2
            )

            yh = torch.remainder(posn[:, 0], 1.0)
            yl = 1.0 - yh
            xh = torch.remainder(posn[:, 1], 1.0)
            xl = 1.0 - xh

            # Account for fractional occupancy of atomic sites if requested
            if fractional_occupancy and self.fractional_occupancy:
                xh *= torch.from_numpy(self.atoms[:, 4]).type(P.dtype).to(device)
                xl *= torch.from_numpy(self.atoms[:, 4]).type(P.dtype).to(device)

            # Each pixel is set to the overlap of a shifted rectangle in that pixel
            P.scatter_add_(0, ielement + islice + yc + xc, yh * xh)
            P.scatter_add_(0, ielement + islice + yc + xf, yh * xl)
            P.scatter_add_(0, ielement + islice + yf + xc, yl * xh)
            P.scatter_add_(0, ielement + islice + yf + xf, yl * xl)

        # Now view potential as a 4D array for next bit
        P = P.view(nelements, nsubslices, *pixels_, 2)

        # FFT potential to reciprocal space
        for i in range(P.shape[0]):
            for j in range(P.shape[1]):
                P[i, j] = torch.fft(P[i, j], signal_ndim=2)

        # Make sinc functions with appropriate singleton dimensions for pytorch
        # broadcasting /gridsize[0]*pixels_[0] /gridsize[1]*pixels_[1]
        sincy = (
            sinc(torch.from_numpy(np.fft.fftfreq(pixels_[0])))
            .view([1, 1, pixels_[0], 1, 1])
            .to(device)
            .type(P.dtype)
        )
        sincx = (
            sinc(torch.from_numpy(np.fft.fftfreq(pixels_[1])))
            .view([1, 1, 1, pixels_[1], 1])
            .to(device)
            .type(P.dtype)
        )
        # #Divide by sinc functions
        P /= sincy
        P /= sincx

        # Option to precalculate scattering factors and pass to program which
        # saves computation for
        if fe is None:
            fe_ = calculate_scattering_factors(psize, gsize, elements)
        else:
            fe_ = fe

        # Convolve with electron scattering factors using Fourier convolution theorem
        P *= torch.from_numpy(fe_).view(nelements, 1, *pixels_, 1).to(device)

        norm = np.prod(pixels_) / np.prod(self.unitcell[:2]) / np.prod(tiling)
        # Add atoms together
        P = norm * torch.sum(P, dim=0)

        # Only return real part
        return torch.ifft(P, signal_ndim=2)[..., 0]

    def make_transmission_functions(
        self,
        pixels,
        eV,
        subslices=[1.0],
        tiling=[1, 1],
        fe=None,
        displacements=True,
        fftout=True,
        dtype=None,
        device=None,
        fractional_occupancy=True,
        seed=None,
        bandwidth_limit=2 / 3,
    ):
        &#34;&#34;&#34;
        Make the transmission functions for the simulation object.

        Transmission functions are the exponential of the specimen electrostatic
        potential scaled by the interaction constant for electrons, sigma. These
        are used to model scattering by a thin slice of the object in the
        multislice algorithm

        Parameters:
        -----------
        pixels : array_like
            Output pixel grid
        eV : float
            Probe accelerating voltage in electron-volts
        subslices : array_like, optional
            An array containing the depths at which each slice ends as a fraction
            of the simulation unit-cell, used for simulation objects thicker
            than typical multislice slicing (about 2 Angstrom)
        tiling : array_like,optional
            Repeat tiling of the simulation object
        fe: array_like,optional
            An array containing the electron scattering factors for the elements
            in the simulation object as calculated by the function
            calculate_scattering_factors
        &#34;&#34;&#34;
        # Make the specimen electrostatic potential
        T = self.make_potential(
            pixels,
            subslices,
            tiling,
            fe=fe,
            displacements=displacements,
            device=device,
            dtype=dtype,
            fractional_occupancy=fractional_occupancy,
            seed=seed,
        )

        # Now take the complex exponential of the electrostatic potential
        # scaled by the electron interaction constant
        T = torch.fft(torch_c_exp(interaction_constant(eV) * T), signal_ndim=2)

        # Band-width limit the transmission function, see Earl Kirkland&#39;s book
        # for an discussion of why this is necessary
        for i in range(T.shape[0]):
            T[i] = bandwidth_limit_array(T[i], bandwidth_limit)

        if fftout:
            return torch.ifft(T, signal_ndim=2)
        return T

    def generate_slicing_figure(self, slices, show=True):
        &#34;&#34;&#34;
        Generate slicing figure.

        Generate a slicing figure that to aid in setting up the slicing
        of the sample for multislice algorithm. This will show where each of the
        slices end for a chosen slicing relative to the atoms. To minimize
        errors, the atoms should sit as close to the top of the slice as possible.

        Parameters
        ----------
        slices: array_like, float
            An array containing the depths at which each slice ends as a fraction
            of the simulation unit-cell
        &#34;&#34;&#34;
        fig, ax = plt.subplots(ncols=2, figsize=(8, 4))

        coords = self.atoms[:, :3] * self.unitcell[None, :]
        # Projection down the x-axis
        for i in range(2):
            ax[i].plot(coords[:, i], coords[:, 2], &#34;bo&#34;, label=&#34;Atoms&#34;)
            for j, slice_ in enumerate(slices):
                if j == 0:
                    label = &#34;Slices&#34;
                else:
                    label = &#34;_&#34;
                ax[i].plot(
                    [0, self.unitcell[i]],
                    [slice_ * self.unitcell[2], slice_ * self.unitcell[2]],
                    &#34;r--&#34;,
                    label=label,
                )
            ax[i].set_xlim([0, self.unitcell[i]])
            ax[i].set_xlabel([&#34;y&#34;, &#34;x&#34;][i])
            ax[i].set_ylim([self.unitcell[2], 0])
            ax[i].set_ylabel(&#34;z&#34;)
            ax[i].set_title(&#34;View down {0} axis&#34;.format([&#34;x&#34;, &#34;y&#34;][i]))
        ax[0].legend()
        if show:
            plt.show(block=True)
        return fig

    def rotate(self, theta, axis, origin=[0.5, 0.5, 0.5]):
        &#34;&#34;&#34;
        Rotate simulation object an amount an angle theta (in radians) about axis.

        Parameters
        ----------
        theta: float
            Angle to rotate simulation object by in radians
        axis: array_like
            Axis about which to rotate simulation object eg [0,0,1]

        Keyword arguments
        ------------------
        origin : array_like, optional
            Origin (in fractional coordinates) about which to rotate simulation
            object eg [0.5, 0.5, 0.5]
        &#34;&#34;&#34;
        new = copy.deepcopy(self)

        # Make rotation matrix, R, and  the point about which we rotate, O
        R = rot_matrix(theta, axis)
        origin_ = np.asarray(origin) * self.unitcell

        # Get atomic coordinates in cartesian (not fractional coordinates)
        new.atoms[:, :3] = self.atoms[:, :3] * self.unitcell[np.newaxis, :]

        # Apply rotation matrix to each atom coordinate
        new.atoms[:, :3] = (new.atoms[:, :3] - origin_) @ R + origin_

        # Apply rotation matrix to cell vertices
        vertices = (
            np.asarray([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]])
            * self.unitcell
            - origin_
        ) @ R + origin_

        # Get new unit cell from maximum range of unit cell vertices
        origin_ = np.amin(vertices, axis=0)
        new.unitcell = np.ptp(vertices, axis=0)

        # Convert atoms back into fractional coordinates in new unit cell
        new.atoms[:, :3] = ((new.atoms[:, :3] - origin_) / new.unitcell) % 1.0

        # Return rotated structure
        return new

    def rot90(self, k=1, axes=(0, 1)):
        &#34;&#34;&#34;
        Rotates a structure by 90 degrees in the plane specified by axes.

        Rotation direction is from the first towards the second axis.

        Parameters
        ----------
        k : integer, optional
            Number of times the structure is rotated by 90 degrees.
        axes: (2,) array_like
            The array is rotated in the plane defined by the axes.
            Axes must be different.
        &#34;&#34;&#34;
        # Much of the following is adapted from the numpy.rot90 function
        axes = tuple(axes)
        if len(axes) != 2:
            raise ValueError(&#34;len(axes) must be 2.&#34;)

        k %= 4

        if k == 0:
            # Do nothing
            return
        if k == 2:
            # Reflect in both axes
            self.reflect(axes)
            return

        axes_list = np.arange(0, 3)
        (axes_list[axes[0]], axes_list[axes[1]]) = (
            axes_list[axes[1]],
            axes_list[axes[0]],
        )

        if k == 1:
            self.reflect([axes[1]])
            self.transpose(axes_list)
        else:
            # k == 3
            self.transpose(axes_list)
            self.reflect([axes[1]])

        return self

    def transpose(self, axes):
        &#34;&#34;&#34;Transpose the axes of a simulation object.&#34;&#34;&#34;
        self.atoms[:, :3] = self.atoms[:, axes]
        self.unitcell = self.unitcell[axes]
        return self

    def tile(self, x=1, y=1, z=1):
        &#34;&#34;&#34;Make a repeat unit tiling of the simulation object.&#34;&#34;&#34;
        # Make copy of original structure
        # new = copy.deepcopy(self)

        tiling = np.asarray([x, y, z], dtype=np.int)

        # Get atoms in unit cell
        natoms = self.atoms.shape[0]

        # Initialize new atom list
        newatoms = np.zeros((natoms * x * y * z, 6))

        # Calculate new unit cell size
        self.unitcell = self.unitcell * np.asarray([x, y, z])

        # tile out the integer amounts
        from itertools import product

        for j, k, l in product(*[np.arange(int(i)) for i in [x, y, z]]):

            # Calculate origin of this particular tile
            origin = np.asarray([j, k, l])

            # Calculate index of this particular tile
            indx = j * int(y) * int(z) + k * int(z) + l

            # Add new atoms to unit cell
            newatoms[indx * natoms : (indx + 1) * natoms, :3] = (
                self.atoms[:, :3] + origin[np.newaxis, :]
            ) / tiling[np.newaxis, :]

            # Copy other information about atoms
            newatoms[indx * natoms : (indx + 1) * natoms, 3:] = self.atoms[:, 3:]
        self.atoms = newatoms
        return self

    def concatenate(self, other, axis=2, side=1, eps=1e-2):
        &#34;&#34;&#34;
        Concatenate two simulation objects.

        Adds other simulation object to the current object. other is added to
        the bottom (top being z =0) routine will attempt to tile objects to
        match dimensions.

        Parameters:
        other : structure class
            Object that will be concatenated onto the other object.
        axis : int, optional
            Axis along which the two structures will be joined.
        side : int, optional
            Determines which side the other structure will be added onto the
            first structure. If side == 0 the structures will be added onto each
            other at the origin, if side == 1 the structures will be added onto
            each other at the end.
        eps : float, optional
            Fractional tolerance of the psuedo rational tiling to make the
            structure dimensions perpendicular to the beam direction match.
        &#34;&#34;&#34;
        # Make deep copies of the structure object and the slice this is so
        # that these objects remain untouched by the operation of this function
        new = copy.deepcopy(self)
        other_ = copy.deepcopy(other)

        tile1, tile2 = [np.ones(3, dtype=np.int) for i in range(2)]

        # Check if the two slices are the same size and
        # tile accordingly
        for ax in range(3):
            # If this axis is the concatenation axis, then it&#39;s not necessary
            # that the structures are the same size
            if ax == axis:
                continue
            # Calculate the psuedo-rational tiling
            if self.unitcell[ax] &lt; other.unitcell[ax]:
                tile1[ax], tile2[ax] = psuedo_rational_tiling(
                    self.unitcell[ax], other.unitcell[ax], eps
                )
            else:
                tile2[ax], tile1[ax] = psuedo_rational_tiling(
                    other.unitcell[ax], self.unitcell[ax], eps
                )

            tile1[ax], tile2[ax] = psuedo_rational_tiling(
                self.unitcell[ax], other.unitcell[ax], eps
            )

        new = new.tile(*tile1)
        tiled_zdim = new.unitcell[axis]
        other_ = other_.tile(*tile2)

        # Update the thickness of the resulting structure object.
        new.unitcell[axis] = tiled_zdim + other_.unitcell[axis]

        # Adjust fractional coordinates of atoms, multiply by old unitcell
        # size to transform into cartesian coordinates and then divide by
        # the old unitcell size to transform into fractional coordinates
        # in the new basis
        new.atoms[:, axis] *= tiled_zdim / new.unitcell[axis]
        other_.atoms[:, axis] *= other_.unitcell[axis] / new.unitcell[axis]

        # Adjust the coordinates of the new or old atoms depending on which
        # side the new structure is to be added.
        if side == 0:
            new.atoms[:, axis] += other_.unitcell[axis] / new.unitcell[axis]
        else:
            other_.atoms[:, axis] += self.unitcell[axis] / new.unitcell[axis]

        # Concatenate adjusted atomic coordinates
        new.atoms = np.concatenate([new.atoms, other_.atoms], axis=0)

        # Concatenate titles
        new.Title = self.Title + &#34; and &#34; + other.Title

        return new

    def reflect(self, axes):
        &#34;&#34;&#34;Reflect structure in each of the axes enumerated in list axes.&#34;&#34;&#34;
        for ax in axes:
            self.atoms[:, ax] = (1 - self.atoms[:, ax]) % 1.0
        return self

    def resize(self, fraction, axis):
        &#34;&#34;&#34;
        Resize (either crop or pad with vacuum) the simulation object.

        Resize the simulation object ranging such that the new axis runs from
        fraction[iax,0] to fraction[iax,1] on specified axis iax, slice_frac is
        in units of fractional coordinates. If fraction[iax,0] is &lt; 0 then
        additional vacuum will be added, if &gt; 0 then parts of the sample will
        be removed for axis[iax]. Likewise if fraction[iax,1] is &gt; 1 then
        additional vacuum will be added, if &lt; 1 then parts of the sample will
        be removed for axis[iax].

        Parameters
        ----------
        fraction : (nax,2) array_like
            Describes the size of the new simulation object as a fraction of
            old simulation object dimensions.
        axis : int or (nax,) array_like
            The axes of the simulation object that wil lbe resized

        Returns
        -------
        New structure : pyms.structure object
            The resized structure object
        &#34;&#34;&#34;
        ax = ensure_array(axis)
        frac = ensure_array(fraction)
        if np.asarray(frac).ndim &lt; 2:
            frac = [frac]

        # Work out which atoms will stay in the sliced structure
        mask = np.ones((self.atoms.shape[0],), dtype=np.bool)
        for a, f in zip(ax, frac):
            atomsin = np.logical_and(self.atoms[:, a] &gt;= f[0], self.atoms[:, a] &lt;= f[1])
            mask = np.logical_and(atomsin, mask)

        # Make a copy of the structure
        new = copy.deepcopy(self)

        # Put remaining atoms back in
        new.atoms = self.atoms[mask, :]

        # Origin for atomic coordinates
        origin = np.zeros((3))

        for a, f in zip(ax, frac):
            # Adjust unit cell dimensions
            new.unitcell[a] = (f[1] - f[0]) * self.unitcell[a]

            # Adjust origin of atomic coordinates
            origin[a] = f[0]

        new.atoms[:, :3] = (new.atoms[:, :3] - origin) * self.unitcell / new.unitcell

        # Return modified structure
        return new

    def cshift(self, shift, axis):
        &#34;&#34;&#34;
        Circular shift routine.

        Shift the atoms within the simulation cell an amount shift in fractional
        coordinates along specified axis (or axes if both shift and axis are
        array_like).

        Parameters
        ----------
        shift : array_like or int
            Amount in fractional coordinates to shift (each) axis.
        axis : array_like or int
            Axis or list of axes to apply shift(s) to.
        &#34;&#34;&#34;

        def _cshift(atoms, x, ax):
            atoms[:, ax % 3] = np.mod(atoms[:, ax % 3] + x, 1.0)
            return atoms

        if hasattr(axis, &#34;__len__&#34;):
            for x, ax in zip(shift, axis):
                self.atoms = _cshift(self.atoms, x, ax)
        else:
            self.atoms = _cshift(self.atoms, shift, axis)

        return self</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyms.structure_routines.structure.from_ase_cluster"><code class="name flex">
<span>def <span class="ident">from_ase_cluster</span></span>(<span>asecell, occupancy=None, Title='', dwf=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize from Atomic Simulation Environment (ASE) cluster object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_ase_cluster(cls, asecell, occupancy=None, Title=&#34;&#34;, dwf=None):
    &#34;&#34;&#34;Initialize from Atomic Simulation Environment (ASE) cluster object.&#34;&#34;&#34;
    unitcell = asecell.cell[:]
    natoms = asecell.numbers.shape[0]
    atoms = np.concatenate(
        [
            asecell.cell.scaled_positions(asecell.positions),
            asecell.numbers.reshape(natoms, 1),
        ],
        axis=1,
    )
    if occupancy is None:
        occ = np.ones(natoms)
    if dwf is None:
        dwf = np.ones(natoms) * 3 / np.pi ** 2 / 8
    return cls(unitcell, atoms, dwf, occ, Title)</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.fromfile"><code class="name flex">
<span>def <span class="ident">fromfile</span></span>(<span>fnam, temperature_factor_units='ums', atomic_coordinates='fractional', EPS=0.01, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Read in a simulation object from a structure file.</p>
<p>Appropriate structure files include *.p1 files, which is outputted by
the vesta software:</p>
<p>K. Momma and F. Izumi, "VESTA 3 for three-dimensional visualization of
crystal, volumetric and morphology data," J. Appl. Crystallogr., 44,
1272-1276 (2011).</p>
<p>or a *.xyz file in the standard of the prismatic software</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fnam</code></strong> :&ensp;<code>string</code></dt>
<dd>Filepath of the structure file</dd>
<dt><strong><code>temperature_factor_units</code></strong> :&ensp;<code>string</code>,optional</dt>
<dd>Units of the Debye-Waller temperature factors in the structure file
appropriate inputs are B (crystallographic temperature factor),
urms (root mean squared displacement) and ums (mean squared
displacement, the default)</dd>
<dt><strong><code>atomic_coordinates</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Units of the atomic coordinates can be "fractional" or "cartesian"</dd>
<dt><strong><code>EPS</code></strong> :&ensp;<code>float</code>,optional</dt>
<dd>Tolerance for procedures such as psuedo-rational tiling for
non-orthorhombic crystal unit cells</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>(3,3) array_like</code> or <code>None</code></dt>
<dd>An optional transformation matrix to be applied to the unit cell
and the atomic coordinates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromfile(
    cls,
    fnam,
    temperature_factor_units=&#34;ums&#34;,
    atomic_coordinates=&#34;fractional&#34;,
    EPS=1e-2,
    T=None,
):
    &#34;&#34;&#34;
    Read in a simulation object from a structure file.

    Appropriate structure files include *.p1 files, which is outputted by
    the vesta software:

    K. Momma and F. Izumi, &#34;VESTA 3 for three-dimensional visualization of
    crystal, volumetric and morphology data,&#34; J. Appl. Crystallogr., 44,
    1272-1276 (2011).

    or a *.xyz file in the standard of the prismatic software

    Parameters
    ----------
    fnam : string
        Filepath of the structure file
    temperature_factor_units : string,optional
        Units of the Debye-Waller temperature factors in the structure file
        appropriate inputs are B (crystallographic temperature factor),
        urms (root mean squared displacement) and ums (mean squared
        displacement, the default)
    atomic_coordinates : string, optional
        Units of the atomic coordinates can be &#34;fractional&#34; or &#34;cartesian&#34;
    EPS : float,optional
        Tolerance for procedures such as psuedo-rational tiling for
        non-orthorhombic crystal unit cells
    T : (3,3) array_like or None
        An optional transformation matrix to be applied to the unit cell
        and the atomic coordinates
    &#34;&#34;&#34;
    f = open(fnam, &#34;r&#34;)

    ext = splitext(fnam)[1].lower()

    # Read title
    Title = f.readline().strip()

    if ext == &#34;.p1&#34;:

        # I have no idea what the second line in the p1 file format means
        # so ignore it
        f.readline()

        # Get unit cell vector - WARNING assume an orthorhombic unit cell
        unitcell = np.loadtxt(f, max_rows=3, dtype=np.float)

        # Get the atomic symbol of each element
        atomtypes = np.loadtxt(f, max_rows=1, dtype=str, ndmin=1)  # noqa

        # Get the number of atoms of each type
        natoms = np.loadtxt(f, max_rows=1, dtype=int, ndmin=1)

        # Skip empty line
        f.readline()

        # Total number of atoms
        totnatoms = np.sum(natoms)
        # Intialize array containing atomic information
        atoms = np.zeros((totnatoms, 6))
        dwf = np.zeros((totnatoms,))
        occ = np.zeros((totnatoms,))

        for i in range(totnatoms):
            atominfo = split(r&#34;\s+&#34;, f.readline().strip())[:6]
            # First three entries are the atomic coordinates
            atoms[i, :3] = np.asarray(atominfo[:3], dtype=np.float)
            # Fourth entry is the atomic symbol
            atoms[i, 3] = atomic_symbol.index(
                match(&#34;([A-Za-z]+)&#34;, atominfo[3]).group(0)
            )
            # Final entries are the fractional occupancy and the temperature
            # (Debye-Waller) factor
            occ[i] = atominfo[4]
            dwf[i] = atominfo[5]

    elif ext == &#34;.xyz&#34;:
        # Read in unit cell dimensions
        unitcell = np.asarray(
            [float(x) for x in split(r&#34;\s+&#34;, f.readline().strip())[:3]]
        )

        atoms = []
        for line in f:

            # Look for end of file marker
            if line.strip() == &#34;-1&#34;:
                break
            # Otherwise parse line
            atoms.append(
                np.array([float(x) for x in split(r&#34;\s+&#34;, line.strip())[:6]])
            )

        # Now stack all atoms into numpy array
        atoms_ = np.stack(atoms, axis=0)

        # Rearrange columns of numpy array to match standard
        totnatoms = atoms_.shape[0]
        atoms = np.zeros((totnatoms, 4))
        # Atomic coordinates
        atoms[:, :3] = atoms_[:, 1:4]
        # Atomic numbers (Z)
        atoms[:, 3] = atoms_[:, 0]
        # Fractional occupancy and Debye-Waller (temperature) factor
        dwf = atoms_[:, 5]
        occ = atoms_[:, 4]
    else:
        print(&#34;File extension: {0} not recognized&#34;.format(ext))
        return None

    # Close file
    f.close()

    # If temperature factors are given in any other format than mean square
    # (ums) convert to mean square. Acceptable formats are crystallographic
    # temperature factor B and root mean square (urms) displacements
    if temperature_factor_units == &#34;B&#34;:
        dwf *= 1 / (8 * np.pi ** 2)
    elif temperature_factor_units == &#34;urms&#34;:
        dwf = dwf ** 2
    elif temperature_factor_units == &#34;ums&#34;:
        pass
    else:
        raise ValueError(&#34;Unrecognized temperature factor units&#34;)

    # If necessary, Convert atomic positions to fractional coordinates
    if atomic_coordinates == &#34;cartesian&#34;:
        atoms[:, :3] /= unitcell[:3][np.newaxis, :]
        atoms[:, :3] = atoms[:, :3] % 1.0

    if T is not None:
        # Transform atoms to cartesian basis and then apply transformation
        # matrix
        atoms[:, :3] = (T @ unitcell @ atoms[:, :3].T).T

        # Apply transformation matrix to unit-cell
        unitcell = unitcell @ T.T

        # Apply inverse of unit cell
        atoms[:, :3] = (np.linalg.inv(unitcell) @ atoms[:, :3].T).T

    return cls(unitcell, atoms[:, :4], dwf, occ, Title, EPS=EPS)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyms.structure_routines.structure.concatenate"><code class="name flex">
<span>def <span class="ident">concatenate</span></span>(<span>self, other, axis=2, side=1, eps=0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenate two simulation objects.</p>
<p>Adds other simulation object to the current object. other is added to
the bottom (top being z =0) routine will attempt to tile objects to
match dimensions.</p>
<p>Parameters:
other : structure class
Object that will be concatenated onto the other object.
axis : int, optional
Axis along which the two structures will be joined.
side : int, optional
Determines which side the other structure will be added onto the
first structure. If side == 0 the structures will be added onto each
other at the origin, if side == 1 the structures will be added onto
each other at the end.
eps : float, optional
Fractional tolerance of the psuedo rational tiling to make the
structure dimensions perpendicular to the beam direction match.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concatenate(self, other, axis=2, side=1, eps=1e-2):
    &#34;&#34;&#34;
    Concatenate two simulation objects.

    Adds other simulation object to the current object. other is added to
    the bottom (top being z =0) routine will attempt to tile objects to
    match dimensions.

    Parameters:
    other : structure class
        Object that will be concatenated onto the other object.
    axis : int, optional
        Axis along which the two structures will be joined.
    side : int, optional
        Determines which side the other structure will be added onto the
        first structure. If side == 0 the structures will be added onto each
        other at the origin, if side == 1 the structures will be added onto
        each other at the end.
    eps : float, optional
        Fractional tolerance of the psuedo rational tiling to make the
        structure dimensions perpendicular to the beam direction match.
    &#34;&#34;&#34;
    # Make deep copies of the structure object and the slice this is so
    # that these objects remain untouched by the operation of this function
    new = copy.deepcopy(self)
    other_ = copy.deepcopy(other)

    tile1, tile2 = [np.ones(3, dtype=np.int) for i in range(2)]

    # Check if the two slices are the same size and
    # tile accordingly
    for ax in range(3):
        # If this axis is the concatenation axis, then it&#39;s not necessary
        # that the structures are the same size
        if ax == axis:
            continue
        # Calculate the psuedo-rational tiling
        if self.unitcell[ax] &lt; other.unitcell[ax]:
            tile1[ax], tile2[ax] = psuedo_rational_tiling(
                self.unitcell[ax], other.unitcell[ax], eps
            )
        else:
            tile2[ax], tile1[ax] = psuedo_rational_tiling(
                other.unitcell[ax], self.unitcell[ax], eps
            )

        tile1[ax], tile2[ax] = psuedo_rational_tiling(
            self.unitcell[ax], other.unitcell[ax], eps
        )

    new = new.tile(*tile1)
    tiled_zdim = new.unitcell[axis]
    other_ = other_.tile(*tile2)

    # Update the thickness of the resulting structure object.
    new.unitcell[axis] = tiled_zdim + other_.unitcell[axis]

    # Adjust fractional coordinates of atoms, multiply by old unitcell
    # size to transform into cartesian coordinates and then divide by
    # the old unitcell size to transform into fractional coordinates
    # in the new basis
    new.atoms[:, axis] *= tiled_zdim / new.unitcell[axis]
    other_.atoms[:, axis] *= other_.unitcell[axis] / new.unitcell[axis]

    # Adjust the coordinates of the new or old atoms depending on which
    # side the new structure is to be added.
    if side == 0:
        new.atoms[:, axis] += other_.unitcell[axis] / new.unitcell[axis]
    else:
        other_.atoms[:, axis] += self.unitcell[axis] / new.unitcell[axis]

    # Concatenate adjusted atomic coordinates
    new.atoms = np.concatenate([new.atoms, other_.atoms], axis=0)

    # Concatenate titles
    new.Title = self.Title + &#34; and &#34; + other.Title

    return new</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.cshift"><code class="name flex">
<span>def <span class="ident">cshift</span></span>(<span>self, shift, axis)</span>
</code></dt>
<dd>
<div class="desc"><p>Circular shift routine.</p>
<p>Shift the atoms within the simulation cell an amount shift in fractional
coordinates along specified axis (or axes if both shift and axis are
array_like).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shift</code></strong> :&ensp;<code>array_like</code> or <code>int</code></dt>
<dd>Amount in fractional coordinates to shift (each) axis.</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>array_like</code> or <code>int</code></dt>
<dd>Axis or list of axes to apply shift(s) to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cshift(self, shift, axis):
    &#34;&#34;&#34;
    Circular shift routine.

    Shift the atoms within the simulation cell an amount shift in fractional
    coordinates along specified axis (or axes if both shift and axis are
    array_like).

    Parameters
    ----------
    shift : array_like or int
        Amount in fractional coordinates to shift (each) axis.
    axis : array_like or int
        Axis or list of axes to apply shift(s) to.
    &#34;&#34;&#34;

    def _cshift(atoms, x, ax):
        atoms[:, ax % 3] = np.mod(atoms[:, ax % 3] + x, 1.0)
        return atoms

    if hasattr(axis, &#34;__len__&#34;):
        for x, ax in zip(shift, axis):
            self.atoms = _cshift(self.atoms, x, ax)
    else:
        self.atoms = _cshift(self.atoms, shift, axis)

    return self</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.generate_slicing_figure"><code class="name flex">
<span>def <span class="ident">generate_slicing_figure</span></span>(<span>self, slices, show=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate slicing figure.</p>
<p>Generate a slicing figure that to aid in setting up the slicing
of the sample for multislice algorithm. This will show where each of the
slices end for a chosen slicing relative to the atoms. To minimize
errors, the atoms should sit as close to the top of the slice as possible.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>slices</code></strong> :&ensp;<code>array_like, float</code></dt>
<dd>An array containing the depths at which each slice ends as a fraction
of the simulation unit-cell</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_slicing_figure(self, slices, show=True):
    &#34;&#34;&#34;
    Generate slicing figure.

    Generate a slicing figure that to aid in setting up the slicing
    of the sample for multislice algorithm. This will show where each of the
    slices end for a chosen slicing relative to the atoms. To minimize
    errors, the atoms should sit as close to the top of the slice as possible.

    Parameters
    ----------
    slices: array_like, float
        An array containing the depths at which each slice ends as a fraction
        of the simulation unit-cell
    &#34;&#34;&#34;
    fig, ax = plt.subplots(ncols=2, figsize=(8, 4))

    coords = self.atoms[:, :3] * self.unitcell[None, :]
    # Projection down the x-axis
    for i in range(2):
        ax[i].plot(coords[:, i], coords[:, 2], &#34;bo&#34;, label=&#34;Atoms&#34;)
        for j, slice_ in enumerate(slices):
            if j == 0:
                label = &#34;Slices&#34;
            else:
                label = &#34;_&#34;
            ax[i].plot(
                [0, self.unitcell[i]],
                [slice_ * self.unitcell[2], slice_ * self.unitcell[2]],
                &#34;r--&#34;,
                label=label,
            )
        ax[i].set_xlim([0, self.unitcell[i]])
        ax[i].set_xlabel([&#34;y&#34;, &#34;x&#34;][i])
        ax[i].set_ylim([self.unitcell[2], 0])
        ax[i].set_ylabel(&#34;z&#34;)
        ax[i].set_title(&#34;View down {0} axis&#34;.format([&#34;x&#34;, &#34;y&#34;][i]))
    ax[0].legend()
    if show:
        plt.show(block=True)
    return fig</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.make_potential"><code class="name flex">
<span>def <span class="ident">make_potential</span></span>(<span>self, pixels, subslices=[1.0], tiling=[1, 1], displacements=True, fractional_occupancy=True, fe=None, device=None, dtype=torch.float32, seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the projected potential of the structure.</p>
<p>Calculate the projected electrostatic potential for a structure on a
pixel grid with dimensions specified by pixels. Subslicing the unit
cell is achieved by passing an array subslices that contains as its
entries the depths at which each subslice should be terminated in units
of fractional coordinates. Tiling of the unit cell (often necessary to
make a sufficiently large simulation grid to fit the probe) is achieved
by passing the tiling factors in the array tiling.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pixels</code></strong> :&ensp;<code>int, (2,) array_like</code></dt>
<dd>The pixel size of the grid on which to calculate the projected
potentials</dd>
<dt><strong><code>subslices</code></strong> :&ensp;<code>float, array_like</code>, optional</dt>
<dd>An array containing the depths at which each slice ends as a fraction
of the simulation unit-cell</dd>
<dt><strong><code>tiling</code></strong> :&ensp;<code>int, (2,) array_like</code>, optional</dt>
<dd>Tiling of the simulation object (often necessary to
make a
sufficiently large simulation grid to fit the probe)</dd>
<dt><strong><code>displacements</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Pass displacements = False to turn off random displacements of the
atoms due to thermal motion</dd>
<dt><strong><code>fractional_occupancy</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Pass fractional_occupancy = False to turn off fractional occupancy
of atomic sites</dd>
<dt><strong><code>fe</code></strong> :&ensp;<code>float, array_like</code></dt>
<dd>An array containing the electron scattering factors for the elements
in the structure as calculated by the function
calculate_scattering_factors, can be passed to save recalculating
each time new potentials are generated</dd>
<dt><strong><code>device</code></strong> :&ensp;<code>torch.device</code></dt>
<dd>Allows the user to control which device the calculations will occur
on</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>torch.dtype</code></dt>
<dd>Controls the data-type of the output</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Seed for random number generator for atomic displacements.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_potential(
    self,
    pixels,
    subslices=[1.0],
    tiling=[1, 1],
    displacements=True,
    fractional_occupancy=True,
    fe=None,
    device=None,
    dtype=torch.float32,
    seed=None,
):
    &#34;&#34;&#34;
    Generate the projected potential of the structure.

    Calculate the projected electrostatic potential for a structure on a
    pixel grid with dimensions specified by pixels. Subslicing the unit
    cell is achieved by passing an array subslices that contains as its
    entries the depths at which each subslice should be terminated in units
    of fractional coordinates. Tiling of the unit cell (often necessary to
    make a sufficiently large simulation grid to fit the probe) is achieved
    by passing the tiling factors in the array tiling.

    Parameters
    ----------
    pixels: int, (2,) array_like
        The pixel size of the grid on which to calculate the projected
        potentials
    subslices: float, array_like, optional
        An array containing the depths at which each slice ends as a fraction
        of the simulation unit-cell
    tiling: int, (2,) array_like, optional
        Tiling of the simulation object (often necessary to  make a
        sufficiently large simulation grid to fit the probe)
    displacements: bool, optional
        Pass displacements = False to turn off random displacements of the
        atoms due to thermal motion
    fractional_occupancy: bool, optional
        Pass fractional_occupancy = False to turn off fractional occupancy
        of atomic sites
    fe: float, array_like
        An array containing the electron scattering factors for the elements
        in the structure as calculated by the function
        calculate_scattering_factors, can be passed to save recalculating
        each time new potentials are generated
    device: torch.device
        Allows the user to control which device the calculations will occur
        on
    dtype: torch.dtype
        Controls the data-type of the output
    seed: int
        Seed for random number generator for atomic displacements.
    &#34;&#34;&#34;
    # Initialize device cuda if available, CPU if no cuda is available
    device = get_device(device)

    # Ensure pixels is integer
    pixels_ = [int(x) for x in pixels]

    # Seed random number generator for displacements
    if seed is not None:
        torch.manual_seed(seed)

    tiling_ = np.asarray(tiling[:2])
    gsize = np.asarray(self.unitcell[:2]) * tiling_
    psize = np.asarray(pixels_)

    pixperA = np.asarray(pixels_) / np.asarray(self.unitcell[:2]) / tiling_

    # Get a list of unique atomic elements
    elements = list(set(np.asarray(self.atoms[:, 3], dtype=np.int)))

    # Get number of unique atomic elements
    nelements = len(elements)
    nsubslices = len(subslices)
    # Build list of equivalent sites if Fractional occupancy is to be
    # taken into account
    if fractional_occupancy and self.fractional_occupancy:
        equivalent_sites = find_equivalent_sites(self.atoms[:, :3], EPS=1e-3)

    # FDES method
    # Intialize potential array
    P = torch.zeros(
        np.prod([nelements, nsubslices, *pixels_, 2]), device=device, dtype=dtype
    )

    # Construct a map of which atom corresponds to which slice
    islice = np.zeros((self.atoms.shape[0]), dtype=np.int)
    slice_stride = np.prod(pixels_) * 2
    # if nsubslices &gt; 1:
    # Finds which slice atom can be found in
    # WARNING Assumes that the slices list ends with 1.0 and is in
    # ascending order
    for i in range(nsubslices):
        zmin = 0 if i == 0 else subslices[i - 1]
        atoms_in_slice = (self.atoms[:, 2] % 1.0 &gt;= zmin) &amp; (
            self.atoms[:, 2] % 1.0 &lt; subslices[i]
        )
        islice[atoms_in_slice] = i * slice_stride
    islice = torch.from_numpy(islice).type(torch.long).to(device)
    # else:
    #     islice = 0
    # Make map a pytorch Tensor

    # Construct a map of which atom corresponds to which element
    element_stride = nsubslices * slice_stride
    ielement = torch.tensor(
        [
            element_stride * elements.index(int(self.atoms[iatom, 3]))
            for iatom in range(self.atoms.shape[0])
        ],
        dtype=torch.long,
        device=device,
    )

    if displacements:
        # Generate thermal displacements
        urms = torch.tensor(
            np.sqrt(self.atoms[:, 5])[:, np.newaxis] * pixperA[np.newaxis, :],
            dtype=P.dtype,
            device=device,
        ).view(self.atoms.shape[0], 2)

    # FDES algorithm implemented using the pytorch scatter_add function,
    # which takes a list of numbers and adds them to a corresponding list
    # of coordinates
    for tile in range(tiling[0] * tiling[1]):
        # For these atomic coordinates (in fractional coordinates) convert
        # to pixel coordinates
        posn = (
            (
                self.atoms[:, :2]
                + np.asarray([tile % tiling[0], tile // tiling[0]])[np.newaxis, :]
            )
            / tiling_
            * psize
        )
        posn = torch.from_numpy(posn).to(device).type(P.dtype)

        if displacements:

            # Add displacement sampled from normal distribution to account
            # for atomic thermal motion
            disp = (
                torch.randn(self.atoms.shape[0], 2, dtype=P.dtype, device=device)
                * urms
            )

            # If using fractional occupancy force atoms occupying equivalent
            # sites to have the same displacement
            if fractional_occupancy and self.fractional_occupancy:
                disp = disp[equivalent_sites, :]

            posn[:, :2] += disp

        yc = (
            torch.remainder(torch.ceil(posn[:, 0]).type(torch.long), pixels_[0])
            * pixels_[1]
            * 2
        )
        yf = (
            torch.remainder(torch.floor(posn[:, 0]).type(torch.long), pixels_[0])
            * pixels_[1]
            * 2
        )
        xc = (
            torch.remainder(torch.ceil(posn[:, 1]).type(torch.long), pixels_[1]) * 2
        )
        xf = (
            torch.remainder(torch.floor(posn[:, 1]).type(torch.long), pixels_[1])
            * 2
        )

        yh = torch.remainder(posn[:, 0], 1.0)
        yl = 1.0 - yh
        xh = torch.remainder(posn[:, 1], 1.0)
        xl = 1.0 - xh

        # Account for fractional occupancy of atomic sites if requested
        if fractional_occupancy and self.fractional_occupancy:
            xh *= torch.from_numpy(self.atoms[:, 4]).type(P.dtype).to(device)
            xl *= torch.from_numpy(self.atoms[:, 4]).type(P.dtype).to(device)

        # Each pixel is set to the overlap of a shifted rectangle in that pixel
        P.scatter_add_(0, ielement + islice + yc + xc, yh * xh)
        P.scatter_add_(0, ielement + islice + yc + xf, yh * xl)
        P.scatter_add_(0, ielement + islice + yf + xc, yl * xh)
        P.scatter_add_(0, ielement + islice + yf + xf, yl * xl)

    # Now view potential as a 4D array for next bit
    P = P.view(nelements, nsubslices, *pixels_, 2)

    # FFT potential to reciprocal space
    for i in range(P.shape[0]):
        for j in range(P.shape[1]):
            P[i, j] = torch.fft(P[i, j], signal_ndim=2)

    # Make sinc functions with appropriate singleton dimensions for pytorch
    # broadcasting /gridsize[0]*pixels_[0] /gridsize[1]*pixels_[1]
    sincy = (
        sinc(torch.from_numpy(np.fft.fftfreq(pixels_[0])))
        .view([1, 1, pixels_[0], 1, 1])
        .to(device)
        .type(P.dtype)
    )
    sincx = (
        sinc(torch.from_numpy(np.fft.fftfreq(pixels_[1])))
        .view([1, 1, 1, pixels_[1], 1])
        .to(device)
        .type(P.dtype)
    )
    # #Divide by sinc functions
    P /= sincy
    P /= sincx

    # Option to precalculate scattering factors and pass to program which
    # saves computation for
    if fe is None:
        fe_ = calculate_scattering_factors(psize, gsize, elements)
    else:
        fe_ = fe

    # Convolve with electron scattering factors using Fourier convolution theorem
    P *= torch.from_numpy(fe_).view(nelements, 1, *pixels_, 1).to(device)

    norm = np.prod(pixels_) / np.prod(self.unitcell[:2]) / np.prod(tiling)
    # Add atoms together
    P = norm * torch.sum(P, dim=0)

    # Only return real part
    return torch.ifft(P, signal_ndim=2)[..., 0]</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.make_transmission_functions"><code class="name flex">
<span>def <span class="ident">make_transmission_functions</span></span>(<span>self, pixels, eV, subslices=[1.0], tiling=[1, 1], fe=None, displacements=True, fftout=True, dtype=None, device=None, fractional_occupancy=True, seed=None, bandwidth_limit=0.6666666666666666)</span>
</code></dt>
<dd>
<div class="desc"><p>Make the transmission functions for the simulation object.</p>
<p>Transmission functions are the exponential of the specimen electrostatic
potential scaled by the interaction constant for electrons, sigma. These
are used to model scattering by a thin slice of the object in the
multislice algorithm</p>
<h2 id="parameters">Parameters:</h2>
<p>pixels : array_like
Output pixel grid
eV : float
Probe accelerating voltage in electron-volts
subslices : array_like, optional
An array containing the depths at which each slice ends as a fraction
of the simulation unit-cell, used for simulation objects thicker
than typical multislice slicing (about 2 Angstrom)
tiling : array_like,optional
Repeat tiling of the simulation object
fe: array_like,optional
An array containing the electron scattering factors for the elements
in the simulation object as calculated by the function
calculate_scattering_factors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_transmission_functions(
    self,
    pixels,
    eV,
    subslices=[1.0],
    tiling=[1, 1],
    fe=None,
    displacements=True,
    fftout=True,
    dtype=None,
    device=None,
    fractional_occupancy=True,
    seed=None,
    bandwidth_limit=2 / 3,
):
    &#34;&#34;&#34;
    Make the transmission functions for the simulation object.

    Transmission functions are the exponential of the specimen electrostatic
    potential scaled by the interaction constant for electrons, sigma. These
    are used to model scattering by a thin slice of the object in the
    multislice algorithm

    Parameters:
    -----------
    pixels : array_like
        Output pixel grid
    eV : float
        Probe accelerating voltage in electron-volts
    subslices : array_like, optional
        An array containing the depths at which each slice ends as a fraction
        of the simulation unit-cell, used for simulation objects thicker
        than typical multislice slicing (about 2 Angstrom)
    tiling : array_like,optional
        Repeat tiling of the simulation object
    fe: array_like,optional
        An array containing the electron scattering factors for the elements
        in the simulation object as calculated by the function
        calculate_scattering_factors
    &#34;&#34;&#34;
    # Make the specimen electrostatic potential
    T = self.make_potential(
        pixels,
        subslices,
        tiling,
        fe=fe,
        displacements=displacements,
        device=device,
        dtype=dtype,
        fractional_occupancy=fractional_occupancy,
        seed=seed,
    )

    # Now take the complex exponential of the electrostatic potential
    # scaled by the electron interaction constant
    T = torch.fft(torch_c_exp(interaction_constant(eV) * T), signal_ndim=2)

    # Band-width limit the transmission function, see Earl Kirkland&#39;s book
    # for an discussion of why this is necessary
    for i in range(T.shape[0]):
        T[i] = bandwidth_limit_array(T[i], bandwidth_limit)

    if fftout:
        return torch.ifft(T, signal_ndim=2)
    return T</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.orthorhombic_supercell"><code class="name flex">
<span>def <span class="ident">orthorhombic_supercell</span></span>(<span>self, EPS=0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an orthorhombic supercell from a monoclinic crystal unit cell.</p>
<p>If not orthorhombic attempt psuedo rational tiling of general
monoclinic structure. Assumes that the self.unitcell matrix is lower
triangular.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def orthorhombic_supercell(self, EPS=1e-2):
    &#34;&#34;&#34;
    Create an orthorhombic supercell from a monoclinic crystal unit cell.

    If not orthorhombic attempt psuedo rational tiling of general
    monoclinic structure. Assumes that the self.unitcell matrix is lower
    triangular.
    &#34;&#34;&#34;
    if not np.abs(np.dot(self.unitcell[0], self.unitcell[1])) &lt; EPS:
        tiley, tilex = psuedo_rational_tiling(*self.unitcell[0:2, 0], EPS)

        # Make deepcopy of old unit cell

        olduc = copy.deepcopy(self.unitcell)

        # Tile out atoms
        self.tile(tiley, tilex, 1)

        # Calculate size of old unit cell under tiling
        olduc = np.asarray([tiley, tilex, 1])[:, np.newaxis] * olduc

        self.unitcell = copy.deepcopy(olduc)
        self.unitcell[1, 0] = 0.0

        # Now calculate fractional coordinates in new orthorhombic cell
        self.atoms[:, :3] = change_of_basis(self.atoms[:, :3], self.unitcell, olduc)
    else:
        self.unitcell[0, 1:] = 0.0
        self.unitcell[1, ::2] = 0.0

    # Now tile crystal in x and y
    tilez1, tiley = psuedo_rational_tiling(*self.unitcell[::-2, 0], EPS)
    tilez2, tilex = psuedo_rational_tiling(*self.unitcell[3:0:-1, 1], EPS)
    tilez = remove_common_factors([tilez1, tilez2, tilez1 * tilez2])[-1]
    tiley *= tilez // tilez1
    tilex *= tilez // tilez2

    olduc = copy.deepcopy(self.unitcell)

    # Tile out atoms
    self.tile(tiley, tilex, tilez)

    # Calculate size of old unit cell under tiling

    olduc = np.asarray([tiley, tilex, tilez])[:, np.newaxis] * olduc

    self.unitcell = copy.deepcopy(olduc)
    self.unitcell[2, 0:2] = 0.0

    # Now calculate fractional coordinates in new orthorhombic cell
    self.atoms[:, :3] = np.mod(
        self.atoms[:, :3] @ olduc @ np.linalg.inv(self.unitcell), 1.0
    )
    self.unitcell = np.diag(self.unitcell)

    # Check for negative values of self.unitcell and rectify
    for i in range(3):
        if self.unitcell[i] &lt; 0:
            self.atoms[:, i] = (1.0 - self.atoms[:, i]) % 1.0
    self.unitcell = np.abs(self.unitcell)</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.output_vesta_xtl"><code class="name flex">
<span>def <span class="ident">output_vesta_xtl</span></span>(<span>self, fnam)</span>
</code></dt>
<dd>
<div class="desc"><p>Output an .xtl file which is viewable by the vesta software.</p>
<p>See K. Momma and F. Izumi, "VESTA 3 for three-dimensional visualization
of crystal, volumetric and morphology data," J. Appl. Crystallogr., 44,
1272-1276 (2011).</p>
<p>Warning: Vesta xtl files do not contain fractional occupancy information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_vesta_xtl(self, fnam):
    &#34;&#34;&#34;Output an .xtl file which is viewable by the vesta software.

    See K. Momma and F. Izumi, &#34;VESTA 3 for three-dimensional visualization
    of crystal, volumetric and morphology data,&#34; J. Appl. Crystallogr., 44,
    1272-1276 (2011).

    Warning: Vesta xtl files do not contain fractional occupancy information
    &#34;&#34;&#34;
    f = open(splitext(fnam)[0] + &#34;.xtl&#34;, &#34;w&#34;)
    f.write(&#34;TITLE &#34; + self.Title + &#34;\n CELL \n&#34;)
    f.write(&#34;  {0:.5f} {1:.5f} {2:.5f} 90 90 90\n&#34;.format(*self.unitcell))
    f.write(&#34;SYMMETRY NUMBER 1\n SYMMETRY LABEL  P1\n ATOMS \n&#34;)
    f.write(&#34;NAME         X           Y           Z&#34; + &#34;\n&#34;)
    for i in range(self.atoms.shape[0]):
        f.write(
            &#34;{0} {1:.4f} {2:.4f} {3:.4f}\n&#34;.format(
                atomic_symbol[int(self.atoms[i, 3])], *self.atoms[i, :3]
            )
        )
    f.write(&#34;EOF&#34;)
    f.close()</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.output_xyz"><code class="name flex">
<span>def <span class="ident">output_xyz</span></span>(<span>self, fnam, atomic_coordinates='cartesian', temperature_factor_units='sqrturms')</span>
</code></dt>
<dd>
<div class="desc"><p>Output an .xyz structure file.</p>
<p>This is the input format used by Kirkland's EM codes and the prismatic
software.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_xyz(
    self, fnam, atomic_coordinates=&#34;cartesian&#34;, temperature_factor_units=&#34;sqrturms&#34;
):
    &#34;&#34;&#34;
    Output an .xyz structure file.

    This is the input format used by Kirkland&#39;s EM codes and the prismatic
    software.
    &#34;&#34;&#34;
    f = open(splitext(fnam)[0] + &#34;.xyz&#34;, &#34;w&#34;)
    f.write(self.Title + &#34;\n {0:.4f} {1:.4f} {2:.4f}\n&#34;.format(*self.unitcell))

    if atomic_coordinates == &#34;cartesian&#34;:
        coords = self.atoms[:, :3] * self.unitcell
    else:
        coords = self.atoms[:, :3]

    # If temperature factors are given as B then convert to urms
    if temperature_factor_units == &#34;B&#34;:
        DWFs = self.atoms[:, 5] * 8 * np.pi ** 2
    elif temperature_factor_units == &#34;sqrturms&#34;:
        DWFs = np.sqrt(self.atoms[:, 5])

    for coord, atom, DWF in zip(coords, self.atoms, DWFs):
        f.write(
            &#34;{0:d} {1:.4f} {2:.4f} {3:.4f} {4:.2f}  {5:.3f}\n&#34;.format(
                int(atom[3]), *coord, atom[4], DWF
            )
        )
    f.write(&#34;-1&#34;)
    f.close()</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.quickplot"><code class="name flex">
<span>def <span class="ident">quickplot</span></span>(<span>self, atomscale=None, cmap=&lt;matplotlib.colors.ListedColormap object&gt;, block=True, colors=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a quick 3D scatter plot of the atomic sites within the structure.</p>
<p>For more detailed visualization output the structure file to a file format
readable by the Vesta software using output_vesta_xtl</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quickplot(
    self, atomscale=None, cmap=plt.get_cmap(&#34;Dark2&#34;), block=True, colors=None
):
    &#34;&#34;&#34;
    Make a quick 3D scatter plot of the atomic sites within the structure.

    For more detailed visualization output the structure file to a file format
    readable by the Vesta software using output_vesta_xtl
    &#34;&#34;&#34;
    from mpl_toolkits.mplot3d import Axes3D  # NOQA

    if atomscale is None:
        atomscale = 1e-3 * np.amax(self.unitcell)

    fig = plt.figure()
    ax = fig.add_subplot(111, projection=&#34;3d&#34;)

    if colors is None:
        colors = cmap(self.atoms[:, 3] / np.amax(self.atoms[:, 3]))
    sizes = self.atoms[:, 3] * atomscale

    ax.scatter(
        *[self.atoms[:, i] * self.unitcell[i] for i in [1, 0, 2]], c=colors, s=sizes
    )

    ax.set_xlim3d(0.0, self.unitcell[1])
    ax.set_ylim3d(top=0.0, bottom=self.unitcell[0])
    ax.set_zlim3d(top=0.0, bottom=self.unitcell[2])
    ax.set_xlabel(&#34;x&#34;)
    ax.set_ylabel(&#34;y&#34;)
    ax.set_zlabel(&#34;z&#34;)

    plt.show(block=block)
    return fig</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.reflect"><code class="name flex">
<span>def <span class="ident">reflect</span></span>(<span>self, axes)</span>
</code></dt>
<dd>
<div class="desc"><p>Reflect structure in each of the axes enumerated in list axes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reflect(self, axes):
    &#34;&#34;&#34;Reflect structure in each of the axes enumerated in list axes.&#34;&#34;&#34;
    for ax in axes:
        self.atoms[:, ax] = (1 - self.atoms[:, ax]) % 1.0
    return self</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, fraction, axis)</span>
</code></dt>
<dd>
<div class="desc"><p>Resize (either crop or pad with vacuum) the simulation object.</p>
<p>Resize the simulation object ranging such that the new axis runs from
fraction[iax,0] to fraction[iax,1] on specified axis iax, slice_frac is
in units of fractional coordinates. If fraction[iax,0] is &lt; 0 then
additional vacuum will be added, if &gt; 0 then parts of the sample will
be removed for axis[iax]. Likewise if fraction[iax,1] is &gt; 1 then
additional vacuum will be added, if &lt; 1 then parts of the sample will
be removed for axis[iax].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fraction</code></strong> :&ensp;<code>(nax,2) array_like</code></dt>
<dd>Describes the size of the new simulation object as a fraction of
old simulation object dimensions.</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code> or <code>(nax,) array_like</code></dt>
<dd>The axes of the simulation object that wil lbe resized</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>New structure : pyms.structure object</code></dt>
<dd>The resized structure object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize(self, fraction, axis):
    &#34;&#34;&#34;
    Resize (either crop or pad with vacuum) the simulation object.

    Resize the simulation object ranging such that the new axis runs from
    fraction[iax,0] to fraction[iax,1] on specified axis iax, slice_frac is
    in units of fractional coordinates. If fraction[iax,0] is &lt; 0 then
    additional vacuum will be added, if &gt; 0 then parts of the sample will
    be removed for axis[iax]. Likewise if fraction[iax,1] is &gt; 1 then
    additional vacuum will be added, if &lt; 1 then parts of the sample will
    be removed for axis[iax].

    Parameters
    ----------
    fraction : (nax,2) array_like
        Describes the size of the new simulation object as a fraction of
        old simulation object dimensions.
    axis : int or (nax,) array_like
        The axes of the simulation object that wil lbe resized

    Returns
    -------
    New structure : pyms.structure object
        The resized structure object
    &#34;&#34;&#34;
    ax = ensure_array(axis)
    frac = ensure_array(fraction)
    if np.asarray(frac).ndim &lt; 2:
        frac = [frac]

    # Work out which atoms will stay in the sliced structure
    mask = np.ones((self.atoms.shape[0],), dtype=np.bool)
    for a, f in zip(ax, frac):
        atomsin = np.logical_and(self.atoms[:, a] &gt;= f[0], self.atoms[:, a] &lt;= f[1])
        mask = np.logical_and(atomsin, mask)

    # Make a copy of the structure
    new = copy.deepcopy(self)

    # Put remaining atoms back in
    new.atoms = self.atoms[mask, :]

    # Origin for atomic coordinates
    origin = np.zeros((3))

    for a, f in zip(ax, frac):
        # Adjust unit cell dimensions
        new.unitcell[a] = (f[1] - f[0]) * self.unitcell[a]

        # Adjust origin of atomic coordinates
        origin[a] = f[0]

    new.atoms[:, :3] = (new.atoms[:, :3] - origin) * self.unitcell / new.unitcell

    # Return modified structure
    return new</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.rot90"><code class="name flex">
<span>def <span class="ident">rot90</span></span>(<span>self, k=1, axes=(0, 1))</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates a structure by 90 degrees in the plane specified by axes.</p>
<p>Rotation direction is from the first towards the second axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>k</code></strong> :&ensp;<code>integer</code>, optional</dt>
<dd>Number of times the structure is rotated by 90 degrees.</dd>
<dt><strong><code>axes</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>The array is rotated in the plane defined by the axes.
Axes must be different.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rot90(self, k=1, axes=(0, 1)):
    &#34;&#34;&#34;
    Rotates a structure by 90 degrees in the plane specified by axes.

    Rotation direction is from the first towards the second axis.

    Parameters
    ----------
    k : integer, optional
        Number of times the structure is rotated by 90 degrees.
    axes: (2,) array_like
        The array is rotated in the plane defined by the axes.
        Axes must be different.
    &#34;&#34;&#34;
    # Much of the following is adapted from the numpy.rot90 function
    axes = tuple(axes)
    if len(axes) != 2:
        raise ValueError(&#34;len(axes) must be 2.&#34;)

    k %= 4

    if k == 0:
        # Do nothing
        return
    if k == 2:
        # Reflect in both axes
        self.reflect(axes)
        return

    axes_list = np.arange(0, 3)
    (axes_list[axes[0]], axes_list[axes[1]]) = (
        axes_list[axes[1]],
        axes_list[axes[0]],
    )

    if k == 1:
        self.reflect([axes[1]])
        self.transpose(axes_list)
    else:
        # k == 3
        self.transpose(axes_list)
        self.reflect([axes[1]])

    return self</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, theta, axis, origin=[0.5, 0.5, 0.5])</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate simulation object an amount an angle theta (in radians) about axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>Angle to rotate simulation object by in radians</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Axis about which to rotate simulation object eg [0,0,1]</dd>
</dl>
<h2 id="keyword-arguments">Keyword Arguments</h2>
<p>origin : array_like, optional
Origin (in fractional coordinates) about which to rotate simulation
object eg [0.5, 0.5, 0.5]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(self, theta, axis, origin=[0.5, 0.5, 0.5]):
    &#34;&#34;&#34;
    Rotate simulation object an amount an angle theta (in radians) about axis.

    Parameters
    ----------
    theta: float
        Angle to rotate simulation object by in radians
    axis: array_like
        Axis about which to rotate simulation object eg [0,0,1]

    Keyword arguments
    ------------------
    origin : array_like, optional
        Origin (in fractional coordinates) about which to rotate simulation
        object eg [0.5, 0.5, 0.5]
    &#34;&#34;&#34;
    new = copy.deepcopy(self)

    # Make rotation matrix, R, and  the point about which we rotate, O
    R = rot_matrix(theta, axis)
    origin_ = np.asarray(origin) * self.unitcell

    # Get atomic coordinates in cartesian (not fractional coordinates)
    new.atoms[:, :3] = self.atoms[:, :3] * self.unitcell[np.newaxis, :]

    # Apply rotation matrix to each atom coordinate
    new.atoms[:, :3] = (new.atoms[:, :3] - origin_) @ R + origin_

    # Apply rotation matrix to cell vertices
    vertices = (
        np.asarray([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]])
        * self.unitcell
        - origin_
    ) @ R + origin_

    # Get new unit cell from maximum range of unit cell vertices
    origin_ = np.amin(vertices, axis=0)
    new.unitcell = np.ptp(vertices, axis=0)

    # Convert atoms back into fractional coordinates in new unit cell
    new.atoms[:, :3] = ((new.atoms[:, :3] - origin_) / new.unitcell) % 1.0

    # Return rotated structure
    return new</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.tile"><code class="name flex">
<span>def <span class="ident">tile</span></span>(<span>self, x=1, y=1, z=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a repeat unit tiling of the simulation object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tile(self, x=1, y=1, z=1):
    &#34;&#34;&#34;Make a repeat unit tiling of the simulation object.&#34;&#34;&#34;
    # Make copy of original structure
    # new = copy.deepcopy(self)

    tiling = np.asarray([x, y, z], dtype=np.int)

    # Get atoms in unit cell
    natoms = self.atoms.shape[0]

    # Initialize new atom list
    newatoms = np.zeros((natoms * x * y * z, 6))

    # Calculate new unit cell size
    self.unitcell = self.unitcell * np.asarray([x, y, z])

    # tile out the integer amounts
    from itertools import product

    for j, k, l in product(*[np.arange(int(i)) for i in [x, y, z]]):

        # Calculate origin of this particular tile
        origin = np.asarray([j, k, l])

        # Calculate index of this particular tile
        indx = j * int(y) * int(z) + k * int(z) + l

        # Add new atoms to unit cell
        newatoms[indx * natoms : (indx + 1) * natoms, :3] = (
            self.atoms[:, :3] + origin[np.newaxis, :]
        ) / tiling[np.newaxis, :]

        # Copy other information about atoms
        newatoms[indx * natoms : (indx + 1) * natoms, 3:] = self.atoms[:, 3:]
    self.atoms = newatoms
    return self</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.to_ase_atoms"><code class="name flex">
<span>def <span class="ident">to_ase_atoms</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert structure to Atomic Simulation Environment (ASE) atoms object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_ase_atoms(self):
    &#34;&#34;&#34;Convert structure to Atomic Simulation Environment (ASE) atoms object.&#34;&#34;&#34;
    scaled_positions = self.atoms[:, :3]
    numbers = self.atoms[:, 3].astype(np.int)
    cell = self.unitcell
    pbc = [True, True, True]
    return ase.Atoms(
        scaled_positions=scaled_positions, numbers=numbers, cell=cell, pbc=pbc
    )</code></pre>
</details>
</dd>
<dt id="pyms.structure_routines.structure.transpose"><code class="name flex">
<span>def <span class="ident">transpose</span></span>(<span>self, axes)</span>
</code></dt>
<dd>
<div class="desc"><p>Transpose the axes of a simulation object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transpose(self, axes):
    &#34;&#34;&#34;Transpose the axes of a simulation object.&#34;&#34;&#34;
    self.atoms[:, :3] = self.atoms[:, axes]
    self.unitcell = self.unitcell[axes]
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyms" href="index.html">pyms</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyms.structure_routines.Xray_scattering_factor" href="#pyms.structure_routines.Xray_scattering_factor">Xray_scattering_factor</a></code></li>
<li><code><a title="pyms.structure_routines.calculate_scattering_factors" href="#pyms.structure_routines.calculate_scattering_factors">calculate_scattering_factors</a></code></li>
<li><code><a title="pyms.structure_routines.change_of_basis" href="#pyms.structure_routines.change_of_basis">change_of_basis</a></code></li>
<li><code><a title="pyms.structure_routines.electron_scattering_factor" href="#pyms.structure_routines.electron_scattering_factor">electron_scattering_factor</a></code></li>
<li><code><a title="pyms.structure_routines.find_equivalent_sites" href="#pyms.structure_routines.find_equivalent_sites">find_equivalent_sites</a></code></li>
<li><code><a title="pyms.structure_routines.interaction_constant" href="#pyms.structure_routines.interaction_constant">interaction_constant</a></code></li>
<li><code><a title="pyms.structure_routines.psuedo_rational_tiling" href="#pyms.structure_routines.psuedo_rational_tiling">psuedo_rational_tiling</a></code></li>
<li><code><a title="pyms.structure_routines.remove_common_factors" href="#pyms.structure_routines.remove_common_factors">remove_common_factors</a></code></li>
<li><code><a title="pyms.structure_routines.rot_matrix" href="#pyms.structure_routines.rot_matrix">rot_matrix</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyms.structure_routines.layered_structure_propagators" href="#pyms.structure_routines.layered_structure_propagators">layered_structure_propagators</a></code></h4>
<ul class="">
<li><code><a title="pyms.structure_routines.layered_structure_propagators.dim" href="#pyms.structure_routines.layered_structure_propagators.dim">dim</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyms.structure_routines.layered_structure_transmission_function" href="#pyms.structure_routines.layered_structure_transmission_function">layered_structure_transmission_function</a></code></h4>
<ul class="">
<li><code><a title="pyms.structure_routines.layered_structure_transmission_function.dim" href="#pyms.structure_routines.layered_structure_transmission_function.dim">dim</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyms.structure_routines.structure" href="#pyms.structure_routines.structure">structure</a></code></h4>
<ul class="">
<li><code><a title="pyms.structure_routines.structure.concatenate" href="#pyms.structure_routines.structure.concatenate">concatenate</a></code></li>
<li><code><a title="pyms.structure_routines.structure.cshift" href="#pyms.structure_routines.structure.cshift">cshift</a></code></li>
<li><code><a title="pyms.structure_routines.structure.from_ase_cluster" href="#pyms.structure_routines.structure.from_ase_cluster">from_ase_cluster</a></code></li>
<li><code><a title="pyms.structure_routines.structure.fromfile" href="#pyms.structure_routines.structure.fromfile">fromfile</a></code></li>
<li><code><a title="pyms.structure_routines.structure.generate_slicing_figure" href="#pyms.structure_routines.structure.generate_slicing_figure">generate_slicing_figure</a></code></li>
<li><code><a title="pyms.structure_routines.structure.make_potential" href="#pyms.structure_routines.structure.make_potential">make_potential</a></code></li>
<li><code><a title="pyms.structure_routines.structure.make_transmission_functions" href="#pyms.structure_routines.structure.make_transmission_functions">make_transmission_functions</a></code></li>
<li><code><a title="pyms.structure_routines.structure.orthorhombic_supercell" href="#pyms.structure_routines.structure.orthorhombic_supercell">orthorhombic_supercell</a></code></li>
<li><code><a title="pyms.structure_routines.structure.output_vesta_xtl" href="#pyms.structure_routines.structure.output_vesta_xtl">output_vesta_xtl</a></code></li>
<li><code><a title="pyms.structure_routines.structure.output_xyz" href="#pyms.structure_routines.structure.output_xyz">output_xyz</a></code></li>
<li><code><a title="pyms.structure_routines.structure.quickplot" href="#pyms.structure_routines.structure.quickplot">quickplot</a></code></li>
<li><code><a title="pyms.structure_routines.structure.reflect" href="#pyms.structure_routines.structure.reflect">reflect</a></code></li>
<li><code><a title="pyms.structure_routines.structure.resize" href="#pyms.structure_routines.structure.resize">resize</a></code></li>
<li><code><a title="pyms.structure_routines.structure.rot90" href="#pyms.structure_routines.structure.rot90">rot90</a></code></li>
<li><code><a title="pyms.structure_routines.structure.rotate" href="#pyms.structure_routines.structure.rotate">rotate</a></code></li>
<li><code><a title="pyms.structure_routines.structure.tile" href="#pyms.structure_routines.structure.tile">tile</a></code></li>
<li><code><a title="pyms.structure_routines.structure.to_ase_atoms" href="#pyms.structure_routines.structure.to_ase_atoms">to_ase_atoms</a></code></li>
<li><code><a title="pyms.structure_routines.structure.transpose" href="#pyms.structure_routines.structure.transpose">transpose</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>