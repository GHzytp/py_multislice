<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>pyms.Probe API documentation</title>
<meta name="description" content="Functions for emulating electron optics of a TEM." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyms.Probe</code></h1>
</header>
<section id="section-intro">
<p>Functions for emulating electron optics of a TEM.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions for emulating electron optics of a TEM.&#34;&#34;&#34;

import numpy as np
import copy
from .utils.numpy_utils import q_space_array


class aberration:
    &#34;&#34;&#34;A class describing electron lens aberrations.&#34;&#34;&#34;

    def __init__(self, Krivanek, Haider, Description, amplitude, angle, n, m):
        &#34;&#34;&#34;
        Intialize the lens aberration object.

        Parameters
        ----------
        Krivanek : str
            A string describing the aberration coefficient in Krivanek notation
            (C_mn)
        Haider : str
            A string describing the aberration coefficient in Haider notation
            (ie. A1, A2, B2)
        Description : str
            A string describing the colloqiual name of the aberration ie. 2-fold
            astig.
        amplitude : float
            The amplitude of the aberration in Angstrom
        angle : float
            The angle of the aberration in radians
        n : int
            The principle aberration order
        m : int
            The rotational order of the aberration.
        &#34;&#34;&#34;
        self.Krivanek = Krivanek
        self.Haider = Haider
        self.Description = Description
        self.amplitude = amplitude
        self.m = m
        self.n = n
        if m &gt; 0:
            self.angle = angle
        else:
            self.angle = 0

    def __str__(self):
        &#34;&#34;&#34;Return a string describing the aberration.&#34;&#34;&#34;
        if self.m &gt; 0:
            return (
                &#34;{0:17s} ({1:2s}) -- {2:3s} = {3:9.2e} \u00E5 \u03B8 = &#34;
                + &#34;{4:4d}\u00B0 &#34;
            ).format(
                self.Description,
                self.Haider,
                self.Krivanek,
                self.amplitude,
                int(np.rad2deg(self.angle)),
            )
        else:
            return &#34; {0:17s} ({1:2s}) -- {2:3s} = {3:9.2e} \u00E5&#34;.format(
                self.Description, self.Haider, self.Krivanek, self.amplitude
            )


def depth_of_field(eV, alpha):
    &#34;&#34;&#34;
    Calculate the probe depth of field (z-resolution) for a probe.

    Parameters
    ----------
    eV : float
        Probe accelerating voltage in electron volts
    alpha : float
        Probe forming semi-angle in mrad
    Returns
    -------
    dof : float
        The probe full-width-at-half-maximum (FWHM) depth of field
    &#34;&#34;&#34;
    return 1.77 / wavev(eV) / alpha / alpha * 1e6


def aberration_starter_pack():
    &#34;&#34;&#34;Create the set of aberrations up to fifth order.&#34;&#34;&#34;
    aberrations = []
    aberrations.append(aberration(&#34;C10&#34;, &#34;C1&#34;, &#34;Defocus          &#34;, 0.0, 0.0, 1, 0))
    aberrations.append(aberration(&#34;C12&#34;, &#34;A1&#34;, &#34;2-Fold astig.    &#34;, 0.0, 0.0, 1, 2))
    aberrations.append(aberration(&#34;C23&#34;, &#34;A2&#34;, &#34;3-Fold astig.    &#34;, 0.0, 0.0, 2, 3))
    aberrations.append(aberration(&#34;C21&#34;, &#34;B2&#34;, &#34;Axial coma       &#34;, 0.0, 0.0, 2, 1))
    aberrations.append(aberration(&#34;C30&#34;, &#34;C3&#34;, &#34;3rd order spher. &#34;, 0.0, 0.0, 3, 0))
    aberrations.append(aberration(&#34;C34&#34;, &#34;A3&#34;, &#34;4-Fold astig.    &#34;, 0.0, 0.0, 3, 4))
    aberrations.append(aberration(&#34;C32&#34;, &#34;S3&#34;, &#34;Axial star aber. &#34;, 0.0, 0.0, 3, 2))
    aberrations.append(aberration(&#34;C45&#34;, &#34;A4&#34;, &#34;5-Fold astig.    &#34;, 0.0, 0.0, 4, 5))
    aberrations.append(aberration(&#34;C43&#34;, &#34;D4&#34;, &#34;3-Lobe aberr.    &#34;, 0.0, 0.0, 4, 3))
    aberrations.append(aberration(&#34;C41&#34;, &#34;B4&#34;, &#34;4th order coma   &#34;, 0.0, 0.0, 4, 1))
    aberrations.append(aberration(&#34;C50&#34;, &#34;C5&#34;, &#34;5th order spher. &#34;, 0.0, 0.0, 5, 0))
    aberrations.append(aberration(&#34;C56&#34;, &#34;A5&#34;, &#34;6-Fold astig.    &#34;, 0.0, 0.0, 5, 6))
    aberrations.append(aberration(&#34;C52&#34;, &#34;S5&#34;, &#34;5th order star   &#34;, 0.0, 0.0, 5, 2))
    aberrations.append(aberration(&#34;C54&#34;, &#34;R5&#34;, &#34;5th order rosette&#34;, 0.0, 0.0, 5, 4))
    return aberrations


def chi(q, qphi, lam, df=0.0, aberrations=[]):
    r&#34;&#34;&#34;
    Calculate the aberration function, chi.

    Parameters
    ----------
    q : float or array_like
        Reciprocal space extent (Inverse angstroms).
    qphi : float or array_like
        Azimuth of grid in radians
    lam : float
        Wavelength of electron (Inverse angstroms).
    df : float, optional
        Defocus in Angstrom
    aberrations : list, optional
        A list containing a set of the class aberration, pass an empty list for
        an unaberrated contrast transfer function.
    Returns
    -------
    chi : float or array_like
        The aberration function, will be the same shape as `q`. This is used to
        calculate the probe wave function in reciprocal space.
    &#34;&#34;&#34;
    qlam = q * lam
    chi_ = qlam ** 2 / 2 * df
    for ab in aberrations:
        chi_ += (
            qlam ** (ab.n + 1)
            * float(ab.amplitude)
            / (ab.n + 1)
            * np.cos(ab.m * (qphi - float(ab.angle)))
        )
    return 2 * np.pi * chi_ / lam


def make_contrast_transfer_function(
    pix_dim,
    real_dim,
    eV,
    app,
    optic_axis=[0, 0],
    aperture_shift=[0, 0],
    tilt_units=&#34;mrad&#34;,
    df=0,
    aberrations=[],
    q=None,
    app_units=&#34;mrad&#34;,
):
    &#34;&#34;&#34;
    Make an electron lens contrast transfer function.

    Parameters
    ---------
    pix_dim : (2,) int array_like
        The pixel size of the grid
    real_dim : (2,) float array_like
        The size of the grid in Angstrom
    eV : float
        The energy of the probe electrons in eV
    app : float or None
        The aperture in units specified by app_units, pass `app` = None for
        no aperture
    optic_axis : (2,) array_like, optional
        allows the user to specify a different optic axis in units specified by
        `tilt_units`
    aperture_shift : (2,) array_like, optional
        Shift of the objective aperture relative to the center of the array
    tilt_units : string
        Units of the `optic_axis` or `aperture_shift` values, default is mrad
    df : float
        Probe defocus in A, a negative value indicate overfocus
    aberrations : array_like of aberration objects
        List containing instances of class aberration
    q :
        Precomputed reciprocal space array, allows the user to reduce
        computation time somewhat
    app_units : string
        The units of `app` (A^-1 or mrad)
    Returns
    -------
    ctf : array_like
        The lens contrast transfer function in reciprocal space
    &#34;&#34;&#34;
    # Make reciprocal space array
    if q is None:
        q = q_space_array(pix_dim, real_dim[:2])

    # Get  electron wave number (inverse of wavelength)
    k = wavev(eV)

    # Convert tilts to units of inverse Angstrom
    optic_axis_ = convert_tilt_angles(
        optic_axis, tilt_units, real_dim, eV, invA_out=True
    )
    aperture_shift_ = convert_tilt_angles(
        aperture_shift, tilt_units, real_dim, eV, invA_out=True
    )

    if app is None:
        app_ = np.amax(np.abs(q))
    else:
        # Get aperture size in units of inverse Angstrom
        app_ = convert_tilt_angles(app, app_units, real_dim, eV, invA_out=True)

    # Initialize the array to contain the CTF
    CTF = np.zeros(pix_dim, dtype=np.complex)

    # Calculate the magnitude of the reciprocal lattice grid
    # qarray1 accounts for a shift of the optic axis
    qarray1 = np.sqrt(
        np.square(q[0] - optic_axis_[0]) + np.square(q[1] - optic_axis_[1])
    )

    # qarray2 accounts for a shift of both the optic axis and the aperture
    qarray2 = np.square(q[0] - optic_axis_[0] - aperture_shift_[0]) + np.square(
        q[1] - optic_axis_[1] - aperture_shift_[1]
    )

    # Calculate azimuth of reciprocal space array in case it is required for
    # aberrations
    qphi = np.arctan2(q[0] - optic_axis_[0], q[1] - optic_axis_[1])

    # Only calculate CTF for region within the aperture
    mask = qarray2 &lt;= app_ ** 2
    CTF[mask] = np.exp(-1j * chi(qarray1[mask], qphi[mask], 1.0 / k, df, aberrations))
    return CTF


def focused_probe(
    gridshape,
    rsize,
    eV,
    app,
    beam_tilt=[0, 0],
    aperture_shift=[0, 0],
    tilt_units=&#34;mrad&#34;,
    df=0,
    aberrations=[],
    q=None,
    app_units=&#34;mrad&#34;,
    qspace=False,
):
    &#34;&#34;&#34;
    Make a focused electron probe wave function.

    Parameters
    ---------
    gridshape : (2,) array_like
        The pixel size of the grid
    rsize : (2,) array_like
        The size of the grid in Angstrom
    eV : float
        The energy of the probe electrons in electron volts
    app : float
        The probe-forming apperture in units specified by app_units, pass None
        if no probe forming aperture is to be used
    beam_tilt : array_like, optional
        Allows the user to simulate a (small &lt; 50 mrad) beam tilt. To maintain
        periodicity of the wave function at the boundaries this tilt is rounded
        to the nearest pixel value.
    aperture_shift : array_like, optional
        Allows the user to simulate a (small &lt; 50 mrad) aperture shift. To
        maintain periodicity of the wave function at the boundaries this tilt
        is rounded to the nearest pixel value.
    tilt_units : string, optional
        Units of beam tilt and aperture shift, can be &#39;mrad&#39;,&#39;pixels&#39; or &#39;invA&#39;
    df : float, optional
        Probe defocus in A, a negative value indicate overfocus
    aberrations : list, optional
        A list of of probe aberrations of class pyms.Probe.aberration, pass an
        empty list for an un-aberrated probe
    app_units : string, optional
        The units of the aperture size (&#34;invA&#34;, &#34;pixels&#34; or &#34;mrad&#34;)
    qspace : bool, optional
        If True return the probe in reciprocal space
    Returns
    -------
    probe : complex (Y,X) np.ndarray
        The requested electron probe wave function
    &#34;&#34;&#34;
    probe = make_contrast_transfer_function(
        gridshape,
        rsize,
        eV,
        app,
        beam_tilt,
        aperture_shift,
        tilt_units,
        df,
        aberrations,
        q,
        app_units,
    )

    # Normalize the STEM probe so that its sum-squared intensity is unity
    probe *= np.sqrt(np.prod(gridshape)) / np.sqrt(np.sum(np.square(np.abs(probe))))

    # Return real or diffraction space probe depending on user preference
    if not qspace:
        return np.fft.ifft2(probe)
    return probe


def plane_wave_illumination(
    gridshape, gridsize, eV, tilt=[0, 0], tilt_units=&#34;mrad&#34;, qspace=False
):
    &#34;&#34;&#34;
    Generate plane wave illumination for input to multislice.

    The wave function will be normalized such that sum of intensity is unity in
    real space.

    Parameters
    ----------
    gridshape : (2,) array_like
        Pixel dimensions of the 2D grid
    gridsize : (2,) array_like
        Size of the grid in real space
    eV : float
        Probe energy in electron volts (irrelevant for untilted illumination)
    tilt : array_like, optional
        Allows the user to simulate a (small &lt; 50 mrad) beam tilt, To maintain
        periodicity of the wave function at the boundaries this tilt is rounded
        to the nearest pixel value.
    tilt_units : string, optional
        Units of beam tilt, can be &#39;mrad&#39;,&#39;pixels&#39; or &#39;invA&#39;
    qspace : bool, optional
        Pass qspace = True to get the probe in momentum (q) space
    Returns
    ------
    illum : np.ndarray (Y,X)
    &#34;&#34;&#34;
    # Initialize array that contains wave function
    illum = np.zeros(gridshape, dtype=np.complex)

    # Convert tilt to units of pixels
    tilt_ = convert_tilt_angles(tilt, tilt_units, gridsize, eV)

    # Case of an untilted plane wave (phase is zero everywhere)
    if tilt[0] == 0 and tilt[1] == 0:
        illum[:, :] = 1 / np.sqrt(np.product(gridshape))

        if qspace:
            return np.fft.fft2(illum)
        else:
            return illum

    # Set the value of wavefunction amplitude such that after inverse Fourier
    # transform (and resulting division by the total number of pixels) the sum
    # of intensity will be 1
    illum[tilt_[0], tilt_[1]] = np.sqrt(np.product(gridshape))

    # Return wave function in real space
    if qspace:
        return illum
    else:
        return np.fft.ifft2(illum)


def wavev(E):
    &#34;&#34;&#34;
    Evaluate the relativistically corrected wavenumber of an electron with energy E.

    Energy E must be in electron-volts, see Eq. (2.5) in Kirkland&#39;s Advanced
    Computing in electron microscopy
    &#34;&#34;&#34;
    # Planck&#39;s constant times speed of light in eV Angstrom
    hc = 1.23984193e4
    # Electron rest mass in eV
    m0c2 = 5.109989461e5
    return np.sqrt(E * (E + 2 * m0c2)) / hc


def relativistic_mass_correction(E):
    &#34;&#34;&#34;
    Evaluate the relativistic mass correction for electron with energy E in eV.

    See Eq. (2.2) in Kirkland&#39;s Advanced Computing in electron microscopy.
    &#34;&#34;&#34;
    # Electron rest mass in eV
    m0c2 = 5.109989461e5
    return (m0c2 + E) / m0c2


def simulation_result_with_Cc(
    func, Cc, deltaE, eV, args=[], kwargs={}, npoints=7, deltaEconv=&#34;1/e&#34;
):
    &#34;&#34;&#34;
    Perform a simulation using function, taking into account chromatic aberration.

    Pass in the function that simulates the multislice result, it is assumed
    that defocus is a variable named &#39;df&#39; somewhere in the keyword argument
    list.

    Parameters
    ----------
    func : function
        Function that simulates the result of interest, ie. pyms.HRTEM. The
        defocus must be present in the keyword argument list as &#39;df&#39;
    Cc : float
        Chromatic aberration coefficient in Angstroms
    deltaE : float
        Energy spread in electron volts using 1/e measure of spread (to convert
        from FWHM divide by 1.655, and divide by sqrt(2) to convert from
        standard deviation )
    eV : float
        (Mean) beam energy in electron volts
    args : list, optional
        Arguments for the method function used to propagate probes to the exit
        surface
    kwargs : Dict, optional
        Keyword arguments for the method function used to propagate probes to
        the exit surface
    npoints : int,optional
        Number of integration points in the Cc numerical integration
    Returns
    -------
    average : dict or array_like
        The simulation requested but averaged over the different defocus values
        to account for chromatic aberration.
    &#34;&#34;&#34;
    # Check if a defocii has already been specified if not, assume that nominal
    # (mean) defocus is 0
    if &#34;df&#34; in kwargs.keys():
        nominal_df = kwargs[&#34;df&#34;]
    else:
        nominal_df = 0

    # Get defocii to integrate over
    defocii = Cc_integration_points(Cc, deltaE, eV, npoints, deltaEconv) + nominal_df
    ndf = len(defocii)

    # Initialise the average result to None
    average = None

    # Now integrate the function over those defocus values
    for df in defocii:
        kwargs[&#34;df&#34;] = df
        result = func(*args, **kwargs)

        # Assume that every function will either return a numpy array
        # (eg. pyms.HRTEM) or a list of numpy arrays (eg. pyms.STEM with both
        # conventional and 4D-STEM options) so average these results
        if isinstance(result, np.ndarray):
            if average is None:
                average = result / ndf
            else:
                average += result / ndf
        elif isinstance(result, dict):
            if average is None:
                average = copy.deepcopy(result)
                for key in average.keys():
                    if average[key] is not None:
                        average[key] /= ndf
            else:
                for key in average.keys():
                    if average[key] is not None:
                        average[key] += result[key] / ndf
        else:
            if average is None:
                average = [x / ndf for x in result]
            else:
                average = [x / ndf + y for x, y in zip(result, average)]
    return average


def Cc_integration_points(Cc, deltaE, eV, npoints=7, deltaEconv=&#34;1/e&#34;):
    &#34;&#34;&#34;
    Calculate the defocus integration points for simulating chromatic aberration.

    The integration points are selected by dividing the assumed gaussian defocus
    spread into npoints regions of equal probability, then finding the mean
    defocus in each of those regions.

    Parameters
    ----------
    Cc : float
        Chromatic aberration coefficient in Angstroms
    deltaE : float
        Energy spread in electron volts using 1/e measure of spread (to convert
        from FWHM divide by 1.655, and divide by sqrt(2) to convert from
        standard deviation )
    eV : float
        (Mean) beam energy in electron volts
    npoints : int,optional
        Number of integration points in the Cc numerical integration
    deltaEconv : float,optional
        The convention for deltaE, the energy spread, acceptable inputs are &#39;1/e&#39;
        the energy point that the probability density function drops to 1/e times
        its maximum value, &#39;std&#39; for standard deviation and &#39;FWHM&#39; for the full
        width at half maximum of the energy spread.
    Returns
    -------
    defocii : (`npoints`,) array_like
        The defocus integration points
    &#34;&#34;&#34;
    # Import the error function (integral of Gaussian) and inverse error function
    # from scipy&#39;s special functions library
    from scipy.special import erfinv, erf

    # First divide the gaussian pdf into npoints different regions of equal
    # &#34;area&#34;
    partitions = erfinv(2 * (np.arange(npoints - 1) + 1) / npoints - 1)

    # Now calculate the mean (expectation value) within each partition
    x = np.zeros(npoints)
    prefactor = 1 / (2 * np.sqrt(np.pi))
    x[0] = -prefactor * np.exp(-partitions[0] ** 2) / (1 + erf(partitions[0])) * 2
    x[1:-1] = (
        prefactor
        * (np.exp(-partitions[:-1] ** 2) - np.exp(-partitions[1:] ** 2))
        / (erf(partitions[1:]) - erf(partitions[:-1]))
        * 2
    )
    x[-1] = prefactor * np.exp(-partitions[-1] ** 2) / (1 - erf(partitions[-1])) * 2

    # Multiply by 1/e spread of defocus values
    return x * Cc * convert_deltaE(deltaE, deltaEconv) / eV


def Cc_defocus_spread(df, Cc, deltaE, eV, deltaEconv):
    &#34;&#34;&#34;
    Calculate the defocus spread for chromatic aberration.

    Evaluates the probability density function at defocus df for the defocus
    spread of a chromatic aberration (Cc) for (1/e) energy spread deltaE and
    beam energy eV in electron volts.


    Parameters
    ----------
    df : float or array_like
        defocus or defocii at which to evaluate the probability density function
    Cc : float
        Chromatic aberration coefficient in Angstroms
    deltaE : float
        Energy spread in electron volts using the measure given by deltaEconv
        (1/e measure of spread is default)
    eV : float
        (Mean) beam energy in electron volts
    deltaEconv : string,optional
        The convention for deltaE, the energy spread, acceptable inputs are &#39;1/e&#39;
        the energy point that the probability density function drops to 1/e times
        its maximum value, &#39;std&#39; for standard deviation and &#39;FWHM&#39; for the full
        width at half maximum of the energy spread
    Returns
    -------
    Cc_pdf : float or array_like
        the probability density function, will be the same size and shape as `df`
    &#34;&#34;&#34;
    # Calculate defocus spread
    df_spread = Cc * convert_deltaE(deltaE, deltaEconv) / eV

    # Evaluate probability density function for given defocus df
    return np.exp(-df * df / df_spread / df_spread) / np.sqrt(np.pi) / df_spread


def convert_deltaE(deltaE, deltaEconv):
    &#34;&#34;&#34;
    Convert the energy spread input to a 1/e spread.

    Parameters
    ----------
    deltaE : float
        Energy spread in electron volts using the measure given by deltaEconv
    deltaEconv : string
        The convention for deltaE, the energy spread, acceptable inputs are &#39;1/e&#39;
        the energy point that the probability density function drops to 1/e times
        its maximum value, &#39;std&#39; for standard deviation and &#39;FWHM&#39; for the full
        width at half maximum of the energy spread
    &#34;&#34;&#34;
    if deltaEconv == &#34;1/e&#34;:
        return deltaE
    elif deltaEconv == &#34;FWHM&#34;:
        return deltaE / 2 / np.sqrt(np.log(2))
    elif deltaEconv == &#34;std&#34;:
        return deltaE * np.sqrt(2)
    else:
        raise AttributeError(
            &#34;detlaEconv &#34;
            + deltaEconv
            + &#34; input not recognized, needs to be one of &#39;1/e&#39;, &#39;FWHM&#39; or &#39;std&#39;&#34;
        )


def convert_tilt_angles(tilt, tilt_units, rsize, eV, invA_out=False):
    &#34;&#34;&#34;
    Convert  tilt to pixel or inverse Angstroms units regardless of input units.

    Input units can be mrad, pixels or inverse Angstrom

    Parameters
    ----------
    tilt : array_like
        Tilt in units of mrad, pixels or inverse Angstrom
    tilt_units : string
        Units of specimen and beam tilt, can be &#39;mrad&#39;,&#39;pixels&#39; or &#39;invA&#39;
    rsize : (2,) array_like
        The size of the grid in Angstrom
    eV : float
        Probe energy in electron volts
    invA_out : bool
        Pass True if inverse Angstrom units are desired.
    &#34;&#34;&#34;
    # If units of the tilt are given in mrad, convert to inverse Angstrom
    if tilt_units == &#34;mrad&#34;:
        k = wavev(eV)
        tilt_ = np.asarray(tilt) * 1e-3 * k
    else:
        tilt_ = tilt

    # If inverse Angstroms are requested our work here is done
    if invA_out:
        return tilt_

    # Convert inverse Angstrom to pixel coordinates, this will be rounded
    # to the nearest pixel
    if tilt_units != &#34;pixels&#34;:
        tilt_ = np.round(tilt_ * rsize[:2]).astype(int)
    return tilt_</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyms.Probe.Cc_defocus_spread"><code class="name flex">
<span>def <span class="ident">Cc_defocus_spread</span></span>(<span>df, Cc, deltaE, eV, deltaEconv)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the defocus spread for chromatic aberration.</p>
<p>Evaluates the probability density function at defocus df for the defocus
spread of a chromatic aberration (Cc) for (1/e) energy spread deltaE and
beam energy eV in electron volts.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>defocus or defocii at which to evaluate the probability density function</dd>
<dt><strong><code>Cc</code></strong> :&ensp;<code>float</code></dt>
<dd>Chromatic aberration coefficient in Angstroms</dd>
<dt><strong><code>deltaE</code></strong> :&ensp;<code>float</code></dt>
<dd>Energy spread in electron volts using the measure given by deltaEconv
(1/e measure of spread is default)</dd>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>(Mean) beam energy in electron volts</dd>
<dt><strong><code>deltaEconv</code></strong> :&ensp;<code>string</code>,optional</dt>
<dd>The convention for deltaE, the energy spread, acceptable inputs are '1/e'
the energy point that the probability density function drops to 1/e times
its maximum value, 'std' for standard deviation and 'FWHM' for the full
width at half maximum of the energy spread</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Cc_pdf</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>the probability density function, will be the same size and shape as <code>df</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Cc_defocus_spread(df, Cc, deltaE, eV, deltaEconv):
    &#34;&#34;&#34;
    Calculate the defocus spread for chromatic aberration.

    Evaluates the probability density function at defocus df for the defocus
    spread of a chromatic aberration (Cc) for (1/e) energy spread deltaE and
    beam energy eV in electron volts.


    Parameters
    ----------
    df : float or array_like
        defocus or defocii at which to evaluate the probability density function
    Cc : float
        Chromatic aberration coefficient in Angstroms
    deltaE : float
        Energy spread in electron volts using the measure given by deltaEconv
        (1/e measure of spread is default)
    eV : float
        (Mean) beam energy in electron volts
    deltaEconv : string,optional
        The convention for deltaE, the energy spread, acceptable inputs are &#39;1/e&#39;
        the energy point that the probability density function drops to 1/e times
        its maximum value, &#39;std&#39; for standard deviation and &#39;FWHM&#39; for the full
        width at half maximum of the energy spread
    Returns
    -------
    Cc_pdf : float or array_like
        the probability density function, will be the same size and shape as `df`
    &#34;&#34;&#34;
    # Calculate defocus spread
    df_spread = Cc * convert_deltaE(deltaE, deltaEconv) / eV

    # Evaluate probability density function for given defocus df
    return np.exp(-df * df / df_spread / df_spread) / np.sqrt(np.pi) / df_spread</code></pre>
</details>
</dd>
<dt id="pyms.Probe.Cc_integration_points"><code class="name flex">
<span>def <span class="ident">Cc_integration_points</span></span>(<span>Cc, deltaE, eV, npoints=7, deltaEconv='1/e')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the defocus integration points for simulating chromatic aberration.</p>
<p>The integration points are selected by dividing the assumed gaussian defocus
spread into npoints regions of equal probability, then finding the mean
defocus in each of those regions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Cc</code></strong> :&ensp;<code>float</code></dt>
<dd>Chromatic aberration coefficient in Angstroms</dd>
<dt><strong><code>deltaE</code></strong> :&ensp;<code>float</code></dt>
<dd>Energy spread in electron volts using 1/e measure of spread (to convert
from FWHM divide by 1.655, and divide by sqrt(2) to convert from
standard deviation )</dd>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>(Mean) beam energy in electron volts</dd>
<dt><strong><code>npoints</code></strong> :&ensp;<code>int</code>,optional</dt>
<dd>Number of integration points in the Cc numerical integration</dd>
<dt><strong><code>deltaEconv</code></strong> :&ensp;<code>float</code>,optional</dt>
<dd>The convention for deltaE, the energy spread, acceptable inputs are '1/e'
the energy point that the probability density function drops to 1/e times
its maximum value, 'std' for standard deviation and 'FWHM' for the full
width at half maximum of the energy spread.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>defocii</code></strong> :&ensp;<code>(</code>npoints<code>,) array_like</code></dt>
<dd>The defocus integration points</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Cc_integration_points(Cc, deltaE, eV, npoints=7, deltaEconv=&#34;1/e&#34;):
    &#34;&#34;&#34;
    Calculate the defocus integration points for simulating chromatic aberration.

    The integration points are selected by dividing the assumed gaussian defocus
    spread into npoints regions of equal probability, then finding the mean
    defocus in each of those regions.

    Parameters
    ----------
    Cc : float
        Chromatic aberration coefficient in Angstroms
    deltaE : float
        Energy spread in electron volts using 1/e measure of spread (to convert
        from FWHM divide by 1.655, and divide by sqrt(2) to convert from
        standard deviation )
    eV : float
        (Mean) beam energy in electron volts
    npoints : int,optional
        Number of integration points in the Cc numerical integration
    deltaEconv : float,optional
        The convention for deltaE, the energy spread, acceptable inputs are &#39;1/e&#39;
        the energy point that the probability density function drops to 1/e times
        its maximum value, &#39;std&#39; for standard deviation and &#39;FWHM&#39; for the full
        width at half maximum of the energy spread.
    Returns
    -------
    defocii : (`npoints`,) array_like
        The defocus integration points
    &#34;&#34;&#34;
    # Import the error function (integral of Gaussian) and inverse error function
    # from scipy&#39;s special functions library
    from scipy.special import erfinv, erf

    # First divide the gaussian pdf into npoints different regions of equal
    # &#34;area&#34;
    partitions = erfinv(2 * (np.arange(npoints - 1) + 1) / npoints - 1)

    # Now calculate the mean (expectation value) within each partition
    x = np.zeros(npoints)
    prefactor = 1 / (2 * np.sqrt(np.pi))
    x[0] = -prefactor * np.exp(-partitions[0] ** 2) / (1 + erf(partitions[0])) * 2
    x[1:-1] = (
        prefactor
        * (np.exp(-partitions[:-1] ** 2) - np.exp(-partitions[1:] ** 2))
        / (erf(partitions[1:]) - erf(partitions[:-1]))
        * 2
    )
    x[-1] = prefactor * np.exp(-partitions[-1] ** 2) / (1 - erf(partitions[-1])) * 2

    # Multiply by 1/e spread of defocus values
    return x * Cc * convert_deltaE(deltaE, deltaEconv) / eV</code></pre>
</details>
</dd>
<dt id="pyms.Probe.aberration_starter_pack"><code class="name flex">
<span>def <span class="ident">aberration_starter_pack</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the set of aberrations up to fifth order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aberration_starter_pack():
    &#34;&#34;&#34;Create the set of aberrations up to fifth order.&#34;&#34;&#34;
    aberrations = []
    aberrations.append(aberration(&#34;C10&#34;, &#34;C1&#34;, &#34;Defocus          &#34;, 0.0, 0.0, 1, 0))
    aberrations.append(aberration(&#34;C12&#34;, &#34;A1&#34;, &#34;2-Fold astig.    &#34;, 0.0, 0.0, 1, 2))
    aberrations.append(aberration(&#34;C23&#34;, &#34;A2&#34;, &#34;3-Fold astig.    &#34;, 0.0, 0.0, 2, 3))
    aberrations.append(aberration(&#34;C21&#34;, &#34;B2&#34;, &#34;Axial coma       &#34;, 0.0, 0.0, 2, 1))
    aberrations.append(aberration(&#34;C30&#34;, &#34;C3&#34;, &#34;3rd order spher. &#34;, 0.0, 0.0, 3, 0))
    aberrations.append(aberration(&#34;C34&#34;, &#34;A3&#34;, &#34;4-Fold astig.    &#34;, 0.0, 0.0, 3, 4))
    aberrations.append(aberration(&#34;C32&#34;, &#34;S3&#34;, &#34;Axial star aber. &#34;, 0.0, 0.0, 3, 2))
    aberrations.append(aberration(&#34;C45&#34;, &#34;A4&#34;, &#34;5-Fold astig.    &#34;, 0.0, 0.0, 4, 5))
    aberrations.append(aberration(&#34;C43&#34;, &#34;D4&#34;, &#34;3-Lobe aberr.    &#34;, 0.0, 0.0, 4, 3))
    aberrations.append(aberration(&#34;C41&#34;, &#34;B4&#34;, &#34;4th order coma   &#34;, 0.0, 0.0, 4, 1))
    aberrations.append(aberration(&#34;C50&#34;, &#34;C5&#34;, &#34;5th order spher. &#34;, 0.0, 0.0, 5, 0))
    aberrations.append(aberration(&#34;C56&#34;, &#34;A5&#34;, &#34;6-Fold astig.    &#34;, 0.0, 0.0, 5, 6))
    aberrations.append(aberration(&#34;C52&#34;, &#34;S5&#34;, &#34;5th order star   &#34;, 0.0, 0.0, 5, 2))
    aberrations.append(aberration(&#34;C54&#34;, &#34;R5&#34;, &#34;5th order rosette&#34;, 0.0, 0.0, 5, 4))
    return aberrations</code></pre>
</details>
</dd>
<dt id="pyms.Probe.chi"><code class="name flex">
<span>def <span class="ident">chi</span></span>(<span>q, qphi, lam, df=0.0, aberrations=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the aberration function, chi.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>q</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Reciprocal space extent (Inverse angstroms).</dd>
<dt><strong><code>qphi</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Azimuth of grid in radians</dd>
<dt><strong><code>lam</code></strong> :&ensp;<code>float</code></dt>
<dd>Wavelength of electron (Inverse angstroms).</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Defocus in Angstrom</dd>
<dt><strong><code>aberrations</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>A list containing a set of the class aberration, pass an empty list for
an unaberrated contrast transfer function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chi</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>The aberration function, will be the same shape as <code>q</code>. This is used to
calculate the probe wave function in reciprocal space.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chi(q, qphi, lam, df=0.0, aberrations=[]):
    r&#34;&#34;&#34;
    Calculate the aberration function, chi.

    Parameters
    ----------
    q : float or array_like
        Reciprocal space extent (Inverse angstroms).
    qphi : float or array_like
        Azimuth of grid in radians
    lam : float
        Wavelength of electron (Inverse angstroms).
    df : float, optional
        Defocus in Angstrom
    aberrations : list, optional
        A list containing a set of the class aberration, pass an empty list for
        an unaberrated contrast transfer function.
    Returns
    -------
    chi : float or array_like
        The aberration function, will be the same shape as `q`. This is used to
        calculate the probe wave function in reciprocal space.
    &#34;&#34;&#34;
    qlam = q * lam
    chi_ = qlam ** 2 / 2 * df
    for ab in aberrations:
        chi_ += (
            qlam ** (ab.n + 1)
            * float(ab.amplitude)
            / (ab.n + 1)
            * np.cos(ab.m * (qphi - float(ab.angle)))
        )
    return 2 * np.pi * chi_ / lam</code></pre>
</details>
</dd>
<dt id="pyms.Probe.convert_deltaE"><code class="name flex">
<span>def <span class="ident">convert_deltaE</span></span>(<span>deltaE, deltaEconv)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the energy spread input to a 1/e spread.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>deltaE</code></strong> :&ensp;<code>float</code></dt>
<dd>Energy spread in electron volts using the measure given by deltaEconv</dd>
<dt><strong><code>deltaEconv</code></strong> :&ensp;<code>string</code></dt>
<dd>The convention for deltaE, the energy spread, acceptable inputs are '1/e'
the energy point that the probability density function drops to 1/e times
its maximum value, 'std' for standard deviation and 'FWHM' for the full
width at half maximum of the energy spread</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_deltaE(deltaE, deltaEconv):
    &#34;&#34;&#34;
    Convert the energy spread input to a 1/e spread.

    Parameters
    ----------
    deltaE : float
        Energy spread in electron volts using the measure given by deltaEconv
    deltaEconv : string
        The convention for deltaE, the energy spread, acceptable inputs are &#39;1/e&#39;
        the energy point that the probability density function drops to 1/e times
        its maximum value, &#39;std&#39; for standard deviation and &#39;FWHM&#39; for the full
        width at half maximum of the energy spread
    &#34;&#34;&#34;
    if deltaEconv == &#34;1/e&#34;:
        return deltaE
    elif deltaEconv == &#34;FWHM&#34;:
        return deltaE / 2 / np.sqrt(np.log(2))
    elif deltaEconv == &#34;std&#34;:
        return deltaE * np.sqrt(2)
    else:
        raise AttributeError(
            &#34;detlaEconv &#34;
            + deltaEconv
            + &#34; input not recognized, needs to be one of &#39;1/e&#39;, &#39;FWHM&#39; or &#39;std&#39;&#34;
        )</code></pre>
</details>
</dd>
<dt id="pyms.Probe.convert_tilt_angles"><code class="name flex">
<span>def <span class="ident">convert_tilt_angles</span></span>(<span>tilt, tilt_units, rsize, eV, invA_out=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert
tilt to pixel or inverse Angstroms units regardless of input units.</p>
<p>Input units can be mrad, pixels or inverse Angstrom</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tilt</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Tilt in units of mrad, pixels or inverse Angstrom</dd>
<dt><strong><code>tilt_units</code></strong> :&ensp;<code>string</code></dt>
<dd>Units of specimen and beam tilt, can be 'mrad','pixels' or 'invA'</dd>
<dt><strong><code>rsize</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>The size of the grid in Angstrom</dd>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>Probe energy in electron volts</dd>
<dt><strong><code>invA_out</code></strong> :&ensp;<code>bool</code></dt>
<dd>Pass True if inverse Angstrom units are desired.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_tilt_angles(tilt, tilt_units, rsize, eV, invA_out=False):
    &#34;&#34;&#34;
    Convert  tilt to pixel or inverse Angstroms units regardless of input units.

    Input units can be mrad, pixels or inverse Angstrom

    Parameters
    ----------
    tilt : array_like
        Tilt in units of mrad, pixels or inverse Angstrom
    tilt_units : string
        Units of specimen and beam tilt, can be &#39;mrad&#39;,&#39;pixels&#39; or &#39;invA&#39;
    rsize : (2,) array_like
        The size of the grid in Angstrom
    eV : float
        Probe energy in electron volts
    invA_out : bool
        Pass True if inverse Angstrom units are desired.
    &#34;&#34;&#34;
    # If units of the tilt are given in mrad, convert to inverse Angstrom
    if tilt_units == &#34;mrad&#34;:
        k = wavev(eV)
        tilt_ = np.asarray(tilt) * 1e-3 * k
    else:
        tilt_ = tilt

    # If inverse Angstroms are requested our work here is done
    if invA_out:
        return tilt_

    # Convert inverse Angstrom to pixel coordinates, this will be rounded
    # to the nearest pixel
    if tilt_units != &#34;pixels&#34;:
        tilt_ = np.round(tilt_ * rsize[:2]).astype(int)
    return tilt_</code></pre>
</details>
</dd>
<dt id="pyms.Probe.depth_of_field"><code class="name flex">
<span>def <span class="ident">depth_of_field</span></span>(<span>eV, alpha)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the probe depth of field (z-resolution) for a probe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>Probe accelerating voltage in electron volts</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>Probe forming semi-angle in mrad</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dof</code></strong> :&ensp;<code>float</code></dt>
<dd>The probe full-width-at-half-maximum (FWHM) depth of field</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def depth_of_field(eV, alpha):
    &#34;&#34;&#34;
    Calculate the probe depth of field (z-resolution) for a probe.

    Parameters
    ----------
    eV : float
        Probe accelerating voltage in electron volts
    alpha : float
        Probe forming semi-angle in mrad
    Returns
    -------
    dof : float
        The probe full-width-at-half-maximum (FWHM) depth of field
    &#34;&#34;&#34;
    return 1.77 / wavev(eV) / alpha / alpha * 1e6</code></pre>
</details>
</dd>
<dt id="pyms.Probe.focused_probe"><code class="name flex">
<span>def <span class="ident">focused_probe</span></span>(<span>gridshape, rsize, eV, app, beam_tilt=[0, 0], aperture_shift=[0, 0], tilt_units='mrad', df=0, aberrations=[], q=None, app_units='mrad', qspace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a focused electron probe wave function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gridshape</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>The pixel size of the grid</dd>
<dt><strong><code>rsize</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>The size of the grid in Angstrom</dd>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>The energy of the probe electrons in electron volts</dd>
<dt><strong><code>app</code></strong> :&ensp;<code>float</code></dt>
<dd>The probe-forming apperture in units specified by app_units, pass None
if no probe forming aperture is to be used</dd>
<dt><strong><code>beam_tilt</code></strong> :&ensp;<code>array_like</code>, optional</dt>
<dd>Allows the user to simulate a (small &lt; 50 mrad) beam tilt. To maintain
periodicity of the wave function at the boundaries this tilt is rounded
to the nearest pixel value.</dd>
<dt><strong><code>aperture_shift</code></strong> :&ensp;<code>array_like</code>, optional</dt>
<dd>Allows the user to simulate a (small &lt; 50 mrad) aperture shift. To
maintain periodicity of the wave function at the boundaries this tilt
is rounded to the nearest pixel value.</dd>
<dt><strong><code>tilt_units</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Units of beam tilt and aperture shift, can be 'mrad','pixels' or 'invA'</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Probe defocus in A, a negative value indicate overfocus</dd>
<dt><strong><code>aberrations</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>A list of of probe aberrations of class pyms.Probe.aberration, pass an
empty list for an un-aberrated probe</dd>
<dt><strong><code>app_units</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>The units of the aperture size ("invA", "pixels" or "mrad")</dd>
<dt><strong><code>qspace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True return the probe in reciprocal space</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>probe</code></strong> :&ensp;<code>complex (Y,X) np.ndarray</code></dt>
<dd>The requested electron probe wave function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focused_probe(
    gridshape,
    rsize,
    eV,
    app,
    beam_tilt=[0, 0],
    aperture_shift=[0, 0],
    tilt_units=&#34;mrad&#34;,
    df=0,
    aberrations=[],
    q=None,
    app_units=&#34;mrad&#34;,
    qspace=False,
):
    &#34;&#34;&#34;
    Make a focused electron probe wave function.

    Parameters
    ---------
    gridshape : (2,) array_like
        The pixel size of the grid
    rsize : (2,) array_like
        The size of the grid in Angstrom
    eV : float
        The energy of the probe electrons in electron volts
    app : float
        The probe-forming apperture in units specified by app_units, pass None
        if no probe forming aperture is to be used
    beam_tilt : array_like, optional
        Allows the user to simulate a (small &lt; 50 mrad) beam tilt. To maintain
        periodicity of the wave function at the boundaries this tilt is rounded
        to the nearest pixel value.
    aperture_shift : array_like, optional
        Allows the user to simulate a (small &lt; 50 mrad) aperture shift. To
        maintain periodicity of the wave function at the boundaries this tilt
        is rounded to the nearest pixel value.
    tilt_units : string, optional
        Units of beam tilt and aperture shift, can be &#39;mrad&#39;,&#39;pixels&#39; or &#39;invA&#39;
    df : float, optional
        Probe defocus in A, a negative value indicate overfocus
    aberrations : list, optional
        A list of of probe aberrations of class pyms.Probe.aberration, pass an
        empty list for an un-aberrated probe
    app_units : string, optional
        The units of the aperture size (&#34;invA&#34;, &#34;pixels&#34; or &#34;mrad&#34;)
    qspace : bool, optional
        If True return the probe in reciprocal space
    Returns
    -------
    probe : complex (Y,X) np.ndarray
        The requested electron probe wave function
    &#34;&#34;&#34;
    probe = make_contrast_transfer_function(
        gridshape,
        rsize,
        eV,
        app,
        beam_tilt,
        aperture_shift,
        tilt_units,
        df,
        aberrations,
        q,
        app_units,
    )

    # Normalize the STEM probe so that its sum-squared intensity is unity
    probe *= np.sqrt(np.prod(gridshape)) / np.sqrt(np.sum(np.square(np.abs(probe))))

    # Return real or diffraction space probe depending on user preference
    if not qspace:
        return np.fft.ifft2(probe)
    return probe</code></pre>
</details>
</dd>
<dt id="pyms.Probe.make_contrast_transfer_function"><code class="name flex">
<span>def <span class="ident">make_contrast_transfer_function</span></span>(<span>pix_dim, real_dim, eV, app, optic_axis=[0, 0], aperture_shift=[0, 0], tilt_units='mrad', df=0, aberrations=[], q=None, app_units='mrad')</span>
</code></dt>
<dd>
<div class="desc"><p>Make an electron lens contrast transfer function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pix_dim</code></strong> :&ensp;<code>(2,) int array_like</code></dt>
<dd>The pixel size of the grid</dd>
<dt><strong><code>real_dim</code></strong> :&ensp;<code>(2,) float array_like</code></dt>
<dd>The size of the grid in Angstrom</dd>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>The energy of the probe electrons in eV</dd>
<dt><strong><code>app</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>The aperture in units specified by app_units, pass <code>app</code> = None for
no aperture</dd>
<dt><strong><code>optic_axis</code></strong> :&ensp;<code>(2,) array_like</code>, optional</dt>
<dd>allows the user to specify a different optic axis in units specified by
<code>tilt_units</code></dd>
<dt><strong><code>aperture_shift</code></strong> :&ensp;<code>(2,) array_like</code>, optional</dt>
<dd>Shift of the objective aperture relative to the center of the array</dd>
<dt><strong><code>tilt_units</code></strong> :&ensp;<code>string</code></dt>
<dd>Units of the <code>optic_axis</code> or <code>aperture_shift</code> values, default is mrad</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>float</code></dt>
<dd>Probe defocus in A, a negative value indicate overfocus</dd>
<dt><strong><code>aberrations</code></strong> :&ensp;<code>array_like</code> of <code><a title="pyms.Probe.aberration" href="#pyms.Probe.aberration">aberration</a> objects</code></dt>
<dd>List containing instances of class aberration</dd>
<dt>q :</dt>
<dt>Precomputed reciprocal space array, allows the user to reduce</dt>
<dt>computation time somewhat</dt>
<dt><strong><code>app_units</code></strong> :&ensp;<code>string</code></dt>
<dd>The units of <code>app</code> (A^-1 or mrad)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ctf</code></strong> :&ensp;<code>array_like</code></dt>
<dd>The lens contrast transfer function in reciprocal space</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_contrast_transfer_function(
    pix_dim,
    real_dim,
    eV,
    app,
    optic_axis=[0, 0],
    aperture_shift=[0, 0],
    tilt_units=&#34;mrad&#34;,
    df=0,
    aberrations=[],
    q=None,
    app_units=&#34;mrad&#34;,
):
    &#34;&#34;&#34;
    Make an electron lens contrast transfer function.

    Parameters
    ---------
    pix_dim : (2,) int array_like
        The pixel size of the grid
    real_dim : (2,) float array_like
        The size of the grid in Angstrom
    eV : float
        The energy of the probe electrons in eV
    app : float or None
        The aperture in units specified by app_units, pass `app` = None for
        no aperture
    optic_axis : (2,) array_like, optional
        allows the user to specify a different optic axis in units specified by
        `tilt_units`
    aperture_shift : (2,) array_like, optional
        Shift of the objective aperture relative to the center of the array
    tilt_units : string
        Units of the `optic_axis` or `aperture_shift` values, default is mrad
    df : float
        Probe defocus in A, a negative value indicate overfocus
    aberrations : array_like of aberration objects
        List containing instances of class aberration
    q :
        Precomputed reciprocal space array, allows the user to reduce
        computation time somewhat
    app_units : string
        The units of `app` (A^-1 or mrad)
    Returns
    -------
    ctf : array_like
        The lens contrast transfer function in reciprocal space
    &#34;&#34;&#34;
    # Make reciprocal space array
    if q is None:
        q = q_space_array(pix_dim, real_dim[:2])

    # Get  electron wave number (inverse of wavelength)
    k = wavev(eV)

    # Convert tilts to units of inverse Angstrom
    optic_axis_ = convert_tilt_angles(
        optic_axis, tilt_units, real_dim, eV, invA_out=True
    )
    aperture_shift_ = convert_tilt_angles(
        aperture_shift, tilt_units, real_dim, eV, invA_out=True
    )

    if app is None:
        app_ = np.amax(np.abs(q))
    else:
        # Get aperture size in units of inverse Angstrom
        app_ = convert_tilt_angles(app, app_units, real_dim, eV, invA_out=True)

    # Initialize the array to contain the CTF
    CTF = np.zeros(pix_dim, dtype=np.complex)

    # Calculate the magnitude of the reciprocal lattice grid
    # qarray1 accounts for a shift of the optic axis
    qarray1 = np.sqrt(
        np.square(q[0] - optic_axis_[0]) + np.square(q[1] - optic_axis_[1])
    )

    # qarray2 accounts for a shift of both the optic axis and the aperture
    qarray2 = np.square(q[0] - optic_axis_[0] - aperture_shift_[0]) + np.square(
        q[1] - optic_axis_[1] - aperture_shift_[1]
    )

    # Calculate azimuth of reciprocal space array in case it is required for
    # aberrations
    qphi = np.arctan2(q[0] - optic_axis_[0], q[1] - optic_axis_[1])

    # Only calculate CTF for region within the aperture
    mask = qarray2 &lt;= app_ ** 2
    CTF[mask] = np.exp(-1j * chi(qarray1[mask], qphi[mask], 1.0 / k, df, aberrations))
    return CTF</code></pre>
</details>
</dd>
<dt id="pyms.Probe.plane_wave_illumination"><code class="name flex">
<span>def <span class="ident">plane_wave_illumination</span></span>(<span>gridshape, gridsize, eV, tilt=[0, 0], tilt_units='mrad', qspace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate plane wave illumination for input to multislice.</p>
<p>The wave function will be normalized such that sum of intensity is unity in
real space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gridshape</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Pixel dimensions of the 2D grid</dd>
<dt><strong><code>gridsize</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Size of the grid in real space</dd>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>Probe energy in electron volts (irrelevant for untilted illumination)</dd>
<dt><strong><code>tilt</code></strong> :&ensp;<code>array_like</code>, optional</dt>
<dd>Allows the user to simulate a (small &lt; 50 mrad) beam tilt, To maintain
periodicity of the wave function at the boundaries this tilt is rounded
to the nearest pixel value.</dd>
<dt><strong><code>tilt_units</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Units of beam tilt, can be 'mrad','pixels' or 'invA'</dd>
<dt><strong><code>qspace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Pass qspace = True to get the probe in momentum (q) space</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>illum</code></strong> :&ensp;<code>np.ndarray (Y,X)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plane_wave_illumination(
    gridshape, gridsize, eV, tilt=[0, 0], tilt_units=&#34;mrad&#34;, qspace=False
):
    &#34;&#34;&#34;
    Generate plane wave illumination for input to multislice.

    The wave function will be normalized such that sum of intensity is unity in
    real space.

    Parameters
    ----------
    gridshape : (2,) array_like
        Pixel dimensions of the 2D grid
    gridsize : (2,) array_like
        Size of the grid in real space
    eV : float
        Probe energy in electron volts (irrelevant for untilted illumination)
    tilt : array_like, optional
        Allows the user to simulate a (small &lt; 50 mrad) beam tilt, To maintain
        periodicity of the wave function at the boundaries this tilt is rounded
        to the nearest pixel value.
    tilt_units : string, optional
        Units of beam tilt, can be &#39;mrad&#39;,&#39;pixels&#39; or &#39;invA&#39;
    qspace : bool, optional
        Pass qspace = True to get the probe in momentum (q) space
    Returns
    ------
    illum : np.ndarray (Y,X)
    &#34;&#34;&#34;
    # Initialize array that contains wave function
    illum = np.zeros(gridshape, dtype=np.complex)

    # Convert tilt to units of pixels
    tilt_ = convert_tilt_angles(tilt, tilt_units, gridsize, eV)

    # Case of an untilted plane wave (phase is zero everywhere)
    if tilt[0] == 0 and tilt[1] == 0:
        illum[:, :] = 1 / np.sqrt(np.product(gridshape))

        if qspace:
            return np.fft.fft2(illum)
        else:
            return illum

    # Set the value of wavefunction amplitude such that after inverse Fourier
    # transform (and resulting division by the total number of pixels) the sum
    # of intensity will be 1
    illum[tilt_[0], tilt_[1]] = np.sqrt(np.product(gridshape))

    # Return wave function in real space
    if qspace:
        return illum
    else:
        return np.fft.ifft2(illum)</code></pre>
</details>
</dd>
<dt id="pyms.Probe.relativistic_mass_correction"><code class="name flex">
<span>def <span class="ident">relativistic_mass_correction</span></span>(<span>E)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate the relativistic mass correction for electron with energy E in eV.</p>
<p>See Eq. (2.2) in Kirkland's Advanced Computing in electron microscopy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relativistic_mass_correction(E):
    &#34;&#34;&#34;
    Evaluate the relativistic mass correction for electron with energy E in eV.

    See Eq. (2.2) in Kirkland&#39;s Advanced Computing in electron microscopy.
    &#34;&#34;&#34;
    # Electron rest mass in eV
    m0c2 = 5.109989461e5
    return (m0c2 + E) / m0c2</code></pre>
</details>
</dd>
<dt id="pyms.Probe.simulation_result_with_Cc"><code class="name flex">
<span>def <span class="ident">simulation_result_with_Cc</span></span>(<span>func, Cc, deltaE, eV, args=[], kwargs={}, npoints=7, deltaEconv='1/e')</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a simulation using function, taking into account chromatic aberration.</p>
<p>Pass in the function that simulates the multislice result, it is assumed
that defocus is a variable named 'df' somewhere in the keyword argument
list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>function</code></dt>
<dd>Function that simulates the result of interest, ie. pyms.HRTEM. The
defocus must be present in the keyword argument list as 'df'</dd>
<dt><strong><code>Cc</code></strong> :&ensp;<code>float</code></dt>
<dd>Chromatic aberration coefficient in Angstroms</dd>
<dt><strong><code>deltaE</code></strong> :&ensp;<code>float</code></dt>
<dd>Energy spread in electron volts using 1/e measure of spread (to convert
from FWHM divide by 1.655, and divide by sqrt(2) to convert from
standard deviation )</dd>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>(Mean) beam energy in electron volts</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Arguments for the method function used to propagate probes to the exit
surface</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>Dict</code>, optional</dt>
<dd>Keyword arguments for the method function used to propagate probes to
the exit surface</dd>
<dt><strong><code>npoints</code></strong> :&ensp;<code>int</code>,optional</dt>
<dd>Number of integration points in the Cc numerical integration</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>average</code></strong> :&ensp;<code>dict</code> or <code>array_like</code></dt>
<dd>The simulation requested but averaged over the different defocus values
to account for chromatic aberration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulation_result_with_Cc(
    func, Cc, deltaE, eV, args=[], kwargs={}, npoints=7, deltaEconv=&#34;1/e&#34;
):
    &#34;&#34;&#34;
    Perform a simulation using function, taking into account chromatic aberration.

    Pass in the function that simulates the multislice result, it is assumed
    that defocus is a variable named &#39;df&#39; somewhere in the keyword argument
    list.

    Parameters
    ----------
    func : function
        Function that simulates the result of interest, ie. pyms.HRTEM. The
        defocus must be present in the keyword argument list as &#39;df&#39;
    Cc : float
        Chromatic aberration coefficient in Angstroms
    deltaE : float
        Energy spread in electron volts using 1/e measure of spread (to convert
        from FWHM divide by 1.655, and divide by sqrt(2) to convert from
        standard deviation )
    eV : float
        (Mean) beam energy in electron volts
    args : list, optional
        Arguments for the method function used to propagate probes to the exit
        surface
    kwargs : Dict, optional
        Keyword arguments for the method function used to propagate probes to
        the exit surface
    npoints : int,optional
        Number of integration points in the Cc numerical integration
    Returns
    -------
    average : dict or array_like
        The simulation requested but averaged over the different defocus values
        to account for chromatic aberration.
    &#34;&#34;&#34;
    # Check if a defocii has already been specified if not, assume that nominal
    # (mean) defocus is 0
    if &#34;df&#34; in kwargs.keys():
        nominal_df = kwargs[&#34;df&#34;]
    else:
        nominal_df = 0

    # Get defocii to integrate over
    defocii = Cc_integration_points(Cc, deltaE, eV, npoints, deltaEconv) + nominal_df
    ndf = len(defocii)

    # Initialise the average result to None
    average = None

    # Now integrate the function over those defocus values
    for df in defocii:
        kwargs[&#34;df&#34;] = df
        result = func(*args, **kwargs)

        # Assume that every function will either return a numpy array
        # (eg. pyms.HRTEM) or a list of numpy arrays (eg. pyms.STEM with both
        # conventional and 4D-STEM options) so average these results
        if isinstance(result, np.ndarray):
            if average is None:
                average = result / ndf
            else:
                average += result / ndf
        elif isinstance(result, dict):
            if average is None:
                average = copy.deepcopy(result)
                for key in average.keys():
                    if average[key] is not None:
                        average[key] /= ndf
            else:
                for key in average.keys():
                    if average[key] is not None:
                        average[key] += result[key] / ndf
        else:
            if average is None:
                average = [x / ndf for x in result]
            else:
                average = [x / ndf + y for x, y in zip(result, average)]
    return average</code></pre>
</details>
</dd>
<dt id="pyms.Probe.wavev"><code class="name flex">
<span>def <span class="ident">wavev</span></span>(<span>E)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate the relativistically corrected wavenumber of an electron with energy E.</p>
<p>Energy E must be in electron-volts, see Eq. (2.5) in Kirkland's Advanced
Computing in electron microscopy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wavev(E):
    &#34;&#34;&#34;
    Evaluate the relativistically corrected wavenumber of an electron with energy E.

    Energy E must be in electron-volts, see Eq. (2.5) in Kirkland&#39;s Advanced
    Computing in electron microscopy
    &#34;&#34;&#34;
    # Planck&#39;s constant times speed of light in eV Angstrom
    hc = 1.23984193e4
    # Electron rest mass in eV
    m0c2 = 5.109989461e5
    return np.sqrt(E * (E + 2 * m0c2)) / hc</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyms.Probe.aberration"><code class="flex name class">
<span>class <span class="ident">aberration</span></span>
<span>(</span><span>Krivanek, Haider, Description, amplitude, angle, n, m)</span>
</code></dt>
<dd>
<div class="desc"><p>A class describing electron lens aberrations.</p>
<p>Intialize the lens aberration object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Krivanek</code></strong> :&ensp;<code>str</code></dt>
<dd>A string describing the aberration coefficient in Krivanek notation
(C_mn)</dd>
<dt><strong><code>Haider</code></strong> :&ensp;<code>str</code></dt>
<dd>A string describing the aberration coefficient in Haider notation
(ie. A1, A2, B2)</dd>
<dt><strong><code>Description</code></strong> :&ensp;<code>str</code></dt>
<dd>A string describing the colloqiual name of the aberration ie. 2-fold
astig.</dd>
<dt><strong><code>amplitude</code></strong> :&ensp;<code>float</code></dt>
<dd>The amplitude of the aberration in Angstrom</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>The angle of the aberration in radians</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The principle aberration order</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>int</code></dt>
<dd>The rotational order of the aberration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class aberration:
    &#34;&#34;&#34;A class describing electron lens aberrations.&#34;&#34;&#34;

    def __init__(self, Krivanek, Haider, Description, amplitude, angle, n, m):
        &#34;&#34;&#34;
        Intialize the lens aberration object.

        Parameters
        ----------
        Krivanek : str
            A string describing the aberration coefficient in Krivanek notation
            (C_mn)
        Haider : str
            A string describing the aberration coefficient in Haider notation
            (ie. A1, A2, B2)
        Description : str
            A string describing the colloqiual name of the aberration ie. 2-fold
            astig.
        amplitude : float
            The amplitude of the aberration in Angstrom
        angle : float
            The angle of the aberration in radians
        n : int
            The principle aberration order
        m : int
            The rotational order of the aberration.
        &#34;&#34;&#34;
        self.Krivanek = Krivanek
        self.Haider = Haider
        self.Description = Description
        self.amplitude = amplitude
        self.m = m
        self.n = n
        if m &gt; 0:
            self.angle = angle
        else:
            self.angle = 0

    def __str__(self):
        &#34;&#34;&#34;Return a string describing the aberration.&#34;&#34;&#34;
        if self.m &gt; 0:
            return (
                &#34;{0:17s} ({1:2s}) -- {2:3s} = {3:9.2e} \u00E5 \u03B8 = &#34;
                + &#34;{4:4d}\u00B0 &#34;
            ).format(
                self.Description,
                self.Haider,
                self.Krivanek,
                self.amplitude,
                int(np.rad2deg(self.angle)),
            )
        else:
            return &#34; {0:17s} ({1:2s}) -- {2:3s} = {3:9.2e} \u00E5&#34;.format(
                self.Description, self.Haider, self.Krivanek, self.amplitude
            )</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyms" href="index.html">pyms</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyms.Probe.Cc_defocus_spread" href="#pyms.Probe.Cc_defocus_spread">Cc_defocus_spread</a></code></li>
<li><code><a title="pyms.Probe.Cc_integration_points" href="#pyms.Probe.Cc_integration_points">Cc_integration_points</a></code></li>
<li><code><a title="pyms.Probe.aberration_starter_pack" href="#pyms.Probe.aberration_starter_pack">aberration_starter_pack</a></code></li>
<li><code><a title="pyms.Probe.chi" href="#pyms.Probe.chi">chi</a></code></li>
<li><code><a title="pyms.Probe.convert_deltaE" href="#pyms.Probe.convert_deltaE">convert_deltaE</a></code></li>
<li><code><a title="pyms.Probe.convert_tilt_angles" href="#pyms.Probe.convert_tilt_angles">convert_tilt_angles</a></code></li>
<li><code><a title="pyms.Probe.depth_of_field" href="#pyms.Probe.depth_of_field">depth_of_field</a></code></li>
<li><code><a title="pyms.Probe.focused_probe" href="#pyms.Probe.focused_probe">focused_probe</a></code></li>
<li><code><a title="pyms.Probe.make_contrast_transfer_function" href="#pyms.Probe.make_contrast_transfer_function">make_contrast_transfer_function</a></code></li>
<li><code><a title="pyms.Probe.plane_wave_illumination" href="#pyms.Probe.plane_wave_illumination">plane_wave_illumination</a></code></li>
<li><code><a title="pyms.Probe.relativistic_mass_correction" href="#pyms.Probe.relativistic_mass_correction">relativistic_mass_correction</a></code></li>
<li><code><a title="pyms.Probe.simulation_result_with_Cc" href="#pyms.Probe.simulation_result_with_Cc">simulation_result_with_Cc</a></code></li>
<li><code><a title="pyms.Probe.wavev" href="#pyms.Probe.wavev">wavev</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyms.Probe.aberration" href="#pyms.Probe.aberration">aberration</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>