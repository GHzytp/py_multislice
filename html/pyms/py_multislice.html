<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>pyms.py_multislice API documentation</title>
<meta name="description" content="Module containing functions for core multislice and PRISM algorithms." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyms.py_multislice</code></h1>
</header>
<section id="section-intro">
<p>Module containing functions for core multislice and PRISM algorithms.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Module containing functions for core multislice and PRISM algorithms.&#34;&#34;&#34;
import matplotlib.pyplot as plt
import numpy as np
import torch
from tqdm import tqdm
from .Probe import wavev, focused_probe
from .utils.numpy_utils import (
    ensure_array,
    bandwidth_limit_array,
    q_space_array,
    fourier_interpolate_2d,
    crop,
)
from .utils.torch_utils import (
    roll_n,
    cx_from_numpy,
    cx_to_numpy,
    complex_matmul,
    complex_mul,
    fourier_shift_array,
    amplitude,
    get_device,
    ensure_torch_array,
    crop_to_bandwidth_limit_torch,
    size_of_bandwidth_limited_array,
    fourier_interpolate_2d_torch,
    crop_window_to_flattened_indices_torch,
    crop_window_to_periodic_indices,
    crop_torch,
)


def tqdm_handler(showProgress):
    &#34;&#34;&#34;Handle showProgress boolean or string input for the tqdm progress bar.&#34;&#34;&#34;
    if isinstance(showProgress, str):
        if showProgress == &#34;notebook&#34;:
            from tqdm import tqdm_notebook as tqdm
        tdisable = False
    elif isinstance(showProgress, bool):
        tdisable = not showProgress
        from tqdm import tqdm
    return tdisable, tqdm


def thickness_to_slices(
    thicknesses, slice_thickness, subslicing=False, subslices=[1.0]
):
    &#34;&#34;&#34;Convert thickness in Angstroms to number of multislice slices.&#34;&#34;&#34;
    t = np.asarray(ensure_array(thicknesses))
    if subslicing:
        # Work out how many slice of the structure is closest to the desired
        # output thicknesses
        m = len(subslices)
        nslices = (t // slice_thickness).astype(np.int) * m
        from scipy.spatial.distance import cdist

        # Work out which subslices of the structure
        remainder = (t % slice_thickness) / slice_thickness
        n = len(remainder)
        dist = cdist(
            remainder.reshape((n, 1)),
            np.concatenate(([0], subslices[:-1])).reshape((m, 1)),
        )
        z = [0] + (nslices + np.asarray([i for i in np.argmin(dist, axis=1)])).tolist()
        return [np.arange(z[i], z[i + 1]) for i in range(len(z) - 1)]
    else:
        return np.ceil(t / slice_thickness).astype(np.int)


def make_propagators(
    gridshape,
    gridsize,
    eV,
    subslices=[1.0],
    tilt=[0, 0],
    tilt_units=&#34;mrad&#34;,
    bandwidth_limit=2 / 3,
):
    &#34;&#34;&#34;
    Make the Fresnel freespace propagators for a multislice simulation.

    Parameters
    ----------
    gridshape : (2,) array_like
        Pixel dimensions of the 2D grid
    gridsize : (3,) array_like
        Size of the grid in real space (first two dimensions) and thickness of
        the object (third dimension)
    eV : float
        Probe energy in electron volts

    Keyword arguments
    -----------------
    subslices : array_like, optional
        A one dimensional array-like object containing the depths (in fractional
        coordinates) at which the object will be subsliced. The last entry
        should always be 1.0. For example, to slice the object into four equal
        sized slices pass [0.25,0.5,0.75,1.0]
    tilt : array_like, optional
        Allows the user to simulate a (small &lt; 50 mrad) tilt of the specimen,
        by shearing the propagator. Units given by input variable tilt_units.
    tilt_units : string, optional
        Units of specimen tilt, can be &#39;mrad&#39;,&#39;pixels&#39; or &#39;invA&#39;
    &#34;&#34;&#34;
    from .Probe import make_contrast_transfer_function

    # We will use the make_contrast_transfer_function function to generate
    # the propagator, the aperture of this propagator will go out to the maximum
    # possible and the function bandwidth_limit_array will provide the band
    # width_limiting
    gridmax = np.asarray(gridshape) / np.asarray(gridsize[:2]) / 2
    app = np.hypot(*gridmax)

    # Intitialize array
    prop = np.zeros((len(subslices), *gridshape), dtype=np.complex)
    for islice, s_ in enumerate(subslices):
        if islice == 0:
            deltaz = s_ * gridsize[2]
        else:
            deltaz = (s_ - subslices[islice - 1]) * gridsize[2]

        # Calculate propagator
        prop[islice, :, :] = bandwidth_limit_array(
            make_contrast_transfer_function(
                gridshape,
                gridsize[:2],
                eV,
                app,
                df=deltaz,
                app_units=&#34;invA&#34;,
                optic_axis=tilt,
                tilt_units=tilt_units,
            ),
            limit=bandwidth_limit,
        )

    return prop


def generate_slice_indices(nslices, nsubslices, subslicing=False):
    &#34;&#34;&#34;Generate the slice indices for the multislice routine.&#34;&#34;&#34;
    from collections.abc import Sequence

    if isinstance(nslices, Sequence) or isinstance(nslices, np.ndarray):
        # If a list is passed, continue as before
        return nslices
    else:
        # If an integer is passed generate a list of slices to iterate through
        niterations = nslices if subslicing else nslices * nsubslices
        return np.arange(niterations)


def multislice(
    probes,
    nslices,
    propagators,
    transmission_functions,
    tiling=[1, 1],
    device_type=None,
    seed=None,
    return_numpy=True,
    qspace_in=False,
    qspace_out=False,
    posn=None,
    subslicing=False,
    output_to_bandwidth_limit=True,
    reverse=False,
    transpose=False,
):
    &#34;&#34;&#34;
    Multislice algorithm for scattering of an electron probe.

    Parameters
    ----------
    probes : (n,Y,X) or (Y,X) complex array_like
        Electron probe wave function(s)
    nslices : int, array_like
        The number of slices (iterations) to perform multislice over, if an
    propagators : (Z,Y,X,2) or (Y,X,2) torch.array
        Fresnel free space operators required for the multislice algorithm
        used to propagate the scattering matrix
    transmission_functions : (Z,nT,Y,X,2)
        The transmission functions describing the electron&#39;s interaction
        with the specimen for the multislice algorithm
    tiling : (2,) array_like
        Tiling of a repeat unit cell on simulation grid.
    device_type : torch.device, optional
        torch.device object which will determine which device (CPU or GPU) the
        calculations will run on
    seed : int, optional
        Seed for the random number generator for frozen phonon configurations
    return_numpy : bool, optional
        Calculations are performed on pytorch tensors for speed, however numpy
        arrays are more convenient for processing. This input allows the
        user to control how the output is returned
    qspace_in : bool, optional
        Should be set to True if the input wavefunction is in momentum (q) space
        and False otherwise (this is the default)
    qspace_out : bool, optional
        Should be set to True if the output wavefunction is desired in momentum
        (q) space and False otherwise (this is the default)
    posn :
        Does nothing, included to match calling signature for STEM function
    subslicing : bool, optional
        Pass subslicing=True to access propagation to sub-slices of the
        unit cell, in this case nslices is taken to be in units of subslices
        to propagate rather than unit cells (i.e. nslices = 3 will propagate
        1.5 unit cells for a subslicing of 2 subslices per unit cell)
    output_to_bandwidth_limit : bool, optional
        Bandwidth-limiting of the arrays is used in multislice to stop
        wrap-around error in reciprocal space, therefore the output of the
        multislice algorithm will be zero beyond some point in reciprocal space
        if this is set to True then these array entries will be cropped out.
        This does have the effect of the output of the function being on a
        different sized grid to the input.
    reverse : bool, optional
        Run inverse multislice (for back propagation of a wavefunction)
    transpose : bool, optional
        Reverse the order of the multislice operations, ie. apply propagator
        first and then transmission function
    Returns
    -------
    psi : (Y,X) or (n,Y,X) complex torch.tensor or np.ndarray
        Exit surface wave functions as a pytorch tensor or numpy array (default)
        depending on whether return_numpy is True or False. If the input `probes`
        is two dimensional then n = 1
    &#34;&#34;&#34;
    # If a single integer is passed to the routine then Seed random number generator,
    # , if None then np.random.RandomState will use the system clock as a seed
    seed_provided = not (seed is None)
    if not seed_provided:
        r = np.random.RandomState()
        np.random.seed(seed)

    # Initialize device cuda if available, CPU if no cuda is available
    device = get_device(device_type)

    # Since pytorch doesn&#39;t have a complex data type we need to add an extra
    # dimension of size 2 to each tensor that will store real and imaginary
    # components.
    T = ensure_torch_array(transmission_functions, device=device)
    P = ensure_torch_array(propagators, dtype=T.dtype, device=device)
    psi = ensure_torch_array(probes, dtype=T.dtype, device=device)

    nT, nsubslices, nopiy, nopix = T.shape[:4]

    # Probe needs to start multislice algorithm in real space
    if qspace_in:
        psi = torch.ifft(psi, signal_ndim=2)

    slices = generate_slice_indices(nslices, nsubslices, subslicing)

    for i, islice in enumerate(slices):

        # If an array-like object is passed then this will be used to uniquely
        # and reproducibly seed each iteration of the multislice algorithm
        if seed_provided:
            r = np.random.RandomState(seed[islice])

        subslice = islice % nsubslices

        # Pick random phase grating
        it = r.randint(0, nT)

        # To save memory in the case of equally sliced sample, there is the option
        # of only using one propagator, this statement catches this case.
        if P.dim() &lt; 4:
            P_ = P
        else:
            P_ = P[subslice]

        # If the transmission function is from a tiled unit cell then
        # there is the option of randomly shifting it around to
        # generate &#34;more&#34; psuedo-random transmission functions
        if tiling[0] == 1 &amp; tiling[1] == 1:
            T_ = T[it, subslice]
        elif nopiy % tiling[0] == 0 and nopix % tiling[1] == 0:

            T_ = T[it, subslice]
            if tiling[0] &gt; 1:
                # Shift an integer number of pixels in y
                T_ = roll_n(T_, 0, r.randint(0, tiling[0]) * (nopiy // tiling[0]))
            if tiling[1] &gt; 1:
                # Shift an integer number of pixels in x
                T_ = roll_n(T_, 1, r.randint(1, tiling[1]) * (nopix // tiling[1]))
        else:
            # Case of a non-integer pixel shifting of the unit cell
            yshift = r.randint(0, tiling[0]) * (nopiy / tiling[0])
            xshift = r.randint(0, tiling[1]) * (nopix / tiling[1])
            shift = torch.tensor([yshift, xshift])

            # Generate an array to perform Fourier shift of transmission
            # function
            FFT_shift_array = fourier_shift_array(
                [nopiy, nopix], shift, dtype=T.dtype, device=T.device
            )

            # Apply Fourier shift theorem for sub-pixel shift
            T_ = torch.ifft(
                complex_mul(FFT_shift_array, torch.fft(T[it, subslice], signal_ndim=2)),
                signal_ndim=2,
            )

        # Perform multislice iteration
        if transpose or reverse:
            # Reverse multislice complex conjugates the transmission and
            # propagation. Both reverse and transpose multislice reverse
            # the order of the transmission and conjugation operations
            # probe should start in real space and finish this iteration in
            # real space
            psi = complex_mul(
                torch.ifft(
                    complex_mul(torch.fft(psi, signal_ndim=2), P_, reverse),
                    signal_ndim=2,
                ),
                T_,
                reverse,
            )
        else:
            # Standard multislice iteration - probe should start in real space
            # and finish this iteration in reciprocal space
            psi = complex_mul(torch.fft(complex_mul(psi, T_), signal_ndim=2), P_)

        # The probe can be cropped to the bandwidth limit, this removes
        # superfluous array entries in reciprocal space that are zero
        # Since the next inverse FFT will apply a factor equal to the
        # square root number of pixels we have to adjust the values
        # of the array to compensate
        if i == len(slices) - 1:
            lim = 2 / 3 if output_to_bandwidth_limit else 1
            psi = crop_to_bandwidth_limit_torch(
                psi,
                qspace_in=not (transpose or reverse),
                qspace_out=qspace_out,
                limit=lim,
                norm=&#34;conserve_norm&#34;,
            )
        elif not (transpose or reverse):
            # Inverse Fourier transform back to real space for next iteration
            psi = torch.ifft(psi, signal_ndim=2)

    if len(slices) &lt; 1 and qspace_out:
        psi = torch.fft(psi, signal_ndim=2)

    if return_numpy:
        return cx_to_numpy(psi)
    return psi


def STEM_phase_contrast_transfer_function(probe, detector):
    &#34;&#34;&#34;
    Calculate the STEM phase contrast transfer function.

    For a thin and weakly scattering sample convolution with the STEM contrast
    transfer function gives a good approximate for STEM image contrast.

    Parameters
    ----------
    probe : complex, (Y,X) array_like
        The STEM probe in reciprocal space
    detector : real, (Y,X) array_like
        The STEM detector

    Returns
    -------
    PCTF : (Y,X) np.ndarray
        The phase contrast transfer function
    &#34;&#34;&#34;
    from .utils import convolve

    norm = np.sum(np.square(np.abs(probe)))
    # Use two ffts to perform reflection k -&gt; -k
    PCTF = (
        convolve(
            probe,
            np.fft.fft2(
                np.fft.fft2(np.conj(probe) * detector, norm=&#34;ortho&#34;), norm=&#34;ortho&#34;
            ),
        )
        / norm
    )
    PCTF -= np.conj(np.fft.fft2(np.fft.fft2(PCTF, norm=&#34;ortho&#34;), norm=&#34;ortho&#34;))

    return -2 * np.imag(PCTF)


# TODO make detectors binary for use with numpy and pytorch sum routines
def make_detector(gridshape, rsize, eV, betamax, betamin=0, units=&#34;mrad&#34;):
    &#34;&#34;&#34;
    Make a STEM detector with acceptance angle between betamin and betamax.

    Parameters
    ----------
    gridshape : (2,) array_like
        Pixel dimensions of the 2D grid
    rsize :  (2,) array_like
        Size of the grid in real space in units of Angstroms
    eV : float
        Probe energy in electron volts
    betamax : float
        Detector outer acceptance semi-angle

    Keyword arguments
    -----------------
    betamin : float, optional
        Detector inner acceptance semi-angle
    units : float, optional
        Units of betamin and betamax, mrad or invA are both acceptable
    &#34;&#34;&#34;
    # Get reciprocal space array
    q = q_space_array(gridshape, rsize)

    # If units are mrad convert qspace array from inverse Angstrom to mrad
    if units == &#34;mrad&#34;:
        q /= wavev(eV) / 1000

    # Calculate modulus square of reciprocal space array
    qsq = np.square(q[0]) + np.square(q[1])

    # Make detector
    detector = np.logical_and(qsq &lt; betamax ** 2, qsq &gt;= betamin ** 2)

    # Convert logical to integer
    return np.where(detector, 1, 0)


def nyquist_sampling(rsize=None, resolution_limit=None, eV=None, alpha=None):
    &#34;&#34;&#34;
    Calculate nyquist sampling (typically for minimum sampling of a STEM probe).

    If array size in units of length is passed then return how many probe
    positions are required otherwise just return the sampling. Alternatively
    pass probe accelerating voltage (eV) in electron-volts and probe forming
    aperture (alpha) in mrad and the resolution limit in inverse length will be
    calculated for you.
    &#34;&#34;&#34;
    if eV is None and alpha is None:
        step_size = 1 / (4 * resolution_limit)
    elif resolution_limit is None:
        step_size = 1 / (4 * wavev(eV) * alpha * 1e-3)
    else:
        return None

    if rsize is None:
        return step_size
    else:
        return np.ceil(rsize / step_size).astype(np.int)


def generate_STEM_raster(
    rsize,
    eV,
    alpha,
    tiling=[1, 1],
    ROI=[0.0, 0.0, 1.0, 1.0],
    gridshape=[1, 1],
    invA=False,
):
    &#34;&#34;&#34;
    Return the probe positions for a nyquist-sampled STEM raster.

    For a real space size rsize return probe positions in units of fraction of
    the array for nyquist sampled STEM raster

    Parameters
    ----------
    rsize :  (2,) array_like
        Size of the grid in real space in units of Angstroms
    eV : float
        Probe energy in electron volts
    alpha : float
        Probe forming aperture semi-angle in mrad or inverse Angstorm
        (if invA == True)

    Keyword arguments
    -----------------
    gridshape : (2,) array_like, optional
        Pixel dimensions of the 2D grid, by default [1,1] so probe positions will
        be returned as a fraction of the array size
    tiling : (2,) array_like
        Tiling of a repeat unit cell on simulation grid, if provided STEM raster
        will only scan a single unit cell.
    ROI : (4,) array_like
        Fraction of the unit cell to be scanned. Should contain [y0,x0,y1,x1]
        where [x0,y0] and [x1,y1] are the bottom left and top right coordinates
        of the region of interest (ROI) expressed as a fraction of the total
        grid (or unit cell).
    invA : bool
        If True, alpha is taken to be in units of inverse Angstrom, not mrad.
        This also means that the value of eV no longer matters

    Returns
    -------
    probe_posns : (nY,nX,2) np.ndarray
        The probe positions in fractions of the array gridshape is [1,1] and in
        pixel units if gridshape is the size of the pixel array.
    &#34;&#34;&#34;
    # Field of view in Angstrom
    FOV = np.asarray([rsize[0] * (ROI[2] - ROI[0]), rsize[1] * (ROI[3] - ROI[1])])

    if invA:
        # Number of scan coordinates in each dimension
        nscan = nyquist_sampling(FOV / np.asarray(tiling), resolution_limit=alpha)
    else:
        # Number of scan coordinates in each dimension
        nscan = nyquist_sampling(FOV / np.asarray(tiling), eV=eV, alpha=alpha)

    # Generate Y and X scan coordinates
    yy, xx = [
        np.arange(
            ROI[0 + i] * gridshape[i] / tiling[i],
            ROI[2 + i] * gridshape[i] / tiling[i],
            step=np.diff(ROI[i::2])[0] * gridshape[i] / nscan[i] / tiling[i],
        )[: nscan[i]]
        / gridshape[i]
        for i in range(2)
    ]

    return np.stack(np.broadcast_arrays(yy[:, None], xx[None, :]), axis=2)


def workout_4DSTEM_datacube_DP_size(FourD_STEM, rsize, gridshape):
    &#34;&#34;&#34;
    Calculate 4D-STEM datacube diffraction pattern gridsize and resampling function.

    Parameters
    ----------
    fourD_STEM : bool or array_like
        Pass fourD_STEM = True gives 4D STEM output with native simulation grid
        sampling. Alternatively, to save disk space a tuple containing pixel
        size and diffraction space extent of the datacube can be passed in. For
        example ([64,64],[1.2,1.2]) will output diffraction patterns measuring
        64 x 64 pixels and 1.2 x 1.2 inverse Angstroms.
    rsize : (2,) array_like
        Real space size of simulation grid
    gridshape : (2,) array_like
        Pixel size of gridshape

    Returns
    -------
    gridout : (2,) array_like
        Pixel size of the diffraciton pattern output
    resize : function
        A function that takes diffraction patterns from the simulation and
        resamples and crops them to the requested size.
    &#34;&#34;&#34;
    # Check whether a resampling directive has been given
    if isinstance(FourD_STEM, (list, tuple)):
        gridout = FourD_STEM[0]

        if len(FourD_STEM) &gt; 1:
            # Get output grid and diffraction space size of that grid from tuple
            Ksize = FourD_STEM[1]

            #
            diff_pat_crop = np.round(np.asarray(Ksize) * np.asarray(rsize[:2])).astype(
                np.int
            )

            # Define resampling function to crop and interpolate
            # diffraction patterns
            def resize(array):
                cropped = crop(np.fft.fftshift(array, axes=(-1, -2)), diff_pat_crop)
                return fourier_interpolate_2d(cropped, gridout, norm=&#34;conserve_L1&#34;)

        else:
            # The size in inverse Angstrom of the grid
            Ksize = np.asarray(gridout) / np.asarray(rsize)

            # Define resampling function to just crop diffraction
            # patterns
            def resize(array):
                return crop(np.fft.fftshift(array, axes=(-1, -2)), gridout)

    else:
        # If no resampling then the output size is just the simulation
        # grid size
        gridout = size_of_bandwidth_limited_array(gridshape)

        # The size in inverse Angstrom of the grid
        Ksize = np.asarray(gridout) / np.asarray(rsize)

        # Define a resampling function that does nothing
        def resize(array):
            return crop(np.fft.fftshift(array, axes=(-1, -2)), gridout)

    return gridout, resize, Ksize


def second_moment(array):
    &#34;&#34;&#34;Calculate the second moment of 2D array as a fraction of array size.&#34;&#34;&#34;
    grids = [np.fft.fftfreq(x) for x in array.shape]
    mass = np.sum(array)
    first_moment = [
        np.sum(x) / mass for x in [grids[0][:, None] * array, grids[1][None, :] * array]
    ]

    y2 = ((grids[0] - first_moment[0] + 0.5) % 1.0 - 0.5) ** 2
    x2 = ((grids[1] - first_moment[1] + 0.5) % 1.0 - 0.5) ** 2
    grid = y2[:, None] + x2[None, :]

    return np.sqrt(np.sum(grid * array) / mass)


def generate_probe_spread_plot(
    gridshape,
    structure,
    eV,
    app,
    thickness,
    subslices=[1],
    tiling=[1, 1],
    showcrossection=True,
    df=0,
    probe_posn=[0, 0],
    show=True,
    device=None,
    P=None,
    T=None,
    nslices=None,
):
    &#34;&#34;&#34;
    Generate probe spread plot to assist with selection of appropriate multislice grid.

    A multislice calculation assumes periodic boundary conditions. To avoid
    artefacts associated with this the pixel grid must be chosen to have
    sufficient size so that the probe does not artificially interfere with
    itself through the periodic boundary (wrap around error). The grid sampling
    must also be sufficient that electrons scattered to high angles are not
    scattered beyond the band-width limit of the array.

    The probe spread plot helps identify whenever these two events are happening.
    If the probe intensity drops below 0.95 (as a fraction of initial intensity)
    then the grid is not sampled finely enough, the pixel size of the array
    (gridshape) needs to increased for finer sampling of the specimen potential.
    If the probe spread exceeds 0.2 (as a fraction of the array) then too much
    of the probe is spreading to the edges of the array, the real space size
    of the array (usually controlled by the tiling of the unit cell) needs to
    be increased.

    Parameters
    ----------
    gridshape : (2,) array_like
        Pixel dimensions of the 2D grid
    structure : pyms.structure_routines.structure
        The structure of interest
    eV : float
        Probe energy in electron volts
    app : float
        Probe-forming aperture in mrad
    thickness : float
        The maximum thickness of the simulation object in Angstrom

    Keyword arguments
    -----------------
    subslices : array_like, optional
        A one dimensional array-like object containing the depths (in fractional
        coordinates) at which the object will be subsliced. The last entry
        should always be 1.0. For example, to slice the object into four equal
        sized slices pass [0.25,0.5,0.75,1.0]
    tiling : (2,) array_like, optional
        Tiling of a repeat unit cell on simulation grid
    showcrossection : bool
        Pass True to plot the projected cross section of the probe to inspect
        the spread.
    df : float
        Probe defocus in Angstrom
    probe_posn : array_like, optional
        Probe position as a fraction of the unit-cell
    P : (n,Y,X) array_like, optional
        Precomputed Fresnel free-space propagators
    T : (n,Y,X) array_like
        Precomputed transmission functions

    Returns
    -------
    fig : matplotlib.figure object
        The figure on which the probe spread is plotted
    &#34;&#34;&#34;
    # Calculate multislice propagator and transmission functions
    from .Premixed_routines import multislice_precursor

    if P is None or T is None:
        P, T = multislice_precursor(
            structure,
            gridshape,
            eV,
            subslices=subslices,
            tiling=tiling,
            device=device,
            nT=1,
            showProgress=False,
        )

    # Calculate focused STEM probe
    probe = focused_probe(
        gridshape, structure.unitcell[:2] * np.asarray(tiling), eV, app, df=df
    )
    pos = np.asarray(probe_posn) / np.asarray(tiling)
    from .utils import fourier_shift, fourier_interpolate_2d

    probe = fourier_shift(probe, pos, pixel_units=False)

    ncols = 1 + showcrossection
    fig, ax = plt.subplots(ncols=ncols, figsize=(ncols * 4, 4), squeeze=False)
    # Total number of slices (not including subslicing of structure)
    if nslices is None:
        nslices = int(np.ceil(thickness / structure.unitcell[2]))
    # Total number of slices (including subslicing of structure)
    maxslices = nslices * len(subslices)

    variances = np.zeros(maxslices)
    intensity = np.zeros(maxslices)

    crossection = np.zeros((maxslices, gridshape[0]))

    # Array must be shifted to center probe position
    shift = (pos * np.asarray(gridshape)).astype(np.int)

    for i in range(maxslices):
        probe = multislice(
            probe,
            [1],
            P,
            T,
            tiling=tiling,
            subslicing=True,
            output_to_bandwidth_limit=False,
            device_type=device,
        )
        mod = np.roll(np.abs(probe) ** 2, shift=-shift, axis=(-2, -1))
        # Record probe intensity and spread
        intensity[i] = np.sum(mod)
        variances[i] = second_moment(mod)
        if showcrossection:
            crossection[i] = np.sum(mod, axis=-1)

    thicknesses = structure.unitcell[2] * (
        np.broadcast_to(np.arange(nslices)[:, None], (nslices, len(subslices))).ravel()
        + np.tile(subslices, nslices)
    )
    ax[0, 0].set_xlim([0, thicknesses[-1]])
    ax[0, 0].set_ylim([0, 1.1])

    ax[0, 0].set_ylabel(
        &#34;$\\sqrt{\\int \\Psi^2 dx}$&#34;, color=&#34;red&#34;
    )  # we already handled the x-label with ax1
    ax[0, 0].set_xlabel(r&#34;Depth of propagation ($\AA$)&#34;)
    ax[0, 0].tick_params(axis=&#34;y&#34;, labelcolor=&#34;red&#34;)
    ax[0, 0].set_title(&#34;Probe intensity and spread&#34;)

    ax2 = ax[0, 0].twinx()  # instantiate a second axes that shares the same x-axis

    print(thicknesses.shape, variances.shape)
    ax2.plot(thicknesses, variances, &#34;b-&#34;)
    ax2.tick_params(axis=&#34;y&#34;, labelcolor=&#34;b&#34;)
    ax2.plot([0, thickness], [0.2, 0.2], &#34;b--&#34;)
    ax2.set_ylim([0, 0.5])
    ax2.set_ylabel(&#34;$\\sqrt{\\int \\Psi^2 x^2 dx}$&#34;, color=&#34;blue&#34;)
    ax[0, 0].plot(thicknesses, intensity, &#34;r-&#34;)
    ax[0, 0].plot([0, thicknesses[-1]], [0.95, 0.95], &#34;r--&#34;)
    nz, ny = crossection.shape
    if showcrossection:
        ax[0, 1].imshow(
            fourier_interpolate_2d(
                np.fft.fftshift(np.sqrt(crossection), axes=1), [ny, ny]
            ),
            extent=[0, gridshape[0], thickness, 0],
            cmap=plt.get_cmap(&#34;gnuplot&#34;),
        )
        ax[0, 1].set_ylabel(r&#34;Depth of propagation ($\AA$)&#34;)
        ax[0, 1].set_title(&#34;Probe depth cross-section&#34;)
    fig.tight_layout()
    if show:
        plt.show(block=True)
    return fig


def STEM(
    rsize,
    probe,
    method,
    nslices,
    eV,
    alpha,
    batch_size=1,
    detectors=None,
    FourD_STEM=False,
    datacube=None,
    PACBED=False,
    scan_posn=None,
    dtype=torch.float32,
    device=None,
    tiling=[1, 1],
    seed=None,
    showProgress=True,
    method_args=(),
    method_kwargs={},
    STEM_image=None,
):
    &#34;&#34;&#34;
    Perform a scanning transmission electron microscopy (STEM) image simulation.

    Will return an array containing conventional STEM images and/or a 4D-STEM
    datacube depending on inputs

    Parameters
    ----------
    rsize : (2,) array_like
        The real space size of the grid in Angstroms
    probe : (Y,X) array_like
        The probe that will be rastered over the object
    method : function
        A function that takes a probe and propagates it to the exit surface of
        the specimen
    nslices : int, array_like
        The number of slices to perform multislice over
    eV : float
        Accelerating voltage of the probe, needed to work out probe sampling
        requirements
    alpha : float
        The convergence angle of the probe in mrad, needed to work out probe
        sampling requirements

    Keyword arguments
    -----------------
    batch_size : int, optional
        The multislice algorithm can be performed on multiple probes columns
        at once to parrallelize computation, the number of parrallel computations
        is set by batch_size.
    detectors : (Ndet, Y, X) array_like, optional
        Diffraction plane detectors to perform conventional STEM imaging. If
        None is passed then no conventional STEM images will be returned.
    fourD_STEM : bool or array_like, optional
        Pass fourD_STEM = True to perform 4D-STEM simulations. To save disk
        space a tuple containing pixel size and diffraction space extent of the
        datacube can be passed in. For example ([64,64],[1.2,1.2]) will output
        diffraction patterns measuring 64 x 64 pixels and 1.2 x 1.2 inverse
        Angstroms.
    datacube :  (Ny, Nx, Y, X) array_like, optional
        datacube for 4D-STEM output, if None is passed (default) this will be
        initialized in the function. If a datacube is passed then the result
        will be added by the STEM routine (useful for multiple frozen phonon
        iterations)
    scan_posn :  (...,2) array_like, optional
        Array containing the STEM scan positions in fractional coordinates.
        If provided scan_posn.shape[:-1] will give the shape of the STEM image.
    dtype : torch.dtype, optional
        Datatype of the simulation arrays, by default 32-bit floating point
    device : torch.device, optional
        torch.device object which will determine which device (CPU or GPU) the
        calculations will run on
    tiling : (2,) array_like, optional
        Tiling of a repeat unit cell on simulation grid, STEM raster will only
        scan a single unit cell.
    seed : int, optional
        Seed for the random number generator for frozen phonon configurations
    showProgress : bool, optional
        Pass showProgress=False to disable progress bar.
    method_args : list, optional
        Arguments for the method function used to propagate probes to the exit
        surface
    method_kwargs : Dict, optional
        Keyword arguments for the method function used to propagate probes to
        the exit surface
    STEM_image : (Ndet,Ny,Nx) array_like, optional
        Array that will contain the conventional STEM images, if not passed
        will be initialized within the function. If it is passed then the result
        will be accumulated within the function, which is useful for multiple
        frozen phonon iterations.
    &#34;&#34;&#34;
    from .utils.torch_utils import detect

    tdisable, tqdm = tqdm_handler(showProgress)

    # Get number of thicknesses in the series
    nthick = len(nslices)

    if isinstance(nslices[0], int):
        nslices_ = np.diff(nslices, prepend=0)
    else:
        nslices_ = nslices

    if device is None:
        device = get_device(device)

    # Get shape of grid
    if torch.is_tensor(probe):
        gridshape = probe.shape[-3:-1]
    else:
        gridshape = probe.shape[-2:]

    # Generate scan positions in units of pixels if not supplied
    if scan_posn is None:
        scan_posn = generate_STEM_raster(rsize[:2], eV, alpha, tiling)

    # Number of scan positions
    scan_shape = scan_posn.shape[:-1]
    nscantot = np.prod(scan_shape)
    scan_posn = scan_posn.reshape((nscantot, 2))

    # Ensure scan_posn is a pytorch tensor with same device and datatype as other
    # arrays
    scan_posn = torch.as_tensor(scan_posn).to(device).type(dtype)

    # Assume real space probe is passed in so perform Fourier transform in
    # anticipation of application of Fourier shift theorem
    probe_ = ensure_torch_array(probe, dtype=dtype, device=device)
    probe_ = torch.fft(probe_, signal_ndim=2)

    # Work out whether to perform conventional STEM or not
    conventional_STEM = detectors is not None

    if conventional_STEM:
        # Get number of detectors
        ndet = detectors.shape[0]

        # Initialize array in which to store resulting STEM images
        if STEM_image is None:
            STEM_image = np.zeros((ndet, nthick, nscantot))
        else:
            STEM_image = STEM_image.reshape((ndet, nthick, nscantot))

        # Also move detectors to pytorch if necessary
        D = ensure_torch_array(detectors, device=device, dtype=dtype)
    else:
        STEM_image = None

    # Initialize array in which to store resulting 4D-STEM datacube if required
    if FourD_STEM:

        # Get diffraction pattern gridsize in pixels from input and function
        # to resample the simulation output to store in the datacube
        gridout, resize, _ = workout_4DSTEM_datacube_DP_size(
            FourD_STEM, rsize, gridshape
        )

        # Check whether a datacube is already provided or not
        if datacube is None:
            datacube = np.zeros((nthick, *scan_shape, *gridout))

    if PACBED:
        PACBED_pattern = torch.zeros((nthick, *gridshape), device=device)
    else:
        PACBED_pattern = None

    # This algorithm allows for &#34;batches&#34; of probe to be sent through the
    # multislice algorithm to achieve some speed up at the cost of storing more
    # probes in memory

    if seed is None and batch_size &gt; 1:
        # If no seed passed to random number generator then make one to pass to
        # the multislice algorithm. This ensure that each probe sees the same
        # frozen phonon configuration if we are doing batched multislice
        # calculations
        seed = np.random.randint(0, 2 ** 31 - 1)

    for i in tqdm(
        range(int(np.ceil(nscantot / batch_size))),
        disable=tdisable,
        desc=&#34;Probe positions&#34;,
    ):

        # Make shifted probes
        scan_index = np.arange(
            i * batch_size, min((i + 1) * batch_size, nscantot), dtype=np.int
        )

        # The shift operator array array will be of size batch_size x Y x X
        probes = fourier_shift_array(
            gridshape,
            torch.as_tensor(scan_posn[scan_index]),
            dtype=dtype,
            device=device,
            units=&#34;fractional&#34;,
        )

        # Apply shift to original probe
        probes = complex_mul(probe_.view(1, *probe_.size()), probes)

        # Thickness series
        #  - need to take the difference between sequential thickness variations
        for it, t in enumerate(nslices_):

            # Evaluate exit surface wave function from input probes
            probes = method(
                probes, t, *method_args, posn=scan_posn[scan_index], **method_kwargs
            )

            # Calculate amplitude of probes
            amp = amplitude(probes)

            # Correct normalization in Fourier space
            amp /= np.prod(probes.size()[-3:-1])

            # Calculate STEM images
            if conventional_STEM:
                # broadcast detector and probe arrays to
                # ndet x batch_size x Y x X and reduce final two dimensions
                STEM_image[:ndet, it, scan_index] += detect(D, amp).cpu().numpy()

            # Store datacube
            if FourD_STEM:
                DPS = resize(amp.cpu().numpy())
                ind = np.unravel_index(scan_index, scan_shape)
                for idp, DP in enumerate(DPS):
                    datacube[it][ind[0][idp], ind[1][idp]] += DP

            if PACBED:
                PACBED_pattern[it] += torch.sum(amp, axis=0) / nscantot

    if conventional_STEM:
        STEM_image = np.squeeze(STEM_image.reshape(ndet, nthick, *scan_shape))
    if PACBED:
        PACBED_pattern = np.fft.fftshift(PACBED_pattern.cpu().numpy(), axes=(-2, -1))
    return {&#34;STEM images&#34;: STEM_image, &#34;datacube&#34;: datacube, &#34;PACBED&#34;: PACBED_pattern}


def unit_cell_shift(array, axis, shift, tiles):
    &#34;&#34;&#34;
    Shift an array an integer number of unit cell.

    For an array consisting of a number of repeat units given by tiles
    shift than array an integer number of unit cells.
    &#34;&#34;&#34;
    indices = torch.remainder(torch.arange(array.shape[-3 + axis]) - shift)
    if axis == 0:
        return array[indices, :, :]
    if axis == 1:
        return array[:, indices, :]


def max_grid_resolution(gridshape, rsize, bandwidthlimit=2 / 3, eV=None):
    &#34;&#34;&#34;
    For a given pixel sampling, return maximum multislice grid resolution.

    For a given grid pixel size (gridshape) and real space size (rsize) return
    maximum resolution permitted by the multislice grid. If the probe
    accelerating voltage is passed in as eV resolution will be given in units
    of mrad, otherwise resolution will be given in units of inverse Angstrom.
    &#34;&#34;&#34;
    max_res = min([gridshape[x] / rsize[x] / 2 * bandwidthlimit for x in range(2)])
    if eV is None:
        return max_res

    return max_res / wavev(eV) * 1e3


class scattering_matrix:
    &#34;&#34;&#34;Scattering matrix object for calculations using the PRISM algorithm.&#34;&#34;&#34;

    def __init__(
        self,
        rsize,
        propagators,
        transmission_functions,
        nslice,
        eV,
        alpha,
        GPU_streaming=False,
        batch_size=30,
        device=None,
        PRISM_factor=[1, 1],
        tiling=[1, 1],
        device_type=None,
        seed=None,
        showProgress=True,
        bandwidth_limit=2 / 3,
        Fourier_space_output=False,
        subslicing=False,
        transposed=False,
        stored_gridshape=None,
    ):
        &#34;&#34;&#34;Initialize a scattering matrix.

        Parameters
        ----------
        rsize : (2,) array_like
            Real space size of the simulation grid in Angstrom
        propagators : (N,Y,X,2) torch.array
            Fresnel free space operators required for the multislice algorithm
            used to propagate the scattering matrix
        transmission_functions : (N,Y,X,2)
            The transmission functions describing the electron&#39;s interaction
            with the specimen for the multislice algorithm
        nslice : int
            The number of slices of the specimen to propagate the scattering
            matrix to
        eV : float
            Electron probe energy in electron-volts
        alpha : float
            Maximum input angle for the scattering matrix, should match the
            probe forming aperture used in experiment

        Keyword arguments
        -----------------
        GPU_streaming : bool, optional
            If True, the scattering matrix will be stored off GPU RAM and
            streamed to GPU RAM as necessary, does nothing if the calculation
            is CPU only
        batch_size : int, optional
            The multislice algorithm can be performed on multiple scattering
            matrix columns at once to parrallelize computation, this number is
            set by batch_size.
        device : torch.device, optional
            torch.device object which will determine which device (CPU or GPU)
            the calculations will run on. By default this will be determined
            by what device the transmission functions are stored on.
        PRISM_factor : int (2,) array_like
            The PRISM &#34;interpolation factor&#34; this is the amount by which the
            scattering matrices are cropped in real space to speed up
            calculations see Ophus, Colin. &#34;A fast image simulation algorithm
            for scanning transmission electron microscopy.&#34; Advanced structural
            and chemical imaging 3.1 (2017): 13 for details on this.
        seed : int32, optional
            A seed to control seeding of the frozen phonon approximation
        showProgress : bool, optional
            Pass showProgress = False to disable live progress readout
        bandwidth_limit : float, optional
            Band-width limiting of the transmission function and propagators to
            prevent wrap-around error in the multislice algorithm, 2/3 by
            default
        Fourier_space_output : bool, optional
            If True the scattering matrix output will be stored in reciprocal
            space, default is False
        subslicing : bool, optional
            Pass subslicing=True to access propagation to sub-slices of the
            unit cell, in this case nslices is taken to be in units of subslices
            to propagate rather than unit cells (i.e. nslices = 3 will propagate
            1.5 unit cells for a subslicing of 2 subslices per unit cell)
        transposed : bool, optional
            Make a &#34;transposed&#34; scattering matrix - see Brown et al. (2019)
            Physical Review Research paper for a discussion of this and its
            applications
        stored_gridshape : (2,) array_like
            Size of the stored grid, can be chosen to be smaller than the
            multislice grid to speed up computation of a smaller diffraction
            space view than that implied by the multislice at no cost to
            computational accuracy.
        &#34;&#34;&#34;
        # Get size of grid
        gridshape = transmission_functions.shape[-3:-1]

        # Datatype (precision) is inferred from transmission functions
        self.dtype = transmission_functions.dtype

        # Device (CPU or GPU) is also inferred from transmission functions
        self.device = device
        if GPU_streaming:
            self.device = torch.device(&#34;cpu&#34;)
        elif self.device is None:
            self.device = transmission_functions.device

        # Get alpha in units of inverse Angstrom
        self.alpha_ = wavev(eV) * alpha * 1e-3

        self.PRISM_factor = PRISM_factor
        self.doPRISM = np.any(np.asarray(PRISM_factor) &gt; 1)

        # Make a list of beams in the scattering matrix
        # Take beams inside the aperture and every nth beam where n is the
        # PRISM &#34;interpolation&#34; factor
        q = q_space_array(gridshape, rsize)
        inside_aperture = np.less_equal(q[0] ** 2 + q[1] ** 2, self.alpha_ ** 2)
        mody, modx = [
            np.mod(np.fft.fftfreq(x, 1 / x).astype(np.int), p) == 0
            for x, p in zip(gridshape, self.PRISM_factor)
        ]
        self.beams = np.nonzero(
            np.logical_and(
                np.logical_and(inside_aperture, mody[:, None]), modx[None, :]
            )
        )
        self.beams = [(x + y // 2) % y - y // 2 for x, y in zip(self.beams, gridshape)]

        self.nbeams = len(self.beams[0])

        # For a scattering matrix stored in real space there is the option
        # of storing it on a much smaller pixel grid than the grid used for
        # multislice. This is handy when, for example, a large grid
        # is required for a converged multislice calculation but only
        # the bright-field region of diffraction (small angle region)
        # is of interest. Be careful using this in conjunction with
        # multiple calls of the propagation method for the scattering matrix,
        # as information outside the angular range of the stored grid is lost.
        self.crop_output = not (stored_gridshape is None)
        if self.crop_output:
            self.stored_gridshape = stored_gridshape

            # We will only store output of the scattering matrix up to the band
            # width limit of the calculation, since this is a circular band-width
            # limit on a square grid we have to get somewhat fancy and store a mapping
            # of the pixels within the bandwidth limit to a one-dimensional vector
            self.bw_mapping = np.argwhere(
                np.logical_and(
                    (
                        np.abs(np.fft.fftfreq(gridshape[0], d=1 / gridshape[0]))
                        &lt; self.stored_gridshape[0] // 2
                    )[:, np.newaxis],
                    (
                        np.abs(np.fft.fftfreq(gridshape[1], d=1 / gridshape[1]))
                        &lt; self.stored_gridshape[1] // 2
                    )[np.newaxis, :],
                )
            )

        else:
            self.stored_gridshape = size_of_bandwidth_limited_array(
                transmission_functions.shape[-3:-1]
            )

            # We will only store output of the scattering matrix up to the band
            # width limit of the calculation, since this is a circular band-width
            # limit on a square grid we have to get somewhat fancy and store a mapping
            # of the pixels within the bandwidth limit to a one-dimensional vector
            self.bw_mapping = np.argwhere(
                (np.fft.fftfreq(gridshape[0]) ** 2)[:, np.newaxis]
                + (np.fft.fftfreq(gridshape[1]) ** 2)[np.newaxis, :]
                &lt; (bandwidth_limit / 2) ** 2
            )

        self.nbout = self.bw_mapping.shape[0]

        self.gridshape, self.rsize, self.eV = [np.asarray(gridshape), rsize, eV]
        self.bw_mapping = (
            self.bw_mapping + self.gridshape // 2
        ) % self.gridshape - self.gridshape // 2
        self.PRISM_factor, self.tiling = [PRISM_factor, tiling]
        self.doPRISM = np.any([self.PRISM_factor[i] &gt; 1 for i in [0, 1]])
        self.Fourier_space_output = Fourier_space_output
        self.nsubslices = transmission_functions.shape[1]
        slices = generate_slice_indices(nslice, self.nsubslices, subslicing=subslicing)
        self.GPU_streaming = GPU_streaming
        self.transposed = transposed

        self.seed = seed
        if self.seed is None:
            # If no seed passed to random number generator then make one to pass to
            # the multislice algorithm. This ensure that each column in the scattering
            # matrix sees the same frozen phonon configuration
            self.seed = np.random.randint(
                0, 2 ** 31 - 1, size=len(slices), dtype=np.uint32
            )

        # This switch tells the propagate function to initialize the Smatrix
        # to plane waves
        self.initialized = False
        # Propagate wave functions of scattering matrix
        self.current_slice = 0
        self.show_Progress = showProgress
        self.Propagate(
            nslice,
            propagators,
            transmission_functions,
            subslicing=subslicing,
            showProgress=self.show_Progress,
            batch_size=batch_size,
        )

    def Propagate(
        self,
        nslice,
        propagators,
        transmission_functions,
        subslicing=False,
        batch_size=3,
        showProgress=True,
        transpose=False,
    ):
        &#34;&#34;&#34;
        Propagate a scattering matrix to slice nslice of the specimen.

        Parameters
        ----------
        nslice : int
            The slice in the specimen to propagate the scattering matrix to
        propagators : (N,Y,X,2) torch.array
            Fresnel free space operators required for the multislice algorithm
            used to propagate the scattering matrix
        transmission_functions : (N,Y,X,2)
            The transmission functions describing the electron&#39;s interaction
            with the specimen for the multislice algorithm

        Keyword arguments
        -----------------
        batch_size : int, optional
            The multislice algorithm can be performed on multiple scattering
            matrix columns at once to parrallelize computation, this number is
            set by batch_size.
        subslicing : bool, optional
            Pass subslicing=True to access propagation to sub-slices of the
            unit cell, in this case nslices is taken to be in units of subslices
            to propagate rather than unit cells (i.e. nslices = 3 will propagate
            1.5 unit cells for a subslicing of 2 subslices per unit cell)
        showProgress : bool, optional
            Pass showProgress = False to disable live progress readout
        transpose : bool, optional
            Make a &#34;transposed&#34; scattering matrix - see Brown et al. (2019)
            Physical Review Research paper for a discussion of this and its
            applications
        &#34;&#34;&#34;
        from .Probe import plane_wave_illumination

        # Initialize scattering matrix if necessary
        if not self.initialized:
            if self.Fourier_space_output:
                self.S = torch.zeros(
                    self.nbeams, self.nbout, 2, dtype=self.dtype, device=self.device
                )
            else:
                self.S = torch.zeros(
                    self.nbeams,
                    *self.stored_gridshape,
                    2,
                    dtype=self.dtype,
                    device=self.device
                )
            for ibeam in range(self.nbeams):
                # Initialize S-matrix to plane-waves
                psi = cx_from_numpy(
                    plane_wave_illumination(
                        self.gridshape,
                        self.rsize[:2],
                        self.eV,
                        tilt=[self.beams[0][ibeam], self.beams[1][ibeam]],
                        tilt_units=&#34;pixels&#34;,
                        qspace=True,
                    )
                )

                # Adjust intensity for correct normalization of S matrix rows
                # taking into account the PRISM factor that needs to be applied
                # when the Smatrix is evaluated (only 1/product(PRISM_factor)
                # beams are taken and only 1/product(PRISM_factor) intensity
                # is cropped out in real space)
                psi *= torch.prod(torch.tensor(self.PRISM_factor, dtype=self.dtype))

                if self.Fourier_space_output:
                    self.S[ibeam] = psi[self.bw_mapping[:, 0], self.bw_mapping[:, 1], :]
                else:
                    self.S[ibeam] = fourier_interpolate_2d_torch(
                        psi,
                        self.stored_gridshape,
                        qspace_in=True,
                        qspace_out=False,
                        norm=&#34;conserve_norm&#34;,
                    )
            self.initialized = True

        # Make nslice_ which always accounts of subslices of the cyrstal structure
        if subslicing:
            nslice_ = nslice
        else:
            nslice_ = nslice * self.nsubslices

        # Work out direction of propagation through specimen
        if nslice_ != self.current_slice:
            direction = np.sign(nslice_ - self.current_slice)
        else:
            direction = 1

        if direction == 0:
            direction = 1

        if nslice_ &gt; len(self.seed):
            # Add new seeds to determine random translations for frozen-phonon
            # multislice (required for reversability of multislice) if required
            self.seed = np.concatenate(
                [
                    self.seed,
                    np.random.randint(0, 2 ** 31 - 1, size=nslice_ - len(self.seed)),
                ]
            )

        # Now generate list of slices that the multislice algorithm will run through
        slices = np.arange(self.current_slice, nslice_, direction)
        if direction &lt; 0:
            slices += direction

        # For a transposed scattering matrix the order of the slices
        # in multislice should be reversed
        if self.transposed:
            slices = slices[::-1]

        # If streaming of Smatrix columns to the GPU is being used, ensure
        # that propagators and transmission functions for the multislice are
        # already on the GPU
        if self.GPU_streaming:
            propagators = ensure_torch_array(propagators).cuda()
            transmission_functions = ensure_torch_array(transmission_functions).cuda()

        self.current_slice = nslice_
        if len(slices) &lt; 1:
            return

        # Loop over the different plane wave components (or columns) of the
        # scattering matrix
        for i in tqdm(
            range(int(np.ceil(self.nbeams / batch_size))),
            disable=not showProgress,
            desc=&#34;Calculating S-matrix&#34;,
        ):
            # Initialize array that will be used as input to the multislice routine
            psi = torch.zeros(
                batch_size, *self.gridshape, 2, dtype=self.dtype, device=self.device
            )
            beams = np.arange(
                i * batch_size, min((i + 1) * batch_size, self.nbeams), dtype=np.int
            )

            if self.Fourier_space_output:
                # Expand S-matrix input to full grid for multislice propagation
                psi[
                    : beams.shape[0], self.bw_mapping[:, 0], self.bw_mapping[:, 1], :
                ] = self.S[beams]
            else:
                # Fourier interpolate stored real space S-matrix column onto
                # multislice grid
                psi = fourier_interpolate_2d_torch(
                    self.S[beams], self.gridshape, norm=&#34;conserve_norm&#34;
                )

            if self.GPU_streaming:
                psi = ensure_torch_array(psi, dtype=self.dtype).to(&#34;cuda&#34;)

            output = multislice(
                psi[: beams.shape[0]],
                slices,
                propagators,
                transmission_functions,
                self.tiling,
                self.device,
                self.seed,
                return_numpy=False,
                qspace_in=self.Fourier_space_output,
                qspace_out=self.Fourier_space_output,
                transpose=self.transposed,
                output_to_bandwidth_limit=False,
                reverse=direction &lt; 0,
            )

            if self.GPU_streaming:
                output = output.to(self.device)

            if self.Fourier_space_output:

                self.S[beams] = output[
                    :, self.bw_mapping[:, 0], self.bw_mapping[:, 1], :
                ] * np.sqrt(np.prod(self.stored_gridshape) / np.prod(self.gridshape))
            else:
                output = fourier_interpolate_2d_torch(
                    output, self.stored_gridshape, norm=&#34;conserve_norm&#34;
                )
                self.S[beams] = output

    def PRISM_crop_window(self, win=None, device=None):
        &#34;&#34;&#34;Calculate 2D array indices of STEM crop window.&#34;&#34;&#34;
        device = get_device(device)
        if win is None:
            win = self.PRISM_factor

        crop_ = [
            torch.arange(
                -self.stored_gridshape[i] // (2 * win[i]),
                self.stored_gridshape[i] // (2 * win[i]),
                device=device,
            )
            for i in range(2)
        ]
        return crop_

    def __call__(self, probes, nslices, posn=None, Smat=None, scan_transform=None):
        &#34;&#34;&#34;
        Calculate exit-surface waves function using the scattering matrix.

        Parameters
        ----------
        probes : (N,Y,X,2) torch.array
            Input wave functions to calculate exit surface wave functions from
            must be in Diffraction space
        nslices :
            Does nothing, only there to match call signature for STEM routine
        posn : array_like (N,2)
            Positions of
        S : array_like (Nbeams,Y,X,2)
            Scattering matrix object

        Returns
        -------
        output : (N,Y,X,2) torch.array
            Exit surface wave functions
        &#34;&#34;&#34;
        from copy import deepcopy

        if Smat is None:
            Smat = self.S
        Sshape = [int(x) for x in Smat.shape]

        device = Smat.device
        crop_ = self.PRISM_crop_window(device=device)
        # Ensure posn and probes are pytorch arrays
        probes = ensure_torch_array(probes, dtype=self.dtype, device=device)

        # Ensure probes tensors correspond to the shape N x Y x X x 2
        # If they have the shape Y x X x 2 then reshape to 1 x Y x X x 2
        if probes.ndim &lt; 4:
            probes = probes.view(1, *probes.shape)

        # Get number of probes
        nprobes = probes.shape[0]

        if posn is None:
            posn = torch.zeros(nprobes, 2, device=device, dtype=self.dtype)
        else:
            posn = torch.as_tensor(posn, device=device, dtype=self.dtype).view(
                (nprobes, 2)
            )

        if scan_transform is not None:
            posn = scan_transform(posn)

        # TODO decide whether to remove the Fourier_space_output option
        if self.Fourier_space_output:

            # A note on normalization: an individual probe enters the STEM routine
            # with sum_squared intensity of 1, but the STEM routine applies an
            # FFT so the sum_squared intensity is now equal to # pixels
            # For a correct matrix multiplication we must now divide by sqrt(# pixels)
            probe_vec = complex_matmul(
                probes[:, self.beams[0], self.beams[1]], Smat
            ) / np.sqrt(np.prod(self.gridshape))

            # Now reshape output from vectors to square arrays
            probes = torch.zeros(
                nprobes, *self.stored_gridshape, 2, dtype=self.dtype, device=self.device
            )
            probes[:, self.bw_mapping[:, 0], self.bw_mapping[:, 1], :] = probe_vec

            # Apply PRISM cropping in real space if appropriate
            if self.doPRISM:
                shape = probes.size()

                probes = torch.ifft(probes, signal_ndim=2).flatten(-3, -2)
                for k in range(nprobes):

                    # Calculate windows in vertical and horizontal directions
                    window = crop_window_to_flattened_indices_torch(
                        [
                            (crop_[i] + posn[k, i] * self.stored_gridshape[i])
                            % self.stored_gridshape[i]
                            for i in range(2)
                        ],
                        self.stored_gridshape,
                    )
                    probe = deepcopy(probes[k])
                    probes[k] = 0
                    probes[k, window, :] = probe[window, :]

                probes = probes.reshape(shape)

                # Transform probe back to Fourier space
                return torch.fft(probes, signal_ndim=2)

            return probes
        else:
            # Flatten the array dimensions
            Smatshape = Smat.shape
            flattened_shape = [Smatshape[0], Smatshape[-3] * Smatshape[-2], 2]
            N = probes.shape[0]
            output = torch.zeros(
                N, *Smat.shape[-3:-1], 2, dtype=self.dtype, device=Smat.device
            )

            # For evaluating the probes in real space we only want to perform the matrix
            # multiplication and summation within the real space PRISM cropping region

            stride = [x // y for x, y in zip(self.stored_gridshape, self.PRISM_factor)]
            halfstride = [x // 2 for x in stride]

            # for k in range(probes.size(0)):
            for probe, pos, out in zip(probes, posn, output):

                if self.doPRISM:
                    start = [
                        int(torch.round(pos[i] * Sshape[-3 + i])) - halfstride[i]
                        for i in range(2)
                    ]
                    windows = crop_window_to_periodic_indices(
                        [start[0], stride[0], start[1], stride[1]], Sshape[-3:-1]
                    )

                    for wind in windows:
                        outview = out.narrow(-3, wind[0][0], wind[0][1]).narrow(
                            -2, wind[1][0], wind[1][1]
                        )
                        sview = Smat.narrow(-3, wind[0][0], wind[0][1]).narrow(
                            -2, wind[1][0], wind[1][1]
                        )
                        p = probe[self.beams[0], self.beams[1]].view(
                            self.nbeams, 1, 1, 2
                        )
                        outview += torch.sum(complex_mul(p, sview), axis=0)
                else:
                    output += complex_matmul(
                        probe[self.beams[0], self.beams[1]], Smat.view(flattened_shape)
                    ).view(Smatshape[1:])

            output /= np.sqrt(np.prod(probes.size()[-3:-1]))
            output = crop_torch(
                output.reshape(probes.size(0), *Smat.size()[-3:]), self.stored_gridshape
            )

            return torch.fft(output, signal_ndim=2)

    def STEM_with_GPU_streaming(
        self,
        detectors=None,
        FourD_STEM=None,
        datacube=None,
        STEM_image=None,
        nstreams=None,
        df=0,
        aberrations=[],
        ROI=[0.0, 0.0, 1.0, 1.0],
        device=None,
        scan_posns=None,
        showProgress=True,
    ):
        &#34;&#34;&#34;
        Perform STEM with scattering matrix streamed between RAM and GPU memory.

        This allows much larger fields of view to be calculated with relatively
        modest graphics card memory. The STEM raster is segmented into spatially
        close clusters and the probe positions in these clusters are processed
        sequentially, with the relevant part of the scattering matrix streamed
        from CPU to GPU memory.

        Parameters
        ----------
        self : scattering_matrix
            The scattering matrix object.
        detectors : (Ndet, Y, X) array_like, optional
            Diffraction plane detectors to perform conventional STEM imaging. If
            None is passed then no conventional STEM images will be returned.
        fourD_STEM : bool or array_like, optional
            Pass fourD_STEM = True to perform 4D-STEM simulations. To save disk
            space a tuple containing pixel size and diffraction space extent of the
            datacube can be passed in. For example ([64,64],[1.2,1.2]) will output
            diffraction patterns measuring 64 x 64 pixels and 1.2 x 1.2 inverse
            Angstroms.
        datacube :  (Ny, Nx, Y, X) array_like, optional
            datacube for 4D-STEM output, if None is passed (default) this will be
            initialized in the function. If a datacube is passed then the result
            will be added by the STEM routine (useful for multiple frozen phonon
            iterations)
        STEM_image : (Ndet,Ny,Nx) array_like, optional
            Array that will contain the conventional STEM images, if not passed
            will be initialized within the function. If it is passed then the result
            will be accumulated within the function, which is useful for multiple
            frozen phonon iterations.
        nstreams : int, optional
            Number of streams (seperate transfers from CPU to GPU memory). If
            None this will just be set to the product of the PRISM interpolation
            factor
        df : float, optional
            Defocus in Angstrom
        aberrations : list, optional
            A list containing a set of the class aberration, pass an empty list for
            an unaberrated contrast transfer function.
        ROI : (4,) array_like
            Fraction of the unit cell to be scanned. Should contain [y0,x0,y1,x1]
            where [x0,y0] and [x1,y1] are the bottom left and top right coordinates
            of the region of interest (ROI) expressed as a fraction of the total
            grid (or unit cell).
        device : torch.device, optional
            torch.device object which will determine which device (CPU or GPU) the
            calculations will run on.
        scan_posn :  (...,2) array_like, optional
            Array containing the STEM scan positions in fractional coordinates.
            If provided scan_posn.shape[:-1] will give the shape of the STEM
            image.
        showProgress : bool, optional
            Pass showProgress=False to disable progress bar.
        &#34;&#34;&#34;
        device = get_device(device)

        # Get indices of PRISM cropping window
        crop_ = [x.cpu().numpy() for x in self.PRISM_crop_window()]

        # Make the STEM probe
        probe = focused_probe(
            self.gridshape,
            self.rsize[:2],
            self.eV,
            self.alpha_,
            df=df,
            aberrations=aberrations,
            app_units=&#34;invA&#34;,
        )
        probe = cx_from_numpy(probe, device=device, dtype=self.dtype)

        # Make scan positions if none already provided
        if scan_posns is None:
            scan_posns = generate_STEM_raster(
                self.rsize, self.eV, self.alpha_, tiling=self.tiling, ROI=ROI, invA=True
            )
        # Get scan (and STEM image) array shape and total number of scan positions
        scan_shape = scan_posns.shape[:-1]
        nscan = np.product(scan_shape)

        # Flatten scan positions to simplify iteration later on.
        scan_posns = scan_posns.reshape((nscan, 2))

        # Calculate default 4D-STEM diffraction pattern sampling
        if FourD_STEM is True:
            GS = self.stored_gridshape
            FourD_STEM = [GS, GS / self.rsize[:2]]

        # Allocate diffraction pattern and STEM images if not already provided
        if FourD_STEM:
            gridout = workout_4DSTEM_datacube_DP_size(
                FourD_STEM, self.rsize, self.gridshape
            )[0]
        if (datacube is None) and FourD_STEM:
            datacube = np.zeros((*scan_shape, *gridout))
        if not FourD_STEM:
            datacube = None

        # If detectors are provided then we are doing conventional STEM
        doConventionalSTEM = detectors is not None

        # Initialize STEM images if not provided
        if doConventionalSTEM:
            ndet = detectors.shape[0]
            if STEM_image is None:
                STEM_image = np.zeros((ndet, nscan))
            else:
                STEM_image = STEM_image.reshape((ndet, nscan))
        else:
            STEM_image = None

        if nstreams is None:
            # If the number of seperate streams is not suggested by the
            # user, make this equal to the product of the PRISM factor
            nstreams = int(np.product(self.PRISM_factor))

        # Divide up the scan positions into clusters based on Euclidean
        # distance
        from sklearn.cluster import Birch

        if nscan &gt; 1:
            model = Birch(threshold=0.01, n_clusters=nstreams)
            yhat = model.fit_predict(scan_posns)
            clusters = np.unique(yhat)
        else:
            yhat, clusters = [[0], [0]]

        # Now do STEM with each of the scan position clusters, streaming
        # only the necessary bits of the scattering matrix to the GPU.
        Datacube_segment = None
        STEM_image_segment = None
        FlatS = self.S.reshape((self.nbeams, np.prod(self.stored_gridshape), 2))

        # Loop over probe positions clusters. This would be a good candidate
        # for multi-GPU work.
        for cluster in tqdm(
            clusters, desc=&#34;Probe position clusters&#34;, disable=not showProgress
        ):
            # Get map of probe positions in cluster
            points = np.nonzero(yhat == cluster)[0]
            npoints = len(points)

            # Get segments of images to update
            if doConventionalSTEM:
                STEM_image_segment = STEM_image[:, points]
            if FourD_STEM:
                Datacube_segment = np.zeros((1, npoints, 1, *gridout))
            pix_posn = scan_posns[points] * np.asarray(self.stored_gridshape)

            # Work out bounds of the rectangular region of the scattering
            # matrix to stream to the GPU
            ymin, ymax = [
                int(np.floor(np.amin(pix_posn[:, 0]) + crop_[0][0])),
                int(np.ceil(np.amax(pix_posn[:, 0]) + crop_[0][-1])),
            ]
            xmin, xmax = [
                int(np.floor(np.amin(pix_posn[:, 1]) + crop_[1][0])),
                int(np.ceil(np.amax(pix_posn[:, 1]) + crop_[1][-1])),
            ]
            size = np.asarray([(ymax - ymin), (xmax - xmin)])

            # Get indices of region of scattering matrix to stream to GPU
            window = [np.arange(a, b) for a, b in zip([ymin, xmin], [ymax, xmax])]
            indices = crop_window_to_flattened_indices_torch(
                window, self.stored_gridshape
            )

            # Get segment of the scattering matrix to stream to GPU
            segmentshape = [len(x) for x in window]
            SegmentS = FlatS[:, indices, :].reshape((self.nbeams, *segmentshape, 2))

            # Define a function that will map probe positions for the global
            # scattering matrix to their correct place on the smaller scattering
            # matrix streamed to the GPU.
            gshape = torch.as_tensor(self.stored_gridshape).to(device).type(self.dtype)
            Origin = torch.as_tensor([ymin, xmin]).to(device).type(self.dtype)
            segment_size = torch.as_tensor(size).to(device).type(self.dtype)

            def scan_transform(posn):
                return (posn * gshape - Origin) / segment_size

            # Keyword arguments to be passed to the __call__ function by the
            # STEM routine
            kwargs = {&#34;Smat&#34;: SegmentS.to(device), &#34;scan_transform&#34;: scan_transform}

            # Calculate STEM images
            STEM(
                self.rsize,
                probe,
                self.__call__,
                [1],
                self.eV,
                self.alpha_,
                detectors=detectors,
                FourD_STEM=FourD_STEM,
                datacube=Datacube_segment,
                scan_posn=scan_posns[points].reshape((npoints, 1, 2)),
                STEM_image=STEM_image_segment,
                method_kwargs=kwargs,
                showProgress=False,
                device=device,
            )

            if doConventionalSTEM:
                STEM_image[:, points] += STEM_image_segment
            if FourD_STEM:
                for point, Dp in zip(points, Datacube_segment[0]):
                    y, x = np.unravel_index(point, scan_shape)
                    datacube[y, x] += Dp[0]

        # Unflatten 4D-STEM datacube scan dimensions, use numpy squeeze to
        # remove superfluous dimensions (ones with length 1)
        # if FourD_STEM:
        #     datacube = datacube.reshape(*scan_shape, *datacube.shape[-2:])

        if doConventionalSTEM:
            STEM_image = np.squeeze(STEM_image.reshape(ndet, *scan_shape))

        # Return STEM images and datacube as a dictionary. If either of these
        # objects were not calculated the dictionary will contain None for those
        # entries.
        return {&#34;STEM images&#34;: STEM_image, &#34;datacube&#34;: datacube}


def phase_from_com(com, reg=1e-10, rsize=[1, 1]):
    &#34;&#34;&#34;
    Integrate 4D-STEM centre of mass (DPC) measurements to calculate object phase.

    Assumes a three dimensional array com, with the final two dimensions
    corresponding to the image and the first dimension of the array corresponding
    to the y and x centre of mass respectively.
    &#34;&#34;&#34;
    # Get shape of arrays
    ny, nx = com.shape[1:]
    s = (ny, nx)

    d = np.asarray(rsize) / np.asarray([ny, nx])
    # Calculate Fourier coordinates for array
    ky = np.fft.fftfreq(ny, d=d[0])
    kx = np.fft.rfftfreq(nx, d=d[1])

    # Calculate numerator and denominator expressions for solution of
    # phase from centre of mass measurements
    numerator = ky[:, None] * np.fft.rfft2(com[0], s=s) + kx[None, :] * np.fft.rfft2(
        com[1], s=s
    )
    denominator = 1j * ((kx ** 2)[None, :] + (ky ** 2)[:, None]) + reg

    # Avoid a divide by zero for the origin of the Fourier coordinates
    numerator[0, 0] = 0
    denominator[0, 0] = 1

    # Return real part of the inverse Fourier transform
    return np.fft.irfft2(numerator / denominator, s=s)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyms.py_multislice.STEM"><code class="name flex">
<span>def <span class="ident">STEM</span></span>(<span>rsize, probe, method, nslices, eV, alpha, batch_size=1, detectors=None, FourD_STEM=False, datacube=None, PACBED=False, scan_posn=None, dtype=torch.float32, device=None, tiling=[1, 1], seed=None, showProgress=True, method_args=(), method_kwargs={}, STEM_image=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a scanning transmission electron microscopy (STEM) image simulation.</p>
<p>Will return an array containing conventional STEM images and/or a 4D-STEM
datacube depending on inputs</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rsize</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>The real space size of the grid in Angstroms</dd>
<dt><strong><code>probe</code></strong> :&ensp;<code>(Y,X) array_like</code></dt>
<dd>The probe that will be rastered over the object</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>function</code></dt>
<dd>A function that takes a probe and propagates it to the exit surface of
the specimen</dd>
<dt><strong><code>nslices</code></strong> :&ensp;<code>int, array_like</code></dt>
<dd>The number of slices to perform multislice over</dd>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>Accelerating voltage of the probe, needed to work out probe sampling
requirements</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>The convergence angle of the probe in mrad, needed to work out probe
sampling requirements</dd>
</dl>
<h2 id="keyword-arguments">Keyword Arguments</h2>
<p>batch_size : int, optional
The multislice algorithm can be performed on multiple probes columns
at once to parrallelize computation, the number of parrallel computations
is set by batch_size.
detectors : (Ndet, Y, X) array_like, optional
Diffraction plane detectors to perform conventional STEM imaging. If
None is passed then no conventional STEM images will be returned.
fourD_STEM : bool or array_like, optional
Pass fourD_STEM = True to perform 4D-STEM simulations. To save disk
space a tuple containing pixel size and diffraction space extent of the
datacube can be passed in. For example ([64,64],[1.2,1.2]) will output
diffraction patterns measuring 64 x 64 pixels and 1.2 x 1.2 inverse
Angstroms.
datacube :
(Ny, Nx, Y, X) array_like, optional
datacube for 4D-STEM output, if None is passed (default) this will be
initialized in the function. If a datacube is passed then the result
will be added by the STEM routine (useful for multiple frozen phonon
iterations)
scan_posn :
(&hellip;,2) array_like, optional
Array containing the STEM scan positions in fractional coordinates.
If provided scan_posn.shape[:-1] will give the shape of the STEM image.
dtype : torch.dtype, optional
Datatype of the simulation arrays, by default 32-bit floating point
device : torch.device, optional
torch.device object which will determine which device (CPU or GPU) the
calculations will run on
tiling : (2,) array_like, optional
Tiling of a repeat unit cell on simulation grid, STEM raster will only
scan a single unit cell.
seed : int, optional
Seed for the random number generator for frozen phonon configurations
showProgress : bool, optional
Pass showProgress=False to disable progress bar.
method_args : list, optional
Arguments for the method function used to propagate probes to the exit
surface
method_kwargs : Dict, optional
Keyword arguments for the method function used to propagate probes to
the exit surface
STEM_image : (Ndet,Ny,Nx) array_like, optional
Array that will contain the conventional STEM images, if not passed
will be initialized within the function. If it is passed then the result
will be accumulated within the function, which is useful for multiple
frozen phonon iterations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def STEM(
    rsize,
    probe,
    method,
    nslices,
    eV,
    alpha,
    batch_size=1,
    detectors=None,
    FourD_STEM=False,
    datacube=None,
    PACBED=False,
    scan_posn=None,
    dtype=torch.float32,
    device=None,
    tiling=[1, 1],
    seed=None,
    showProgress=True,
    method_args=(),
    method_kwargs={},
    STEM_image=None,
):
    &#34;&#34;&#34;
    Perform a scanning transmission electron microscopy (STEM) image simulation.

    Will return an array containing conventional STEM images and/or a 4D-STEM
    datacube depending on inputs

    Parameters
    ----------
    rsize : (2,) array_like
        The real space size of the grid in Angstroms
    probe : (Y,X) array_like
        The probe that will be rastered over the object
    method : function
        A function that takes a probe and propagates it to the exit surface of
        the specimen
    nslices : int, array_like
        The number of slices to perform multislice over
    eV : float
        Accelerating voltage of the probe, needed to work out probe sampling
        requirements
    alpha : float
        The convergence angle of the probe in mrad, needed to work out probe
        sampling requirements

    Keyword arguments
    -----------------
    batch_size : int, optional
        The multislice algorithm can be performed on multiple probes columns
        at once to parrallelize computation, the number of parrallel computations
        is set by batch_size.
    detectors : (Ndet, Y, X) array_like, optional
        Diffraction plane detectors to perform conventional STEM imaging. If
        None is passed then no conventional STEM images will be returned.
    fourD_STEM : bool or array_like, optional
        Pass fourD_STEM = True to perform 4D-STEM simulations. To save disk
        space a tuple containing pixel size and diffraction space extent of the
        datacube can be passed in. For example ([64,64],[1.2,1.2]) will output
        diffraction patterns measuring 64 x 64 pixels and 1.2 x 1.2 inverse
        Angstroms.
    datacube :  (Ny, Nx, Y, X) array_like, optional
        datacube for 4D-STEM output, if None is passed (default) this will be
        initialized in the function. If a datacube is passed then the result
        will be added by the STEM routine (useful for multiple frozen phonon
        iterations)
    scan_posn :  (...,2) array_like, optional
        Array containing the STEM scan positions in fractional coordinates.
        If provided scan_posn.shape[:-1] will give the shape of the STEM image.
    dtype : torch.dtype, optional
        Datatype of the simulation arrays, by default 32-bit floating point
    device : torch.device, optional
        torch.device object which will determine which device (CPU or GPU) the
        calculations will run on
    tiling : (2,) array_like, optional
        Tiling of a repeat unit cell on simulation grid, STEM raster will only
        scan a single unit cell.
    seed : int, optional
        Seed for the random number generator for frozen phonon configurations
    showProgress : bool, optional
        Pass showProgress=False to disable progress bar.
    method_args : list, optional
        Arguments for the method function used to propagate probes to the exit
        surface
    method_kwargs : Dict, optional
        Keyword arguments for the method function used to propagate probes to
        the exit surface
    STEM_image : (Ndet,Ny,Nx) array_like, optional
        Array that will contain the conventional STEM images, if not passed
        will be initialized within the function. If it is passed then the result
        will be accumulated within the function, which is useful for multiple
        frozen phonon iterations.
    &#34;&#34;&#34;
    from .utils.torch_utils import detect

    tdisable, tqdm = tqdm_handler(showProgress)

    # Get number of thicknesses in the series
    nthick = len(nslices)

    if isinstance(nslices[0], int):
        nslices_ = np.diff(nslices, prepend=0)
    else:
        nslices_ = nslices

    if device is None:
        device = get_device(device)

    # Get shape of grid
    if torch.is_tensor(probe):
        gridshape = probe.shape[-3:-1]
    else:
        gridshape = probe.shape[-2:]

    # Generate scan positions in units of pixels if not supplied
    if scan_posn is None:
        scan_posn = generate_STEM_raster(rsize[:2], eV, alpha, tiling)

    # Number of scan positions
    scan_shape = scan_posn.shape[:-1]
    nscantot = np.prod(scan_shape)
    scan_posn = scan_posn.reshape((nscantot, 2))

    # Ensure scan_posn is a pytorch tensor with same device and datatype as other
    # arrays
    scan_posn = torch.as_tensor(scan_posn).to(device).type(dtype)

    # Assume real space probe is passed in so perform Fourier transform in
    # anticipation of application of Fourier shift theorem
    probe_ = ensure_torch_array(probe, dtype=dtype, device=device)
    probe_ = torch.fft(probe_, signal_ndim=2)

    # Work out whether to perform conventional STEM or not
    conventional_STEM = detectors is not None

    if conventional_STEM:
        # Get number of detectors
        ndet = detectors.shape[0]

        # Initialize array in which to store resulting STEM images
        if STEM_image is None:
            STEM_image = np.zeros((ndet, nthick, nscantot))
        else:
            STEM_image = STEM_image.reshape((ndet, nthick, nscantot))

        # Also move detectors to pytorch if necessary
        D = ensure_torch_array(detectors, device=device, dtype=dtype)
    else:
        STEM_image = None

    # Initialize array in which to store resulting 4D-STEM datacube if required
    if FourD_STEM:

        # Get diffraction pattern gridsize in pixels from input and function
        # to resample the simulation output to store in the datacube
        gridout, resize, _ = workout_4DSTEM_datacube_DP_size(
            FourD_STEM, rsize, gridshape
        )

        # Check whether a datacube is already provided or not
        if datacube is None:
            datacube = np.zeros((nthick, *scan_shape, *gridout))

    if PACBED:
        PACBED_pattern = torch.zeros((nthick, *gridshape), device=device)
    else:
        PACBED_pattern = None

    # This algorithm allows for &#34;batches&#34; of probe to be sent through the
    # multislice algorithm to achieve some speed up at the cost of storing more
    # probes in memory

    if seed is None and batch_size &gt; 1:
        # If no seed passed to random number generator then make one to pass to
        # the multislice algorithm. This ensure that each probe sees the same
        # frozen phonon configuration if we are doing batched multislice
        # calculations
        seed = np.random.randint(0, 2 ** 31 - 1)

    for i in tqdm(
        range(int(np.ceil(nscantot / batch_size))),
        disable=tdisable,
        desc=&#34;Probe positions&#34;,
    ):

        # Make shifted probes
        scan_index = np.arange(
            i * batch_size, min((i + 1) * batch_size, nscantot), dtype=np.int
        )

        # The shift operator array array will be of size batch_size x Y x X
        probes = fourier_shift_array(
            gridshape,
            torch.as_tensor(scan_posn[scan_index]),
            dtype=dtype,
            device=device,
            units=&#34;fractional&#34;,
        )

        # Apply shift to original probe
        probes = complex_mul(probe_.view(1, *probe_.size()), probes)

        # Thickness series
        #  - need to take the difference between sequential thickness variations
        for it, t in enumerate(nslices_):

            # Evaluate exit surface wave function from input probes
            probes = method(
                probes, t, *method_args, posn=scan_posn[scan_index], **method_kwargs
            )

            # Calculate amplitude of probes
            amp = amplitude(probes)

            # Correct normalization in Fourier space
            amp /= np.prod(probes.size()[-3:-1])

            # Calculate STEM images
            if conventional_STEM:
                # broadcast detector and probe arrays to
                # ndet x batch_size x Y x X and reduce final two dimensions
                STEM_image[:ndet, it, scan_index] += detect(D, amp).cpu().numpy()

            # Store datacube
            if FourD_STEM:
                DPS = resize(amp.cpu().numpy())
                ind = np.unravel_index(scan_index, scan_shape)
                for idp, DP in enumerate(DPS):
                    datacube[it][ind[0][idp], ind[1][idp]] += DP

            if PACBED:
                PACBED_pattern[it] += torch.sum(amp, axis=0) / nscantot

    if conventional_STEM:
        STEM_image = np.squeeze(STEM_image.reshape(ndet, nthick, *scan_shape))
    if PACBED:
        PACBED_pattern = np.fft.fftshift(PACBED_pattern.cpu().numpy(), axes=(-2, -1))
    return {&#34;STEM images&#34;: STEM_image, &#34;datacube&#34;: datacube, &#34;PACBED&#34;: PACBED_pattern}</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.STEM_phase_contrast_transfer_function"><code class="name flex">
<span>def <span class="ident">STEM_phase_contrast_transfer_function</span></span>(<span>probe, detector)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the STEM phase contrast transfer function.</p>
<p>For a thin and weakly scattering sample convolution with the STEM contrast
transfer function gives a good approximate for STEM image contrast.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>probe</code></strong> :&ensp;<code>complex, (Y,X) array_like</code></dt>
<dd>The STEM probe in reciprocal space</dd>
<dt><strong><code>detector</code></strong> :&ensp;<code>real, (Y,X) array_like</code></dt>
<dd>The STEM detector</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>PCTF</code></strong> :&ensp;<code>(Y,X) np.ndarray</code></dt>
<dd>The phase contrast transfer function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def STEM_phase_contrast_transfer_function(probe, detector):
    &#34;&#34;&#34;
    Calculate the STEM phase contrast transfer function.

    For a thin and weakly scattering sample convolution with the STEM contrast
    transfer function gives a good approximate for STEM image contrast.

    Parameters
    ----------
    probe : complex, (Y,X) array_like
        The STEM probe in reciprocal space
    detector : real, (Y,X) array_like
        The STEM detector

    Returns
    -------
    PCTF : (Y,X) np.ndarray
        The phase contrast transfer function
    &#34;&#34;&#34;
    from .utils import convolve

    norm = np.sum(np.square(np.abs(probe)))
    # Use two ffts to perform reflection k -&gt; -k
    PCTF = (
        convolve(
            probe,
            np.fft.fft2(
                np.fft.fft2(np.conj(probe) * detector, norm=&#34;ortho&#34;), norm=&#34;ortho&#34;
            ),
        )
        / norm
    )
    PCTF -= np.conj(np.fft.fft2(np.fft.fft2(PCTF, norm=&#34;ortho&#34;), norm=&#34;ortho&#34;))

    return -2 * np.imag(PCTF)</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.generate_STEM_raster"><code class="name flex">
<span>def <span class="ident">generate_STEM_raster</span></span>(<span>rsize, eV, alpha, tiling=[1, 1], ROI=[0.0, 0.0, 1.0, 1.0], gridshape=[1, 1], invA=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the probe positions for a nyquist-sampled STEM raster.</p>
<p>For a real space size rsize return probe positions in units of fraction of
the array for nyquist sampled STEM raster</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rsize</code></strong> :&ensp;<code> (2,) array_like</code></dt>
<dd>Size of the grid in real space in units of Angstroms</dd>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>Probe energy in electron volts</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>Probe forming aperture semi-angle in mrad or inverse Angstorm
(if invA == True)</dd>
</dl>
<h2 id="keyword-arguments">Keyword Arguments</h2>
<p>gridshape : (2,) array_like, optional
Pixel dimensions of the 2D grid, by default [1,1] so probe positions will
be returned as a fraction of the array size
tiling : (2,) array_like
Tiling of a repeat unit cell on simulation grid, if provided STEM raster
will only scan a single unit cell.
ROI : (4,) array_like
Fraction of the unit cell to be scanned. Should contain [y0,x0,y1,x1]
where [x0,y0] and [x1,y1] are the bottom left and top right coordinates
of the region of interest (ROI) expressed as a fraction of the total
grid (or unit cell).
invA : bool
If True, alpha is taken to be in units of inverse Angstrom, not mrad.
This also means that the value of eV no longer matters</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>probe_posns</code></strong> :&ensp;<code>(nY,nX,2) np.ndarray</code></dt>
<dd>The probe positions in fractions of the array gridshape is [1,1] and in
pixel units if gridshape is the size of the pixel array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_STEM_raster(
    rsize,
    eV,
    alpha,
    tiling=[1, 1],
    ROI=[0.0, 0.0, 1.0, 1.0],
    gridshape=[1, 1],
    invA=False,
):
    &#34;&#34;&#34;
    Return the probe positions for a nyquist-sampled STEM raster.

    For a real space size rsize return probe positions in units of fraction of
    the array for nyquist sampled STEM raster

    Parameters
    ----------
    rsize :  (2,) array_like
        Size of the grid in real space in units of Angstroms
    eV : float
        Probe energy in electron volts
    alpha : float
        Probe forming aperture semi-angle in mrad or inverse Angstorm
        (if invA == True)

    Keyword arguments
    -----------------
    gridshape : (2,) array_like, optional
        Pixel dimensions of the 2D grid, by default [1,1] so probe positions will
        be returned as a fraction of the array size
    tiling : (2,) array_like
        Tiling of a repeat unit cell on simulation grid, if provided STEM raster
        will only scan a single unit cell.
    ROI : (4,) array_like
        Fraction of the unit cell to be scanned. Should contain [y0,x0,y1,x1]
        where [x0,y0] and [x1,y1] are the bottom left and top right coordinates
        of the region of interest (ROI) expressed as a fraction of the total
        grid (or unit cell).
    invA : bool
        If True, alpha is taken to be in units of inverse Angstrom, not mrad.
        This also means that the value of eV no longer matters

    Returns
    -------
    probe_posns : (nY,nX,2) np.ndarray
        The probe positions in fractions of the array gridshape is [1,1] and in
        pixel units if gridshape is the size of the pixel array.
    &#34;&#34;&#34;
    # Field of view in Angstrom
    FOV = np.asarray([rsize[0] * (ROI[2] - ROI[0]), rsize[1] * (ROI[3] - ROI[1])])

    if invA:
        # Number of scan coordinates in each dimension
        nscan = nyquist_sampling(FOV / np.asarray(tiling), resolution_limit=alpha)
    else:
        # Number of scan coordinates in each dimension
        nscan = nyquist_sampling(FOV / np.asarray(tiling), eV=eV, alpha=alpha)

    # Generate Y and X scan coordinates
    yy, xx = [
        np.arange(
            ROI[0 + i] * gridshape[i] / tiling[i],
            ROI[2 + i] * gridshape[i] / tiling[i],
            step=np.diff(ROI[i::2])[0] * gridshape[i] / nscan[i] / tiling[i],
        )[: nscan[i]]
        / gridshape[i]
        for i in range(2)
    ]

    return np.stack(np.broadcast_arrays(yy[:, None], xx[None, :]), axis=2)</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.generate_probe_spread_plot"><code class="name flex">
<span>def <span class="ident">generate_probe_spread_plot</span></span>(<span>gridshape, structure, eV, app, thickness, subslices=[1], tiling=[1, 1], showcrossection=True, df=0, probe_posn=[0, 0], show=True, device=None, P=None, T=None, nslices=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate probe spread plot to assist with selection of appropriate multislice grid.</p>
<p>A multislice calculation assumes periodic boundary conditions. To avoid
artefacts associated with this the pixel grid must be chosen to have
sufficient size so that the probe does not artificially interfere with
itself through the periodic boundary (wrap around error). The grid sampling
must also be sufficient that electrons scattered to high angles are not
scattered beyond the band-width limit of the array.</p>
<p>The probe spread plot helps identify whenever these two events are happening.
If the probe intensity drops below 0.95 (as a fraction of initial intensity)
then the grid is not sampled finely enough, the pixel size of the array
(gridshape) needs to increased for finer sampling of the specimen potential.
If the probe spread exceeds 0.2 (as a fraction of the array) then too much
of the probe is spreading to the edges of the array, the real space size
of the array (usually controlled by the tiling of the unit cell) needs to
be increased.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gridshape</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Pixel dimensions of the 2D grid</dd>
<dt><strong><code>structure</code></strong> :&ensp;<code><a title="pyms.structure_routines.structure" href="structure_routines.html#pyms.structure_routines.structure">structure</a></code></dt>
<dd>The structure of interest</dd>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>Probe energy in electron volts</dd>
<dt><strong><code>app</code></strong> :&ensp;<code>float</code></dt>
<dd>Probe-forming aperture in mrad</dd>
<dt><strong><code>thickness</code></strong> :&ensp;<code>float</code></dt>
<dd>The maximum thickness of the simulation object in Angstrom</dd>
</dl>
<h2 id="keyword-arguments">Keyword Arguments</h2>
<p>subslices : array_like, optional
A one dimensional array-like object containing the depths (in fractional
coordinates) at which the object will be subsliced. The last entry
should always be 1.0. For example, to slice the object into four equal
sized slices pass [0.25,0.5,0.75,1.0]
tiling : (2,) array_like, optional
Tiling of a repeat unit cell on simulation grid
showcrossection : bool
Pass True to plot the projected cross section of the probe to inspect
the spread.
df : float
Probe defocus in Angstrom
probe_posn : array_like, optional
Probe position as a fraction of the unit-cell
P : (n,Y,X) array_like, optional
Precomputed Fresnel free-space propagators
T : (n,Y,X) array_like
Precomputed transmission functions</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.figure object</code></dt>
<dd>The figure on which the probe spread is plotted</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_probe_spread_plot(
    gridshape,
    structure,
    eV,
    app,
    thickness,
    subslices=[1],
    tiling=[1, 1],
    showcrossection=True,
    df=0,
    probe_posn=[0, 0],
    show=True,
    device=None,
    P=None,
    T=None,
    nslices=None,
):
    &#34;&#34;&#34;
    Generate probe spread plot to assist with selection of appropriate multislice grid.

    A multislice calculation assumes periodic boundary conditions. To avoid
    artefacts associated with this the pixel grid must be chosen to have
    sufficient size so that the probe does not artificially interfere with
    itself through the periodic boundary (wrap around error). The grid sampling
    must also be sufficient that electrons scattered to high angles are not
    scattered beyond the band-width limit of the array.

    The probe spread plot helps identify whenever these two events are happening.
    If the probe intensity drops below 0.95 (as a fraction of initial intensity)
    then the grid is not sampled finely enough, the pixel size of the array
    (gridshape) needs to increased for finer sampling of the specimen potential.
    If the probe spread exceeds 0.2 (as a fraction of the array) then too much
    of the probe is spreading to the edges of the array, the real space size
    of the array (usually controlled by the tiling of the unit cell) needs to
    be increased.

    Parameters
    ----------
    gridshape : (2,) array_like
        Pixel dimensions of the 2D grid
    structure : pyms.structure_routines.structure
        The structure of interest
    eV : float
        Probe energy in electron volts
    app : float
        Probe-forming aperture in mrad
    thickness : float
        The maximum thickness of the simulation object in Angstrom

    Keyword arguments
    -----------------
    subslices : array_like, optional
        A one dimensional array-like object containing the depths (in fractional
        coordinates) at which the object will be subsliced. The last entry
        should always be 1.0. For example, to slice the object into four equal
        sized slices pass [0.25,0.5,0.75,1.0]
    tiling : (2,) array_like, optional
        Tiling of a repeat unit cell on simulation grid
    showcrossection : bool
        Pass True to plot the projected cross section of the probe to inspect
        the spread.
    df : float
        Probe defocus in Angstrom
    probe_posn : array_like, optional
        Probe position as a fraction of the unit-cell
    P : (n,Y,X) array_like, optional
        Precomputed Fresnel free-space propagators
    T : (n,Y,X) array_like
        Precomputed transmission functions

    Returns
    -------
    fig : matplotlib.figure object
        The figure on which the probe spread is plotted
    &#34;&#34;&#34;
    # Calculate multislice propagator and transmission functions
    from .Premixed_routines import multislice_precursor

    if P is None or T is None:
        P, T = multislice_precursor(
            structure,
            gridshape,
            eV,
            subslices=subslices,
            tiling=tiling,
            device=device,
            nT=1,
            showProgress=False,
        )

    # Calculate focused STEM probe
    probe = focused_probe(
        gridshape, structure.unitcell[:2] * np.asarray(tiling), eV, app, df=df
    )
    pos = np.asarray(probe_posn) / np.asarray(tiling)
    from .utils import fourier_shift, fourier_interpolate_2d

    probe = fourier_shift(probe, pos, pixel_units=False)

    ncols = 1 + showcrossection
    fig, ax = plt.subplots(ncols=ncols, figsize=(ncols * 4, 4), squeeze=False)
    # Total number of slices (not including subslicing of structure)
    if nslices is None:
        nslices = int(np.ceil(thickness / structure.unitcell[2]))
    # Total number of slices (including subslicing of structure)
    maxslices = nslices * len(subslices)

    variances = np.zeros(maxslices)
    intensity = np.zeros(maxslices)

    crossection = np.zeros((maxslices, gridshape[0]))

    # Array must be shifted to center probe position
    shift = (pos * np.asarray(gridshape)).astype(np.int)

    for i in range(maxslices):
        probe = multislice(
            probe,
            [1],
            P,
            T,
            tiling=tiling,
            subslicing=True,
            output_to_bandwidth_limit=False,
            device_type=device,
        )
        mod = np.roll(np.abs(probe) ** 2, shift=-shift, axis=(-2, -1))
        # Record probe intensity and spread
        intensity[i] = np.sum(mod)
        variances[i] = second_moment(mod)
        if showcrossection:
            crossection[i] = np.sum(mod, axis=-1)

    thicknesses = structure.unitcell[2] * (
        np.broadcast_to(np.arange(nslices)[:, None], (nslices, len(subslices))).ravel()
        + np.tile(subslices, nslices)
    )
    ax[0, 0].set_xlim([0, thicknesses[-1]])
    ax[0, 0].set_ylim([0, 1.1])

    ax[0, 0].set_ylabel(
        &#34;$\\sqrt{\\int \\Psi^2 dx}$&#34;, color=&#34;red&#34;
    )  # we already handled the x-label with ax1
    ax[0, 0].set_xlabel(r&#34;Depth of propagation ($\AA$)&#34;)
    ax[0, 0].tick_params(axis=&#34;y&#34;, labelcolor=&#34;red&#34;)
    ax[0, 0].set_title(&#34;Probe intensity and spread&#34;)

    ax2 = ax[0, 0].twinx()  # instantiate a second axes that shares the same x-axis

    print(thicknesses.shape, variances.shape)
    ax2.plot(thicknesses, variances, &#34;b-&#34;)
    ax2.tick_params(axis=&#34;y&#34;, labelcolor=&#34;b&#34;)
    ax2.plot([0, thickness], [0.2, 0.2], &#34;b--&#34;)
    ax2.set_ylim([0, 0.5])
    ax2.set_ylabel(&#34;$\\sqrt{\\int \\Psi^2 x^2 dx}$&#34;, color=&#34;blue&#34;)
    ax[0, 0].plot(thicknesses, intensity, &#34;r-&#34;)
    ax[0, 0].plot([0, thicknesses[-1]], [0.95, 0.95], &#34;r--&#34;)
    nz, ny = crossection.shape
    if showcrossection:
        ax[0, 1].imshow(
            fourier_interpolate_2d(
                np.fft.fftshift(np.sqrt(crossection), axes=1), [ny, ny]
            ),
            extent=[0, gridshape[0], thickness, 0],
            cmap=plt.get_cmap(&#34;gnuplot&#34;),
        )
        ax[0, 1].set_ylabel(r&#34;Depth of propagation ($\AA$)&#34;)
        ax[0, 1].set_title(&#34;Probe depth cross-section&#34;)
    fig.tight_layout()
    if show:
        plt.show(block=True)
    return fig</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.generate_slice_indices"><code class="name flex">
<span>def <span class="ident">generate_slice_indices</span></span>(<span>nslices, nsubslices, subslicing=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the slice indices for the multislice routine.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_slice_indices(nslices, nsubslices, subslicing=False):
    &#34;&#34;&#34;Generate the slice indices for the multislice routine.&#34;&#34;&#34;
    from collections.abc import Sequence

    if isinstance(nslices, Sequence) or isinstance(nslices, np.ndarray):
        # If a list is passed, continue as before
        return nslices
    else:
        # If an integer is passed generate a list of slices to iterate through
        niterations = nslices if subslicing else nslices * nsubslices
        return np.arange(niterations)</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.make_detector"><code class="name flex">
<span>def <span class="ident">make_detector</span></span>(<span>gridshape, rsize, eV, betamax, betamin=0, units='mrad')</span>
</code></dt>
<dd>
<div class="desc"><p>Make a STEM detector with acceptance angle between betamin and betamax.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gridshape</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Pixel dimensions of the 2D grid</dd>
<dt><strong><code>rsize</code></strong> :&ensp;<code> (2,) array_like</code></dt>
<dd>Size of the grid in real space in units of Angstroms</dd>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>Probe energy in electron volts</dd>
<dt><strong><code>betamax</code></strong> :&ensp;<code>float</code></dt>
<dd>Detector outer acceptance semi-angle</dd>
</dl>
<h2 id="keyword-arguments">Keyword Arguments</h2>
<p>betamin : float, optional
Detector inner acceptance semi-angle
units : float, optional
Units of betamin and betamax, mrad or invA are both acceptable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_detector(gridshape, rsize, eV, betamax, betamin=0, units=&#34;mrad&#34;):
    &#34;&#34;&#34;
    Make a STEM detector with acceptance angle between betamin and betamax.

    Parameters
    ----------
    gridshape : (2,) array_like
        Pixel dimensions of the 2D grid
    rsize :  (2,) array_like
        Size of the grid in real space in units of Angstroms
    eV : float
        Probe energy in electron volts
    betamax : float
        Detector outer acceptance semi-angle

    Keyword arguments
    -----------------
    betamin : float, optional
        Detector inner acceptance semi-angle
    units : float, optional
        Units of betamin and betamax, mrad or invA are both acceptable
    &#34;&#34;&#34;
    # Get reciprocal space array
    q = q_space_array(gridshape, rsize)

    # If units are mrad convert qspace array from inverse Angstrom to mrad
    if units == &#34;mrad&#34;:
        q /= wavev(eV) / 1000

    # Calculate modulus square of reciprocal space array
    qsq = np.square(q[0]) + np.square(q[1])

    # Make detector
    detector = np.logical_and(qsq &lt; betamax ** 2, qsq &gt;= betamin ** 2)

    # Convert logical to integer
    return np.where(detector, 1, 0)</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.make_propagators"><code class="name flex">
<span>def <span class="ident">make_propagators</span></span>(<span>gridshape, gridsize, eV, subslices=[1.0], tilt=[0, 0], tilt_units='mrad', bandwidth_limit=0.6666666666666666)</span>
</code></dt>
<dd>
<div class="desc"><p>Make the Fresnel freespace propagators for a multislice simulation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gridshape</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Pixel dimensions of the 2D grid</dd>
<dt><strong><code>gridsize</code></strong> :&ensp;<code>(3,) array_like</code></dt>
<dd>Size of the grid in real space (first two dimensions) and thickness of
the object (third dimension)</dd>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>Probe energy in electron volts</dd>
</dl>
<h2 id="keyword-arguments">Keyword Arguments</h2>
<p>subslices : array_like, optional
A one dimensional array-like object containing the depths (in fractional
coordinates) at which the object will be subsliced. The last entry
should always be 1.0. For example, to slice the object into four equal
sized slices pass [0.25,0.5,0.75,1.0]
tilt : array_like, optional
Allows the user to simulate a (small &lt; 50 mrad) tilt of the specimen,
by shearing the propagator. Units given by input variable tilt_units.
tilt_units : string, optional
Units of specimen tilt, can be 'mrad','pixels' or 'invA'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_propagators(
    gridshape,
    gridsize,
    eV,
    subslices=[1.0],
    tilt=[0, 0],
    tilt_units=&#34;mrad&#34;,
    bandwidth_limit=2 / 3,
):
    &#34;&#34;&#34;
    Make the Fresnel freespace propagators for a multislice simulation.

    Parameters
    ----------
    gridshape : (2,) array_like
        Pixel dimensions of the 2D grid
    gridsize : (3,) array_like
        Size of the grid in real space (first two dimensions) and thickness of
        the object (third dimension)
    eV : float
        Probe energy in electron volts

    Keyword arguments
    -----------------
    subslices : array_like, optional
        A one dimensional array-like object containing the depths (in fractional
        coordinates) at which the object will be subsliced. The last entry
        should always be 1.0. For example, to slice the object into four equal
        sized slices pass [0.25,0.5,0.75,1.0]
    tilt : array_like, optional
        Allows the user to simulate a (small &lt; 50 mrad) tilt of the specimen,
        by shearing the propagator. Units given by input variable tilt_units.
    tilt_units : string, optional
        Units of specimen tilt, can be &#39;mrad&#39;,&#39;pixels&#39; or &#39;invA&#39;
    &#34;&#34;&#34;
    from .Probe import make_contrast_transfer_function

    # We will use the make_contrast_transfer_function function to generate
    # the propagator, the aperture of this propagator will go out to the maximum
    # possible and the function bandwidth_limit_array will provide the band
    # width_limiting
    gridmax = np.asarray(gridshape) / np.asarray(gridsize[:2]) / 2
    app = np.hypot(*gridmax)

    # Intitialize array
    prop = np.zeros((len(subslices), *gridshape), dtype=np.complex)
    for islice, s_ in enumerate(subslices):
        if islice == 0:
            deltaz = s_ * gridsize[2]
        else:
            deltaz = (s_ - subslices[islice - 1]) * gridsize[2]

        # Calculate propagator
        prop[islice, :, :] = bandwidth_limit_array(
            make_contrast_transfer_function(
                gridshape,
                gridsize[:2],
                eV,
                app,
                df=deltaz,
                app_units=&#34;invA&#34;,
                optic_axis=tilt,
                tilt_units=tilt_units,
            ),
            limit=bandwidth_limit,
        )

    return prop</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.max_grid_resolution"><code class="name flex">
<span>def <span class="ident">max_grid_resolution</span></span>(<span>gridshape, rsize, bandwidthlimit=0.6666666666666666, eV=None)</span>
</code></dt>
<dd>
<div class="desc"><p>For a given pixel sampling, return maximum multislice grid resolution.</p>
<p>For a given grid pixel size (gridshape) and real space size (rsize) return
maximum resolution permitted by the multislice grid. If the probe
accelerating voltage is passed in as eV resolution will be given in units
of mrad, otherwise resolution will be given in units of inverse Angstrom.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_grid_resolution(gridshape, rsize, bandwidthlimit=2 / 3, eV=None):
    &#34;&#34;&#34;
    For a given pixel sampling, return maximum multislice grid resolution.

    For a given grid pixel size (gridshape) and real space size (rsize) return
    maximum resolution permitted by the multislice grid. If the probe
    accelerating voltage is passed in as eV resolution will be given in units
    of mrad, otherwise resolution will be given in units of inverse Angstrom.
    &#34;&#34;&#34;
    max_res = min([gridshape[x] / rsize[x] / 2 * bandwidthlimit for x in range(2)])
    if eV is None:
        return max_res

    return max_res / wavev(eV) * 1e3</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.multislice"><code class="name flex">
<span>def <span class="ident">multislice</span></span>(<span>probes, nslices, propagators, transmission_functions, tiling=[1, 1], device_type=None, seed=None, return_numpy=True, qspace_in=False, qspace_out=False, posn=None, subslicing=False, output_to_bandwidth_limit=True, reverse=False, transpose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Multislice algorithm for scattering of an electron probe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>probes</code></strong> :&ensp;<code>(n,Y,X)</code> or <code>(Y,X) complex array_like</code></dt>
<dd>Electron probe wave function(s)</dd>
<dt><strong><code>nslices</code></strong> :&ensp;<code>int, array_like</code></dt>
<dd>The number of slices (iterations) to perform multislice over, if an</dd>
<dt><strong><code>propagators</code></strong> :&ensp;<code>(Z,Y,X,2)</code> or <code>(Y,X,2) torch.array</code></dt>
<dd>Fresnel free space operators required for the multislice algorithm
used to propagate the scattering matrix</dd>
<dt><strong><code>transmission_functions</code></strong> :&ensp;<code>(Z,nT,Y,X,2)</code></dt>
<dd>The transmission functions describing the electron's interaction
with the specimen for the multislice algorithm</dd>
<dt><strong><code>tiling</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Tiling of a repeat unit cell on simulation grid.</dd>
<dt><strong><code>device_type</code></strong> :&ensp;<code>torch.device</code>, optional</dt>
<dd>torch.device object which will determine which device (CPU or GPU) the
calculations will run on</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Seed for the random number generator for frozen phonon configurations</dd>
<dt><strong><code>return_numpy</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Calculations are performed on pytorch tensors for speed, however numpy
arrays are more convenient for processing. This input allows the
user to control how the output is returned</dd>
<dt><strong><code>qspace_in</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Should be set to True if the input wavefunction is in momentum (q) space
and False otherwise (this is the default)</dd>
<dt><strong><code>qspace_out</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Should be set to True if the output wavefunction is desired in momentum
(q) space and False otherwise (this is the default)</dd>
<dt>posn :</dt>
<dt>Does nothing, included to match calling signature for STEM function</dt>
<dt><strong><code>subslicing</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Pass subslicing=True to access propagation to sub-slices of the
unit cell, in this case nslices is taken to be in units of subslices
to propagate rather than unit cells (i.e. nslices = 3 will propagate
1.5 unit cells for a subslicing of 2 subslices per unit cell)</dd>
<dt><strong><code>output_to_bandwidth_limit</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Bandwidth-limiting of the arrays is used in multislice to stop
wrap-around error in reciprocal space, therefore the output of the
multislice algorithm will be zero beyond some point in reciprocal space
if this is set to True then these array entries will be cropped out.
This does have the effect of the output of the function being on a
different sized grid to the input.</dd>
<dt><strong><code>reverse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Run inverse multislice (for back propagation of a wavefunction)</dd>
<dt><strong><code>transpose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Reverse the order of the multislice operations, ie. apply propagator
first and then transmission function</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>psi</code></strong> :&ensp;<code>(Y,X)</code> or <code>(n,Y,X) complex torch.tensor</code> or <code>np.ndarray</code></dt>
<dd>Exit surface wave functions as a pytorch tensor or numpy array (default)
depending on whether return_numpy is True or False. If the input <code>probes</code>
is two dimensional then n = 1</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multislice(
    probes,
    nslices,
    propagators,
    transmission_functions,
    tiling=[1, 1],
    device_type=None,
    seed=None,
    return_numpy=True,
    qspace_in=False,
    qspace_out=False,
    posn=None,
    subslicing=False,
    output_to_bandwidth_limit=True,
    reverse=False,
    transpose=False,
):
    &#34;&#34;&#34;
    Multislice algorithm for scattering of an electron probe.

    Parameters
    ----------
    probes : (n,Y,X) or (Y,X) complex array_like
        Electron probe wave function(s)
    nslices : int, array_like
        The number of slices (iterations) to perform multislice over, if an
    propagators : (Z,Y,X,2) or (Y,X,2) torch.array
        Fresnel free space operators required for the multislice algorithm
        used to propagate the scattering matrix
    transmission_functions : (Z,nT,Y,X,2)
        The transmission functions describing the electron&#39;s interaction
        with the specimen for the multislice algorithm
    tiling : (2,) array_like
        Tiling of a repeat unit cell on simulation grid.
    device_type : torch.device, optional
        torch.device object which will determine which device (CPU or GPU) the
        calculations will run on
    seed : int, optional
        Seed for the random number generator for frozen phonon configurations
    return_numpy : bool, optional
        Calculations are performed on pytorch tensors for speed, however numpy
        arrays are more convenient for processing. This input allows the
        user to control how the output is returned
    qspace_in : bool, optional
        Should be set to True if the input wavefunction is in momentum (q) space
        and False otherwise (this is the default)
    qspace_out : bool, optional
        Should be set to True if the output wavefunction is desired in momentum
        (q) space and False otherwise (this is the default)
    posn :
        Does nothing, included to match calling signature for STEM function
    subslicing : bool, optional
        Pass subslicing=True to access propagation to sub-slices of the
        unit cell, in this case nslices is taken to be in units of subslices
        to propagate rather than unit cells (i.e. nslices = 3 will propagate
        1.5 unit cells for a subslicing of 2 subslices per unit cell)
    output_to_bandwidth_limit : bool, optional
        Bandwidth-limiting of the arrays is used in multislice to stop
        wrap-around error in reciprocal space, therefore the output of the
        multislice algorithm will be zero beyond some point in reciprocal space
        if this is set to True then these array entries will be cropped out.
        This does have the effect of the output of the function being on a
        different sized grid to the input.
    reverse : bool, optional
        Run inverse multislice (for back propagation of a wavefunction)
    transpose : bool, optional
        Reverse the order of the multislice operations, ie. apply propagator
        first and then transmission function
    Returns
    -------
    psi : (Y,X) or (n,Y,X) complex torch.tensor or np.ndarray
        Exit surface wave functions as a pytorch tensor or numpy array (default)
        depending on whether return_numpy is True or False. If the input `probes`
        is two dimensional then n = 1
    &#34;&#34;&#34;
    # If a single integer is passed to the routine then Seed random number generator,
    # , if None then np.random.RandomState will use the system clock as a seed
    seed_provided = not (seed is None)
    if not seed_provided:
        r = np.random.RandomState()
        np.random.seed(seed)

    # Initialize device cuda if available, CPU if no cuda is available
    device = get_device(device_type)

    # Since pytorch doesn&#39;t have a complex data type we need to add an extra
    # dimension of size 2 to each tensor that will store real and imaginary
    # components.
    T = ensure_torch_array(transmission_functions, device=device)
    P = ensure_torch_array(propagators, dtype=T.dtype, device=device)
    psi = ensure_torch_array(probes, dtype=T.dtype, device=device)

    nT, nsubslices, nopiy, nopix = T.shape[:4]

    # Probe needs to start multislice algorithm in real space
    if qspace_in:
        psi = torch.ifft(psi, signal_ndim=2)

    slices = generate_slice_indices(nslices, nsubslices, subslicing)

    for i, islice in enumerate(slices):

        # If an array-like object is passed then this will be used to uniquely
        # and reproducibly seed each iteration of the multislice algorithm
        if seed_provided:
            r = np.random.RandomState(seed[islice])

        subslice = islice % nsubslices

        # Pick random phase grating
        it = r.randint(0, nT)

        # To save memory in the case of equally sliced sample, there is the option
        # of only using one propagator, this statement catches this case.
        if P.dim() &lt; 4:
            P_ = P
        else:
            P_ = P[subslice]

        # If the transmission function is from a tiled unit cell then
        # there is the option of randomly shifting it around to
        # generate &#34;more&#34; psuedo-random transmission functions
        if tiling[0] == 1 &amp; tiling[1] == 1:
            T_ = T[it, subslice]
        elif nopiy % tiling[0] == 0 and nopix % tiling[1] == 0:

            T_ = T[it, subslice]
            if tiling[0] &gt; 1:
                # Shift an integer number of pixels in y
                T_ = roll_n(T_, 0, r.randint(0, tiling[0]) * (nopiy // tiling[0]))
            if tiling[1] &gt; 1:
                # Shift an integer number of pixels in x
                T_ = roll_n(T_, 1, r.randint(1, tiling[1]) * (nopix // tiling[1]))
        else:
            # Case of a non-integer pixel shifting of the unit cell
            yshift = r.randint(0, tiling[0]) * (nopiy / tiling[0])
            xshift = r.randint(0, tiling[1]) * (nopix / tiling[1])
            shift = torch.tensor([yshift, xshift])

            # Generate an array to perform Fourier shift of transmission
            # function
            FFT_shift_array = fourier_shift_array(
                [nopiy, nopix], shift, dtype=T.dtype, device=T.device
            )

            # Apply Fourier shift theorem for sub-pixel shift
            T_ = torch.ifft(
                complex_mul(FFT_shift_array, torch.fft(T[it, subslice], signal_ndim=2)),
                signal_ndim=2,
            )

        # Perform multislice iteration
        if transpose or reverse:
            # Reverse multislice complex conjugates the transmission and
            # propagation. Both reverse and transpose multislice reverse
            # the order of the transmission and conjugation operations
            # probe should start in real space and finish this iteration in
            # real space
            psi = complex_mul(
                torch.ifft(
                    complex_mul(torch.fft(psi, signal_ndim=2), P_, reverse),
                    signal_ndim=2,
                ),
                T_,
                reverse,
            )
        else:
            # Standard multislice iteration - probe should start in real space
            # and finish this iteration in reciprocal space
            psi = complex_mul(torch.fft(complex_mul(psi, T_), signal_ndim=2), P_)

        # The probe can be cropped to the bandwidth limit, this removes
        # superfluous array entries in reciprocal space that are zero
        # Since the next inverse FFT will apply a factor equal to the
        # square root number of pixels we have to adjust the values
        # of the array to compensate
        if i == len(slices) - 1:
            lim = 2 / 3 if output_to_bandwidth_limit else 1
            psi = crop_to_bandwidth_limit_torch(
                psi,
                qspace_in=not (transpose or reverse),
                qspace_out=qspace_out,
                limit=lim,
                norm=&#34;conserve_norm&#34;,
            )
        elif not (transpose or reverse):
            # Inverse Fourier transform back to real space for next iteration
            psi = torch.ifft(psi, signal_ndim=2)

    if len(slices) &lt; 1 and qspace_out:
        psi = torch.fft(psi, signal_ndim=2)

    if return_numpy:
        return cx_to_numpy(psi)
    return psi</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.nyquist_sampling"><code class="name flex">
<span>def <span class="ident">nyquist_sampling</span></span>(<span>rsize=None, resolution_limit=None, eV=None, alpha=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate nyquist sampling (typically for minimum sampling of a STEM probe).</p>
<p>If array size in units of length is passed then return how many probe
positions are required otherwise just return the sampling. Alternatively
pass probe accelerating voltage (eV) in electron-volts and probe forming
aperture (alpha) in mrad and the resolution limit in inverse length will be
calculated for you.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nyquist_sampling(rsize=None, resolution_limit=None, eV=None, alpha=None):
    &#34;&#34;&#34;
    Calculate nyquist sampling (typically for minimum sampling of a STEM probe).

    If array size in units of length is passed then return how many probe
    positions are required otherwise just return the sampling. Alternatively
    pass probe accelerating voltage (eV) in electron-volts and probe forming
    aperture (alpha) in mrad and the resolution limit in inverse length will be
    calculated for you.
    &#34;&#34;&#34;
    if eV is None and alpha is None:
        step_size = 1 / (4 * resolution_limit)
    elif resolution_limit is None:
        step_size = 1 / (4 * wavev(eV) * alpha * 1e-3)
    else:
        return None

    if rsize is None:
        return step_size
    else:
        return np.ceil(rsize / step_size).astype(np.int)</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.phase_from_com"><code class="name flex">
<span>def <span class="ident">phase_from_com</span></span>(<span>com, reg=1e-10, rsize=[1, 1])</span>
</code></dt>
<dd>
<div class="desc"><p>Integrate 4D-STEM centre of mass (DPC) measurements to calculate object phase.</p>
<p>Assumes a three dimensional array com, with the final two dimensions
corresponding to the image and the first dimension of the array corresponding
to the y and x centre of mass respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phase_from_com(com, reg=1e-10, rsize=[1, 1]):
    &#34;&#34;&#34;
    Integrate 4D-STEM centre of mass (DPC) measurements to calculate object phase.

    Assumes a three dimensional array com, with the final two dimensions
    corresponding to the image and the first dimension of the array corresponding
    to the y and x centre of mass respectively.
    &#34;&#34;&#34;
    # Get shape of arrays
    ny, nx = com.shape[1:]
    s = (ny, nx)

    d = np.asarray(rsize) / np.asarray([ny, nx])
    # Calculate Fourier coordinates for array
    ky = np.fft.fftfreq(ny, d=d[0])
    kx = np.fft.rfftfreq(nx, d=d[1])

    # Calculate numerator and denominator expressions for solution of
    # phase from centre of mass measurements
    numerator = ky[:, None] * np.fft.rfft2(com[0], s=s) + kx[None, :] * np.fft.rfft2(
        com[1], s=s
    )
    denominator = 1j * ((kx ** 2)[None, :] + (ky ** 2)[:, None]) + reg

    # Avoid a divide by zero for the origin of the Fourier coordinates
    numerator[0, 0] = 0
    denominator[0, 0] = 1

    # Return real part of the inverse Fourier transform
    return np.fft.irfft2(numerator / denominator, s=s)</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.second_moment"><code class="name flex">
<span>def <span class="ident">second_moment</span></span>(<span>array)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the second moment of 2D array as a fraction of array size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def second_moment(array):
    &#34;&#34;&#34;Calculate the second moment of 2D array as a fraction of array size.&#34;&#34;&#34;
    grids = [np.fft.fftfreq(x) for x in array.shape]
    mass = np.sum(array)
    first_moment = [
        np.sum(x) / mass for x in [grids[0][:, None] * array, grids[1][None, :] * array]
    ]

    y2 = ((grids[0] - first_moment[0] + 0.5) % 1.0 - 0.5) ** 2
    x2 = ((grids[1] - first_moment[1] + 0.5) % 1.0 - 0.5) ** 2
    grid = y2[:, None] + x2[None, :]

    return np.sqrt(np.sum(grid * array) / mass)</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.thickness_to_slices"><code class="name flex">
<span>def <span class="ident">thickness_to_slices</span></span>(<span>thicknesses, slice_thickness, subslicing=False, subslices=[1.0])</span>
</code></dt>
<dd>
<div class="desc"><p>Convert thickness in Angstroms to number of multislice slices.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thickness_to_slices(
    thicknesses, slice_thickness, subslicing=False, subslices=[1.0]
):
    &#34;&#34;&#34;Convert thickness in Angstroms to number of multislice slices.&#34;&#34;&#34;
    t = np.asarray(ensure_array(thicknesses))
    if subslicing:
        # Work out how many slice of the structure is closest to the desired
        # output thicknesses
        m = len(subslices)
        nslices = (t // slice_thickness).astype(np.int) * m
        from scipy.spatial.distance import cdist

        # Work out which subslices of the structure
        remainder = (t % slice_thickness) / slice_thickness
        n = len(remainder)
        dist = cdist(
            remainder.reshape((n, 1)),
            np.concatenate(([0], subslices[:-1])).reshape((m, 1)),
        )
        z = [0] + (nslices + np.asarray([i for i in np.argmin(dist, axis=1)])).tolist()
        return [np.arange(z[i], z[i + 1]) for i in range(len(z) - 1)]
    else:
        return np.ceil(t / slice_thickness).astype(np.int)</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.tqdm_handler"><code class="name flex">
<span>def <span class="ident">tqdm_handler</span></span>(<span>showProgress)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle showProgress boolean or string input for the tqdm progress bar.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tqdm_handler(showProgress):
    &#34;&#34;&#34;Handle showProgress boolean or string input for the tqdm progress bar.&#34;&#34;&#34;
    if isinstance(showProgress, str):
        if showProgress == &#34;notebook&#34;:
            from tqdm import tqdm_notebook as tqdm
        tdisable = False
    elif isinstance(showProgress, bool):
        tdisable = not showProgress
        from tqdm import tqdm
    return tdisable, tqdm</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.unit_cell_shift"><code class="name flex">
<span>def <span class="ident">unit_cell_shift</span></span>(<span>array, axis, shift, tiles)</span>
</code></dt>
<dd>
<div class="desc"><p>Shift an array an integer number of unit cell.</p>
<p>For an array consisting of a number of repeat units given by tiles
shift than array an integer number of unit cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit_cell_shift(array, axis, shift, tiles):
    &#34;&#34;&#34;
    Shift an array an integer number of unit cell.

    For an array consisting of a number of repeat units given by tiles
    shift than array an integer number of unit cells.
    &#34;&#34;&#34;
    indices = torch.remainder(torch.arange(array.shape[-3 + axis]) - shift)
    if axis == 0:
        return array[indices, :, :]
    if axis == 1:
        return array[:, indices, :]</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.workout_4DSTEM_datacube_DP_size"><code class="name flex">
<span>def <span class="ident">workout_4DSTEM_datacube_DP_size</span></span>(<span>FourD_STEM, rsize, gridshape)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate 4D-STEM datacube diffraction pattern gridsize and resampling function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fourD_STEM</code></strong> :&ensp;<code>bool</code> or <code>array_like</code></dt>
<dd>Pass fourD_STEM = True gives 4D STEM output with native simulation grid
sampling. Alternatively, to save disk space a tuple containing pixel
size and diffraction space extent of the datacube can be passed in. For
example ([64,64],[1.2,1.2]) will output diffraction patterns measuring
64 x 64 pixels and 1.2 x 1.2 inverse Angstroms.</dd>
<dt><strong><code>rsize</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Real space size of simulation grid</dd>
<dt><strong><code>gridshape</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Pixel size of gridshape</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>gridout</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Pixel size of the diffraciton pattern output</dd>
<dt><strong><code>resize</code></strong> :&ensp;<code>function</code></dt>
<dd>A function that takes diffraction patterns from the simulation and
resamples and crops them to the requested size.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def workout_4DSTEM_datacube_DP_size(FourD_STEM, rsize, gridshape):
    &#34;&#34;&#34;
    Calculate 4D-STEM datacube diffraction pattern gridsize and resampling function.

    Parameters
    ----------
    fourD_STEM : bool or array_like
        Pass fourD_STEM = True gives 4D STEM output with native simulation grid
        sampling. Alternatively, to save disk space a tuple containing pixel
        size and diffraction space extent of the datacube can be passed in. For
        example ([64,64],[1.2,1.2]) will output diffraction patterns measuring
        64 x 64 pixels and 1.2 x 1.2 inverse Angstroms.
    rsize : (2,) array_like
        Real space size of simulation grid
    gridshape : (2,) array_like
        Pixel size of gridshape

    Returns
    -------
    gridout : (2,) array_like
        Pixel size of the diffraciton pattern output
    resize : function
        A function that takes diffraction patterns from the simulation and
        resamples and crops them to the requested size.
    &#34;&#34;&#34;
    # Check whether a resampling directive has been given
    if isinstance(FourD_STEM, (list, tuple)):
        gridout = FourD_STEM[0]

        if len(FourD_STEM) &gt; 1:
            # Get output grid and diffraction space size of that grid from tuple
            Ksize = FourD_STEM[1]

            #
            diff_pat_crop = np.round(np.asarray(Ksize) * np.asarray(rsize[:2])).astype(
                np.int
            )

            # Define resampling function to crop and interpolate
            # diffraction patterns
            def resize(array):
                cropped = crop(np.fft.fftshift(array, axes=(-1, -2)), diff_pat_crop)
                return fourier_interpolate_2d(cropped, gridout, norm=&#34;conserve_L1&#34;)

        else:
            # The size in inverse Angstrom of the grid
            Ksize = np.asarray(gridout) / np.asarray(rsize)

            # Define resampling function to just crop diffraction
            # patterns
            def resize(array):
                return crop(np.fft.fftshift(array, axes=(-1, -2)), gridout)

    else:
        # If no resampling then the output size is just the simulation
        # grid size
        gridout = size_of_bandwidth_limited_array(gridshape)

        # The size in inverse Angstrom of the grid
        Ksize = np.asarray(gridout) / np.asarray(rsize)

        # Define a resampling function that does nothing
        def resize(array):
            return crop(np.fft.fftshift(array, axes=(-1, -2)), gridout)

    return gridout, resize, Ksize</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyms.py_multislice.scattering_matrix"><code class="flex name class">
<span>class <span class="ident">scattering_matrix</span></span>
<span>(</span><span>rsize, propagators, transmission_functions, nslice, eV, alpha, GPU_streaming=False, batch_size=30, device=None, PRISM_factor=[1, 1], tiling=[1, 1], device_type=None, seed=None, showProgress=True, bandwidth_limit=0.6666666666666666, Fourier_space_output=False, subslicing=False, transposed=False, stored_gridshape=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Scattering matrix object for calculations using the PRISM algorithm.</p>
<p>Initialize a scattering matrix.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rsize</code></strong> :&ensp;<code>(2,) array_like</code></dt>
<dd>Real space size of the simulation grid in Angstrom</dd>
<dt><strong><code>propagators</code></strong> :&ensp;<code>(N,Y,X,2) torch.array</code></dt>
<dd>Fresnel free space operators required for the multislice algorithm
used to propagate the scattering matrix</dd>
<dt><strong><code>transmission_functions</code></strong> :&ensp;<code>(N,Y,X,2)</code></dt>
<dd>The transmission functions describing the electron's interaction
with the specimen for the multislice algorithm</dd>
<dt><strong><code>nslice</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of slices of the specimen to propagate the scattering
matrix to</dd>
<dt><strong><code>eV</code></strong> :&ensp;<code>float</code></dt>
<dd>Electron probe energy in electron-volts</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum input angle for the scattering matrix, should match the
probe forming aperture used in experiment</dd>
</dl>
<h2 id="keyword-arguments">Keyword Arguments</h2>
<p>GPU_streaming : bool, optional
If True, the scattering matrix will be stored off GPU RAM and
streamed to GPU RAM as necessary, does nothing if the calculation
is CPU only
batch_size : int, optional
The multislice algorithm can be performed on multiple scattering
matrix columns at once to parrallelize computation, this number is
set by batch_size.
device : torch.device, optional
torch.device object which will determine which device (CPU or GPU)
the calculations will run on. By default this will be determined
by what device the transmission functions are stored on.
PRISM_factor : int (2,) array_like
The PRISM "interpolation factor" this is the amount by which the
scattering matrices are cropped in real space to speed up
calculations see Ophus, Colin. "A fast image simulation algorithm
for scanning transmission electron microscopy." Advanced structural
and chemical imaging 3.1 (2017): 13 for details on this.
seed : int32, optional
A seed to control seeding of the frozen phonon approximation
showProgress : bool, optional
Pass showProgress = False to disable live progress readout
bandwidth_limit : float, optional
Band-width limiting of the transmission function and propagators to
prevent wrap-around error in the multislice algorithm, 2/3 by
default
Fourier_space_output : bool, optional
If True the scattering matrix output will be stored in reciprocal
space, default is False
subslicing : bool, optional
Pass subslicing=True to access propagation to sub-slices of the
unit cell, in this case nslices is taken to be in units of subslices
to propagate rather than unit cells (i.e. nslices = 3 will propagate
1.5 unit cells for a subslicing of 2 subslices per unit cell)
transposed : bool, optional
Make a "transposed" scattering matrix - see Brown et al. (2019)
Physical Review Research paper for a discussion of this and its
applications
stored_gridshape : (2,) array_like
Size of the stored grid, can be chosen to be smaller than the
multislice grid to speed up computation of a smaller diffraction
space view than that implied by the multislice at no cost to
computational accuracy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class scattering_matrix:
    &#34;&#34;&#34;Scattering matrix object for calculations using the PRISM algorithm.&#34;&#34;&#34;

    def __init__(
        self,
        rsize,
        propagators,
        transmission_functions,
        nslice,
        eV,
        alpha,
        GPU_streaming=False,
        batch_size=30,
        device=None,
        PRISM_factor=[1, 1],
        tiling=[1, 1],
        device_type=None,
        seed=None,
        showProgress=True,
        bandwidth_limit=2 / 3,
        Fourier_space_output=False,
        subslicing=False,
        transposed=False,
        stored_gridshape=None,
    ):
        &#34;&#34;&#34;Initialize a scattering matrix.

        Parameters
        ----------
        rsize : (2,) array_like
            Real space size of the simulation grid in Angstrom
        propagators : (N,Y,X,2) torch.array
            Fresnel free space operators required for the multislice algorithm
            used to propagate the scattering matrix
        transmission_functions : (N,Y,X,2)
            The transmission functions describing the electron&#39;s interaction
            with the specimen for the multislice algorithm
        nslice : int
            The number of slices of the specimen to propagate the scattering
            matrix to
        eV : float
            Electron probe energy in electron-volts
        alpha : float
            Maximum input angle for the scattering matrix, should match the
            probe forming aperture used in experiment

        Keyword arguments
        -----------------
        GPU_streaming : bool, optional
            If True, the scattering matrix will be stored off GPU RAM and
            streamed to GPU RAM as necessary, does nothing if the calculation
            is CPU only
        batch_size : int, optional
            The multislice algorithm can be performed on multiple scattering
            matrix columns at once to parrallelize computation, this number is
            set by batch_size.
        device : torch.device, optional
            torch.device object which will determine which device (CPU or GPU)
            the calculations will run on. By default this will be determined
            by what device the transmission functions are stored on.
        PRISM_factor : int (2,) array_like
            The PRISM &#34;interpolation factor&#34; this is the amount by which the
            scattering matrices are cropped in real space to speed up
            calculations see Ophus, Colin. &#34;A fast image simulation algorithm
            for scanning transmission electron microscopy.&#34; Advanced structural
            and chemical imaging 3.1 (2017): 13 for details on this.
        seed : int32, optional
            A seed to control seeding of the frozen phonon approximation
        showProgress : bool, optional
            Pass showProgress = False to disable live progress readout
        bandwidth_limit : float, optional
            Band-width limiting of the transmission function and propagators to
            prevent wrap-around error in the multislice algorithm, 2/3 by
            default
        Fourier_space_output : bool, optional
            If True the scattering matrix output will be stored in reciprocal
            space, default is False
        subslicing : bool, optional
            Pass subslicing=True to access propagation to sub-slices of the
            unit cell, in this case nslices is taken to be in units of subslices
            to propagate rather than unit cells (i.e. nslices = 3 will propagate
            1.5 unit cells for a subslicing of 2 subslices per unit cell)
        transposed : bool, optional
            Make a &#34;transposed&#34; scattering matrix - see Brown et al. (2019)
            Physical Review Research paper for a discussion of this and its
            applications
        stored_gridshape : (2,) array_like
            Size of the stored grid, can be chosen to be smaller than the
            multislice grid to speed up computation of a smaller diffraction
            space view than that implied by the multislice at no cost to
            computational accuracy.
        &#34;&#34;&#34;
        # Get size of grid
        gridshape = transmission_functions.shape[-3:-1]

        # Datatype (precision) is inferred from transmission functions
        self.dtype = transmission_functions.dtype

        # Device (CPU or GPU) is also inferred from transmission functions
        self.device = device
        if GPU_streaming:
            self.device = torch.device(&#34;cpu&#34;)
        elif self.device is None:
            self.device = transmission_functions.device

        # Get alpha in units of inverse Angstrom
        self.alpha_ = wavev(eV) * alpha * 1e-3

        self.PRISM_factor = PRISM_factor
        self.doPRISM = np.any(np.asarray(PRISM_factor) &gt; 1)

        # Make a list of beams in the scattering matrix
        # Take beams inside the aperture and every nth beam where n is the
        # PRISM &#34;interpolation&#34; factor
        q = q_space_array(gridshape, rsize)
        inside_aperture = np.less_equal(q[0] ** 2 + q[1] ** 2, self.alpha_ ** 2)
        mody, modx = [
            np.mod(np.fft.fftfreq(x, 1 / x).astype(np.int), p) == 0
            for x, p in zip(gridshape, self.PRISM_factor)
        ]
        self.beams = np.nonzero(
            np.logical_and(
                np.logical_and(inside_aperture, mody[:, None]), modx[None, :]
            )
        )
        self.beams = [(x + y // 2) % y - y // 2 for x, y in zip(self.beams, gridshape)]

        self.nbeams = len(self.beams[0])

        # For a scattering matrix stored in real space there is the option
        # of storing it on a much smaller pixel grid than the grid used for
        # multislice. This is handy when, for example, a large grid
        # is required for a converged multislice calculation but only
        # the bright-field region of diffraction (small angle region)
        # is of interest. Be careful using this in conjunction with
        # multiple calls of the propagation method for the scattering matrix,
        # as information outside the angular range of the stored grid is lost.
        self.crop_output = not (stored_gridshape is None)
        if self.crop_output:
            self.stored_gridshape = stored_gridshape

            # We will only store output of the scattering matrix up to the band
            # width limit of the calculation, since this is a circular band-width
            # limit on a square grid we have to get somewhat fancy and store a mapping
            # of the pixels within the bandwidth limit to a one-dimensional vector
            self.bw_mapping = np.argwhere(
                np.logical_and(
                    (
                        np.abs(np.fft.fftfreq(gridshape[0], d=1 / gridshape[0]))
                        &lt; self.stored_gridshape[0] // 2
                    )[:, np.newaxis],
                    (
                        np.abs(np.fft.fftfreq(gridshape[1], d=1 / gridshape[1]))
                        &lt; self.stored_gridshape[1] // 2
                    )[np.newaxis, :],
                )
            )

        else:
            self.stored_gridshape = size_of_bandwidth_limited_array(
                transmission_functions.shape[-3:-1]
            )

            # We will only store output of the scattering matrix up to the band
            # width limit of the calculation, since this is a circular band-width
            # limit on a square grid we have to get somewhat fancy and store a mapping
            # of the pixels within the bandwidth limit to a one-dimensional vector
            self.bw_mapping = np.argwhere(
                (np.fft.fftfreq(gridshape[0]) ** 2)[:, np.newaxis]
                + (np.fft.fftfreq(gridshape[1]) ** 2)[np.newaxis, :]
                &lt; (bandwidth_limit / 2) ** 2
            )

        self.nbout = self.bw_mapping.shape[0]

        self.gridshape, self.rsize, self.eV = [np.asarray(gridshape), rsize, eV]
        self.bw_mapping = (
            self.bw_mapping + self.gridshape // 2
        ) % self.gridshape - self.gridshape // 2
        self.PRISM_factor, self.tiling = [PRISM_factor, tiling]
        self.doPRISM = np.any([self.PRISM_factor[i] &gt; 1 for i in [0, 1]])
        self.Fourier_space_output = Fourier_space_output
        self.nsubslices = transmission_functions.shape[1]
        slices = generate_slice_indices(nslice, self.nsubslices, subslicing=subslicing)
        self.GPU_streaming = GPU_streaming
        self.transposed = transposed

        self.seed = seed
        if self.seed is None:
            # If no seed passed to random number generator then make one to pass to
            # the multislice algorithm. This ensure that each column in the scattering
            # matrix sees the same frozen phonon configuration
            self.seed = np.random.randint(
                0, 2 ** 31 - 1, size=len(slices), dtype=np.uint32
            )

        # This switch tells the propagate function to initialize the Smatrix
        # to plane waves
        self.initialized = False
        # Propagate wave functions of scattering matrix
        self.current_slice = 0
        self.show_Progress = showProgress
        self.Propagate(
            nslice,
            propagators,
            transmission_functions,
            subslicing=subslicing,
            showProgress=self.show_Progress,
            batch_size=batch_size,
        )

    def Propagate(
        self,
        nslice,
        propagators,
        transmission_functions,
        subslicing=False,
        batch_size=3,
        showProgress=True,
        transpose=False,
    ):
        &#34;&#34;&#34;
        Propagate a scattering matrix to slice nslice of the specimen.

        Parameters
        ----------
        nslice : int
            The slice in the specimen to propagate the scattering matrix to
        propagators : (N,Y,X,2) torch.array
            Fresnel free space operators required for the multislice algorithm
            used to propagate the scattering matrix
        transmission_functions : (N,Y,X,2)
            The transmission functions describing the electron&#39;s interaction
            with the specimen for the multislice algorithm

        Keyword arguments
        -----------------
        batch_size : int, optional
            The multislice algorithm can be performed on multiple scattering
            matrix columns at once to parrallelize computation, this number is
            set by batch_size.
        subslicing : bool, optional
            Pass subslicing=True to access propagation to sub-slices of the
            unit cell, in this case nslices is taken to be in units of subslices
            to propagate rather than unit cells (i.e. nslices = 3 will propagate
            1.5 unit cells for a subslicing of 2 subslices per unit cell)
        showProgress : bool, optional
            Pass showProgress = False to disable live progress readout
        transpose : bool, optional
            Make a &#34;transposed&#34; scattering matrix - see Brown et al. (2019)
            Physical Review Research paper for a discussion of this and its
            applications
        &#34;&#34;&#34;
        from .Probe import plane_wave_illumination

        # Initialize scattering matrix if necessary
        if not self.initialized:
            if self.Fourier_space_output:
                self.S = torch.zeros(
                    self.nbeams, self.nbout, 2, dtype=self.dtype, device=self.device
                )
            else:
                self.S = torch.zeros(
                    self.nbeams,
                    *self.stored_gridshape,
                    2,
                    dtype=self.dtype,
                    device=self.device
                )
            for ibeam in range(self.nbeams):
                # Initialize S-matrix to plane-waves
                psi = cx_from_numpy(
                    plane_wave_illumination(
                        self.gridshape,
                        self.rsize[:2],
                        self.eV,
                        tilt=[self.beams[0][ibeam], self.beams[1][ibeam]],
                        tilt_units=&#34;pixels&#34;,
                        qspace=True,
                    )
                )

                # Adjust intensity for correct normalization of S matrix rows
                # taking into account the PRISM factor that needs to be applied
                # when the Smatrix is evaluated (only 1/product(PRISM_factor)
                # beams are taken and only 1/product(PRISM_factor) intensity
                # is cropped out in real space)
                psi *= torch.prod(torch.tensor(self.PRISM_factor, dtype=self.dtype))

                if self.Fourier_space_output:
                    self.S[ibeam] = psi[self.bw_mapping[:, 0], self.bw_mapping[:, 1], :]
                else:
                    self.S[ibeam] = fourier_interpolate_2d_torch(
                        psi,
                        self.stored_gridshape,
                        qspace_in=True,
                        qspace_out=False,
                        norm=&#34;conserve_norm&#34;,
                    )
            self.initialized = True

        # Make nslice_ which always accounts of subslices of the cyrstal structure
        if subslicing:
            nslice_ = nslice
        else:
            nslice_ = nslice * self.nsubslices

        # Work out direction of propagation through specimen
        if nslice_ != self.current_slice:
            direction = np.sign(nslice_ - self.current_slice)
        else:
            direction = 1

        if direction == 0:
            direction = 1

        if nslice_ &gt; len(self.seed):
            # Add new seeds to determine random translations for frozen-phonon
            # multislice (required for reversability of multislice) if required
            self.seed = np.concatenate(
                [
                    self.seed,
                    np.random.randint(0, 2 ** 31 - 1, size=nslice_ - len(self.seed)),
                ]
            )

        # Now generate list of slices that the multislice algorithm will run through
        slices = np.arange(self.current_slice, nslice_, direction)
        if direction &lt; 0:
            slices += direction

        # For a transposed scattering matrix the order of the slices
        # in multislice should be reversed
        if self.transposed:
            slices = slices[::-1]

        # If streaming of Smatrix columns to the GPU is being used, ensure
        # that propagators and transmission functions for the multislice are
        # already on the GPU
        if self.GPU_streaming:
            propagators = ensure_torch_array(propagators).cuda()
            transmission_functions = ensure_torch_array(transmission_functions).cuda()

        self.current_slice = nslice_
        if len(slices) &lt; 1:
            return

        # Loop over the different plane wave components (or columns) of the
        # scattering matrix
        for i in tqdm(
            range(int(np.ceil(self.nbeams / batch_size))),
            disable=not showProgress,
            desc=&#34;Calculating S-matrix&#34;,
        ):
            # Initialize array that will be used as input to the multislice routine
            psi = torch.zeros(
                batch_size, *self.gridshape, 2, dtype=self.dtype, device=self.device
            )
            beams = np.arange(
                i * batch_size, min((i + 1) * batch_size, self.nbeams), dtype=np.int
            )

            if self.Fourier_space_output:
                # Expand S-matrix input to full grid for multislice propagation
                psi[
                    : beams.shape[0], self.bw_mapping[:, 0], self.bw_mapping[:, 1], :
                ] = self.S[beams]
            else:
                # Fourier interpolate stored real space S-matrix column onto
                # multislice grid
                psi = fourier_interpolate_2d_torch(
                    self.S[beams], self.gridshape, norm=&#34;conserve_norm&#34;
                )

            if self.GPU_streaming:
                psi = ensure_torch_array(psi, dtype=self.dtype).to(&#34;cuda&#34;)

            output = multislice(
                psi[: beams.shape[0]],
                slices,
                propagators,
                transmission_functions,
                self.tiling,
                self.device,
                self.seed,
                return_numpy=False,
                qspace_in=self.Fourier_space_output,
                qspace_out=self.Fourier_space_output,
                transpose=self.transposed,
                output_to_bandwidth_limit=False,
                reverse=direction &lt; 0,
            )

            if self.GPU_streaming:
                output = output.to(self.device)

            if self.Fourier_space_output:

                self.S[beams] = output[
                    :, self.bw_mapping[:, 0], self.bw_mapping[:, 1], :
                ] * np.sqrt(np.prod(self.stored_gridshape) / np.prod(self.gridshape))
            else:
                output = fourier_interpolate_2d_torch(
                    output, self.stored_gridshape, norm=&#34;conserve_norm&#34;
                )
                self.S[beams] = output

    def PRISM_crop_window(self, win=None, device=None):
        &#34;&#34;&#34;Calculate 2D array indices of STEM crop window.&#34;&#34;&#34;
        device = get_device(device)
        if win is None:
            win = self.PRISM_factor

        crop_ = [
            torch.arange(
                -self.stored_gridshape[i] // (2 * win[i]),
                self.stored_gridshape[i] // (2 * win[i]),
                device=device,
            )
            for i in range(2)
        ]
        return crop_

    def __call__(self, probes, nslices, posn=None, Smat=None, scan_transform=None):
        &#34;&#34;&#34;
        Calculate exit-surface waves function using the scattering matrix.

        Parameters
        ----------
        probes : (N,Y,X,2) torch.array
            Input wave functions to calculate exit surface wave functions from
            must be in Diffraction space
        nslices :
            Does nothing, only there to match call signature for STEM routine
        posn : array_like (N,2)
            Positions of
        S : array_like (Nbeams,Y,X,2)
            Scattering matrix object

        Returns
        -------
        output : (N,Y,X,2) torch.array
            Exit surface wave functions
        &#34;&#34;&#34;
        from copy import deepcopy

        if Smat is None:
            Smat = self.S
        Sshape = [int(x) for x in Smat.shape]

        device = Smat.device
        crop_ = self.PRISM_crop_window(device=device)
        # Ensure posn and probes are pytorch arrays
        probes = ensure_torch_array(probes, dtype=self.dtype, device=device)

        # Ensure probes tensors correspond to the shape N x Y x X x 2
        # If they have the shape Y x X x 2 then reshape to 1 x Y x X x 2
        if probes.ndim &lt; 4:
            probes = probes.view(1, *probes.shape)

        # Get number of probes
        nprobes = probes.shape[0]

        if posn is None:
            posn = torch.zeros(nprobes, 2, device=device, dtype=self.dtype)
        else:
            posn = torch.as_tensor(posn, device=device, dtype=self.dtype).view(
                (nprobes, 2)
            )

        if scan_transform is not None:
            posn = scan_transform(posn)

        # TODO decide whether to remove the Fourier_space_output option
        if self.Fourier_space_output:

            # A note on normalization: an individual probe enters the STEM routine
            # with sum_squared intensity of 1, but the STEM routine applies an
            # FFT so the sum_squared intensity is now equal to # pixels
            # For a correct matrix multiplication we must now divide by sqrt(# pixels)
            probe_vec = complex_matmul(
                probes[:, self.beams[0], self.beams[1]], Smat
            ) / np.sqrt(np.prod(self.gridshape))

            # Now reshape output from vectors to square arrays
            probes = torch.zeros(
                nprobes, *self.stored_gridshape, 2, dtype=self.dtype, device=self.device
            )
            probes[:, self.bw_mapping[:, 0], self.bw_mapping[:, 1], :] = probe_vec

            # Apply PRISM cropping in real space if appropriate
            if self.doPRISM:
                shape = probes.size()

                probes = torch.ifft(probes, signal_ndim=2).flatten(-3, -2)
                for k in range(nprobes):

                    # Calculate windows in vertical and horizontal directions
                    window = crop_window_to_flattened_indices_torch(
                        [
                            (crop_[i] + posn[k, i] * self.stored_gridshape[i])
                            % self.stored_gridshape[i]
                            for i in range(2)
                        ],
                        self.stored_gridshape,
                    )
                    probe = deepcopy(probes[k])
                    probes[k] = 0
                    probes[k, window, :] = probe[window, :]

                probes = probes.reshape(shape)

                # Transform probe back to Fourier space
                return torch.fft(probes, signal_ndim=2)

            return probes
        else:
            # Flatten the array dimensions
            Smatshape = Smat.shape
            flattened_shape = [Smatshape[0], Smatshape[-3] * Smatshape[-2], 2]
            N = probes.shape[0]
            output = torch.zeros(
                N, *Smat.shape[-3:-1], 2, dtype=self.dtype, device=Smat.device
            )

            # For evaluating the probes in real space we only want to perform the matrix
            # multiplication and summation within the real space PRISM cropping region

            stride = [x // y for x, y in zip(self.stored_gridshape, self.PRISM_factor)]
            halfstride = [x // 2 for x in stride]

            # for k in range(probes.size(0)):
            for probe, pos, out in zip(probes, posn, output):

                if self.doPRISM:
                    start = [
                        int(torch.round(pos[i] * Sshape[-3 + i])) - halfstride[i]
                        for i in range(2)
                    ]
                    windows = crop_window_to_periodic_indices(
                        [start[0], stride[0], start[1], stride[1]], Sshape[-3:-1]
                    )

                    for wind in windows:
                        outview = out.narrow(-3, wind[0][0], wind[0][1]).narrow(
                            -2, wind[1][0], wind[1][1]
                        )
                        sview = Smat.narrow(-3, wind[0][0], wind[0][1]).narrow(
                            -2, wind[1][0], wind[1][1]
                        )
                        p = probe[self.beams[0], self.beams[1]].view(
                            self.nbeams, 1, 1, 2
                        )
                        outview += torch.sum(complex_mul(p, sview), axis=0)
                else:
                    output += complex_matmul(
                        probe[self.beams[0], self.beams[1]], Smat.view(flattened_shape)
                    ).view(Smatshape[1:])

            output /= np.sqrt(np.prod(probes.size()[-3:-1]))
            output = crop_torch(
                output.reshape(probes.size(0), *Smat.size()[-3:]), self.stored_gridshape
            )

            return torch.fft(output, signal_ndim=2)

    def STEM_with_GPU_streaming(
        self,
        detectors=None,
        FourD_STEM=None,
        datacube=None,
        STEM_image=None,
        nstreams=None,
        df=0,
        aberrations=[],
        ROI=[0.0, 0.0, 1.0, 1.0],
        device=None,
        scan_posns=None,
        showProgress=True,
    ):
        &#34;&#34;&#34;
        Perform STEM with scattering matrix streamed between RAM and GPU memory.

        This allows much larger fields of view to be calculated with relatively
        modest graphics card memory. The STEM raster is segmented into spatially
        close clusters and the probe positions in these clusters are processed
        sequentially, with the relevant part of the scattering matrix streamed
        from CPU to GPU memory.

        Parameters
        ----------
        self : scattering_matrix
            The scattering matrix object.
        detectors : (Ndet, Y, X) array_like, optional
            Diffraction plane detectors to perform conventional STEM imaging. If
            None is passed then no conventional STEM images will be returned.
        fourD_STEM : bool or array_like, optional
            Pass fourD_STEM = True to perform 4D-STEM simulations. To save disk
            space a tuple containing pixel size and diffraction space extent of the
            datacube can be passed in. For example ([64,64],[1.2,1.2]) will output
            diffraction patterns measuring 64 x 64 pixels and 1.2 x 1.2 inverse
            Angstroms.
        datacube :  (Ny, Nx, Y, X) array_like, optional
            datacube for 4D-STEM output, if None is passed (default) this will be
            initialized in the function. If a datacube is passed then the result
            will be added by the STEM routine (useful for multiple frozen phonon
            iterations)
        STEM_image : (Ndet,Ny,Nx) array_like, optional
            Array that will contain the conventional STEM images, if not passed
            will be initialized within the function. If it is passed then the result
            will be accumulated within the function, which is useful for multiple
            frozen phonon iterations.
        nstreams : int, optional
            Number of streams (seperate transfers from CPU to GPU memory). If
            None this will just be set to the product of the PRISM interpolation
            factor
        df : float, optional
            Defocus in Angstrom
        aberrations : list, optional
            A list containing a set of the class aberration, pass an empty list for
            an unaberrated contrast transfer function.
        ROI : (4,) array_like
            Fraction of the unit cell to be scanned. Should contain [y0,x0,y1,x1]
            where [x0,y0] and [x1,y1] are the bottom left and top right coordinates
            of the region of interest (ROI) expressed as a fraction of the total
            grid (or unit cell).
        device : torch.device, optional
            torch.device object which will determine which device (CPU or GPU) the
            calculations will run on.
        scan_posn :  (...,2) array_like, optional
            Array containing the STEM scan positions in fractional coordinates.
            If provided scan_posn.shape[:-1] will give the shape of the STEM
            image.
        showProgress : bool, optional
            Pass showProgress=False to disable progress bar.
        &#34;&#34;&#34;
        device = get_device(device)

        # Get indices of PRISM cropping window
        crop_ = [x.cpu().numpy() for x in self.PRISM_crop_window()]

        # Make the STEM probe
        probe = focused_probe(
            self.gridshape,
            self.rsize[:2],
            self.eV,
            self.alpha_,
            df=df,
            aberrations=aberrations,
            app_units=&#34;invA&#34;,
        )
        probe = cx_from_numpy(probe, device=device, dtype=self.dtype)

        # Make scan positions if none already provided
        if scan_posns is None:
            scan_posns = generate_STEM_raster(
                self.rsize, self.eV, self.alpha_, tiling=self.tiling, ROI=ROI, invA=True
            )
        # Get scan (and STEM image) array shape and total number of scan positions
        scan_shape = scan_posns.shape[:-1]
        nscan = np.product(scan_shape)

        # Flatten scan positions to simplify iteration later on.
        scan_posns = scan_posns.reshape((nscan, 2))

        # Calculate default 4D-STEM diffraction pattern sampling
        if FourD_STEM is True:
            GS = self.stored_gridshape
            FourD_STEM = [GS, GS / self.rsize[:2]]

        # Allocate diffraction pattern and STEM images if not already provided
        if FourD_STEM:
            gridout = workout_4DSTEM_datacube_DP_size(
                FourD_STEM, self.rsize, self.gridshape
            )[0]
        if (datacube is None) and FourD_STEM:
            datacube = np.zeros((*scan_shape, *gridout))
        if not FourD_STEM:
            datacube = None

        # If detectors are provided then we are doing conventional STEM
        doConventionalSTEM = detectors is not None

        # Initialize STEM images if not provided
        if doConventionalSTEM:
            ndet = detectors.shape[0]
            if STEM_image is None:
                STEM_image = np.zeros((ndet, nscan))
            else:
                STEM_image = STEM_image.reshape((ndet, nscan))
        else:
            STEM_image = None

        if nstreams is None:
            # If the number of seperate streams is not suggested by the
            # user, make this equal to the product of the PRISM factor
            nstreams = int(np.product(self.PRISM_factor))

        # Divide up the scan positions into clusters based on Euclidean
        # distance
        from sklearn.cluster import Birch

        if nscan &gt; 1:
            model = Birch(threshold=0.01, n_clusters=nstreams)
            yhat = model.fit_predict(scan_posns)
            clusters = np.unique(yhat)
        else:
            yhat, clusters = [[0], [0]]

        # Now do STEM with each of the scan position clusters, streaming
        # only the necessary bits of the scattering matrix to the GPU.
        Datacube_segment = None
        STEM_image_segment = None
        FlatS = self.S.reshape((self.nbeams, np.prod(self.stored_gridshape), 2))

        # Loop over probe positions clusters. This would be a good candidate
        # for multi-GPU work.
        for cluster in tqdm(
            clusters, desc=&#34;Probe position clusters&#34;, disable=not showProgress
        ):
            # Get map of probe positions in cluster
            points = np.nonzero(yhat == cluster)[0]
            npoints = len(points)

            # Get segments of images to update
            if doConventionalSTEM:
                STEM_image_segment = STEM_image[:, points]
            if FourD_STEM:
                Datacube_segment = np.zeros((1, npoints, 1, *gridout))
            pix_posn = scan_posns[points] * np.asarray(self.stored_gridshape)

            # Work out bounds of the rectangular region of the scattering
            # matrix to stream to the GPU
            ymin, ymax = [
                int(np.floor(np.amin(pix_posn[:, 0]) + crop_[0][0])),
                int(np.ceil(np.amax(pix_posn[:, 0]) + crop_[0][-1])),
            ]
            xmin, xmax = [
                int(np.floor(np.amin(pix_posn[:, 1]) + crop_[1][0])),
                int(np.ceil(np.amax(pix_posn[:, 1]) + crop_[1][-1])),
            ]
            size = np.asarray([(ymax - ymin), (xmax - xmin)])

            # Get indices of region of scattering matrix to stream to GPU
            window = [np.arange(a, b) for a, b in zip([ymin, xmin], [ymax, xmax])]
            indices = crop_window_to_flattened_indices_torch(
                window, self.stored_gridshape
            )

            # Get segment of the scattering matrix to stream to GPU
            segmentshape = [len(x) for x in window]
            SegmentS = FlatS[:, indices, :].reshape((self.nbeams, *segmentshape, 2))

            # Define a function that will map probe positions for the global
            # scattering matrix to their correct place on the smaller scattering
            # matrix streamed to the GPU.
            gshape = torch.as_tensor(self.stored_gridshape).to(device).type(self.dtype)
            Origin = torch.as_tensor([ymin, xmin]).to(device).type(self.dtype)
            segment_size = torch.as_tensor(size).to(device).type(self.dtype)

            def scan_transform(posn):
                return (posn * gshape - Origin) / segment_size

            # Keyword arguments to be passed to the __call__ function by the
            # STEM routine
            kwargs = {&#34;Smat&#34;: SegmentS.to(device), &#34;scan_transform&#34;: scan_transform}

            # Calculate STEM images
            STEM(
                self.rsize,
                probe,
                self.__call__,
                [1],
                self.eV,
                self.alpha_,
                detectors=detectors,
                FourD_STEM=FourD_STEM,
                datacube=Datacube_segment,
                scan_posn=scan_posns[points].reshape((npoints, 1, 2)),
                STEM_image=STEM_image_segment,
                method_kwargs=kwargs,
                showProgress=False,
                device=device,
            )

            if doConventionalSTEM:
                STEM_image[:, points] += STEM_image_segment
            if FourD_STEM:
                for point, Dp in zip(points, Datacube_segment[0]):
                    y, x = np.unravel_index(point, scan_shape)
                    datacube[y, x] += Dp[0]

        # Unflatten 4D-STEM datacube scan dimensions, use numpy squeeze to
        # remove superfluous dimensions (ones with length 1)
        # if FourD_STEM:
        #     datacube = datacube.reshape(*scan_shape, *datacube.shape[-2:])

        if doConventionalSTEM:
            STEM_image = np.squeeze(STEM_image.reshape(ndet, *scan_shape))

        # Return STEM images and datacube as a dictionary. If either of these
        # objects were not calculated the dictionary will contain None for those
        # entries.
        return {&#34;STEM images&#34;: STEM_image, &#34;datacube&#34;: datacube}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyms.py_multislice.scattering_matrix.PRISM_crop_window"><code class="name flex">
<span>def <span class="ident">PRISM_crop_window</span></span>(<span>self, win=None, device=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate 2D array indices of STEM crop window.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PRISM_crop_window(self, win=None, device=None):
    &#34;&#34;&#34;Calculate 2D array indices of STEM crop window.&#34;&#34;&#34;
    device = get_device(device)
    if win is None:
        win = self.PRISM_factor

    crop_ = [
        torch.arange(
            -self.stored_gridshape[i] // (2 * win[i]),
            self.stored_gridshape[i] // (2 * win[i]),
            device=device,
        )
        for i in range(2)
    ]
    return crop_</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.scattering_matrix.Propagate"><code class="name flex">
<span>def <span class="ident">Propagate</span></span>(<span>self, nslice, propagators, transmission_functions, subslicing=False, batch_size=3, showProgress=True, transpose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Propagate a scattering matrix to slice nslice of the specimen.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nslice</code></strong> :&ensp;<code>int</code></dt>
<dd>The slice in the specimen to propagate the scattering matrix to</dd>
<dt><strong><code>propagators</code></strong> :&ensp;<code>(N,Y,X,2) torch.array</code></dt>
<dd>Fresnel free space operators required for the multislice algorithm
used to propagate the scattering matrix</dd>
<dt><strong><code>transmission_functions</code></strong> :&ensp;<code>(N,Y,X,2)</code></dt>
<dd>The transmission functions describing the electron's interaction
with the specimen for the multislice algorithm</dd>
</dl>
<h2 id="keyword-arguments">Keyword Arguments</h2>
<p>batch_size : int, optional
The multislice algorithm can be performed on multiple scattering
matrix columns at once to parrallelize computation, this number is
set by batch_size.
subslicing : bool, optional
Pass subslicing=True to access propagation to sub-slices of the
unit cell, in this case nslices is taken to be in units of subslices
to propagate rather than unit cells (i.e. nslices = 3 will propagate
1.5 unit cells for a subslicing of 2 subslices per unit cell)
showProgress : bool, optional
Pass showProgress = False to disable live progress readout
transpose : bool, optional
Make a "transposed" scattering matrix - see Brown et al. (2019)
Physical Review Research paper for a discussion of this and its
applications</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Propagate(
    self,
    nslice,
    propagators,
    transmission_functions,
    subslicing=False,
    batch_size=3,
    showProgress=True,
    transpose=False,
):
    &#34;&#34;&#34;
    Propagate a scattering matrix to slice nslice of the specimen.

    Parameters
    ----------
    nslice : int
        The slice in the specimen to propagate the scattering matrix to
    propagators : (N,Y,X,2) torch.array
        Fresnel free space operators required for the multislice algorithm
        used to propagate the scattering matrix
    transmission_functions : (N,Y,X,2)
        The transmission functions describing the electron&#39;s interaction
        with the specimen for the multislice algorithm

    Keyword arguments
    -----------------
    batch_size : int, optional
        The multislice algorithm can be performed on multiple scattering
        matrix columns at once to parrallelize computation, this number is
        set by batch_size.
    subslicing : bool, optional
        Pass subslicing=True to access propagation to sub-slices of the
        unit cell, in this case nslices is taken to be in units of subslices
        to propagate rather than unit cells (i.e. nslices = 3 will propagate
        1.5 unit cells for a subslicing of 2 subslices per unit cell)
    showProgress : bool, optional
        Pass showProgress = False to disable live progress readout
    transpose : bool, optional
        Make a &#34;transposed&#34; scattering matrix - see Brown et al. (2019)
        Physical Review Research paper for a discussion of this and its
        applications
    &#34;&#34;&#34;
    from .Probe import plane_wave_illumination

    # Initialize scattering matrix if necessary
    if not self.initialized:
        if self.Fourier_space_output:
            self.S = torch.zeros(
                self.nbeams, self.nbout, 2, dtype=self.dtype, device=self.device
            )
        else:
            self.S = torch.zeros(
                self.nbeams,
                *self.stored_gridshape,
                2,
                dtype=self.dtype,
                device=self.device
            )
        for ibeam in range(self.nbeams):
            # Initialize S-matrix to plane-waves
            psi = cx_from_numpy(
                plane_wave_illumination(
                    self.gridshape,
                    self.rsize[:2],
                    self.eV,
                    tilt=[self.beams[0][ibeam], self.beams[1][ibeam]],
                    tilt_units=&#34;pixels&#34;,
                    qspace=True,
                )
            )

            # Adjust intensity for correct normalization of S matrix rows
            # taking into account the PRISM factor that needs to be applied
            # when the Smatrix is evaluated (only 1/product(PRISM_factor)
            # beams are taken and only 1/product(PRISM_factor) intensity
            # is cropped out in real space)
            psi *= torch.prod(torch.tensor(self.PRISM_factor, dtype=self.dtype))

            if self.Fourier_space_output:
                self.S[ibeam] = psi[self.bw_mapping[:, 0], self.bw_mapping[:, 1], :]
            else:
                self.S[ibeam] = fourier_interpolate_2d_torch(
                    psi,
                    self.stored_gridshape,
                    qspace_in=True,
                    qspace_out=False,
                    norm=&#34;conserve_norm&#34;,
                )
        self.initialized = True

    # Make nslice_ which always accounts of subslices of the cyrstal structure
    if subslicing:
        nslice_ = nslice
    else:
        nslice_ = nslice * self.nsubslices

    # Work out direction of propagation through specimen
    if nslice_ != self.current_slice:
        direction = np.sign(nslice_ - self.current_slice)
    else:
        direction = 1

    if direction == 0:
        direction = 1

    if nslice_ &gt; len(self.seed):
        # Add new seeds to determine random translations for frozen-phonon
        # multislice (required for reversability of multislice) if required
        self.seed = np.concatenate(
            [
                self.seed,
                np.random.randint(0, 2 ** 31 - 1, size=nslice_ - len(self.seed)),
            ]
        )

    # Now generate list of slices that the multislice algorithm will run through
    slices = np.arange(self.current_slice, nslice_, direction)
    if direction &lt; 0:
        slices += direction

    # For a transposed scattering matrix the order of the slices
    # in multislice should be reversed
    if self.transposed:
        slices = slices[::-1]

    # If streaming of Smatrix columns to the GPU is being used, ensure
    # that propagators and transmission functions for the multislice are
    # already on the GPU
    if self.GPU_streaming:
        propagators = ensure_torch_array(propagators).cuda()
        transmission_functions = ensure_torch_array(transmission_functions).cuda()

    self.current_slice = nslice_
    if len(slices) &lt; 1:
        return

    # Loop over the different plane wave components (or columns) of the
    # scattering matrix
    for i in tqdm(
        range(int(np.ceil(self.nbeams / batch_size))),
        disable=not showProgress,
        desc=&#34;Calculating S-matrix&#34;,
    ):
        # Initialize array that will be used as input to the multislice routine
        psi = torch.zeros(
            batch_size, *self.gridshape, 2, dtype=self.dtype, device=self.device
        )
        beams = np.arange(
            i * batch_size, min((i + 1) * batch_size, self.nbeams), dtype=np.int
        )

        if self.Fourier_space_output:
            # Expand S-matrix input to full grid for multislice propagation
            psi[
                : beams.shape[0], self.bw_mapping[:, 0], self.bw_mapping[:, 1], :
            ] = self.S[beams]
        else:
            # Fourier interpolate stored real space S-matrix column onto
            # multislice grid
            psi = fourier_interpolate_2d_torch(
                self.S[beams], self.gridshape, norm=&#34;conserve_norm&#34;
            )

        if self.GPU_streaming:
            psi = ensure_torch_array(psi, dtype=self.dtype).to(&#34;cuda&#34;)

        output = multislice(
            psi[: beams.shape[0]],
            slices,
            propagators,
            transmission_functions,
            self.tiling,
            self.device,
            self.seed,
            return_numpy=False,
            qspace_in=self.Fourier_space_output,
            qspace_out=self.Fourier_space_output,
            transpose=self.transposed,
            output_to_bandwidth_limit=False,
            reverse=direction &lt; 0,
        )

        if self.GPU_streaming:
            output = output.to(self.device)

        if self.Fourier_space_output:

            self.S[beams] = output[
                :, self.bw_mapping[:, 0], self.bw_mapping[:, 1], :
            ] * np.sqrt(np.prod(self.stored_gridshape) / np.prod(self.gridshape))
        else:
            output = fourier_interpolate_2d_torch(
                output, self.stored_gridshape, norm=&#34;conserve_norm&#34;
            )
            self.S[beams] = output</code></pre>
</details>
</dd>
<dt id="pyms.py_multislice.scattering_matrix.STEM_with_GPU_streaming"><code class="name flex">
<span>def <span class="ident">STEM_with_GPU_streaming</span></span>(<span>self, detectors=None, FourD_STEM=None, datacube=None, STEM_image=None, nstreams=None, df=0, aberrations=[], ROI=[0.0, 0.0, 1.0, 1.0], device=None, scan_posns=None, showProgress=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform STEM with scattering matrix streamed between RAM and GPU memory.</p>
<p>This allows much larger fields of view to be calculated with relatively
modest graphics card memory. The STEM raster is segmented into spatially
close clusters and the probe positions in these clusters are processed
sequentially, with the relevant part of the scattering matrix streamed
from CPU to GPU memory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>self</code></strong> :&ensp;<code><a title="pyms.py_multislice.scattering_matrix" href="#pyms.py_multislice.scattering_matrix">scattering_matrix</a></code></dt>
<dd>The scattering matrix object.</dd>
<dt><strong><code>detectors</code></strong> :&ensp;<code>(Ndet, Y, X) array_like</code>, optional</dt>
<dd>Diffraction plane detectors to perform conventional STEM imaging. If
None is passed then no conventional STEM images will be returned.</dd>
<dt><strong><code>fourD_STEM</code></strong> :&ensp;<code>bool</code> or <code>array_like</code>, optional</dt>
<dd>Pass fourD_STEM = True to perform 4D-STEM simulations. To save disk
space a tuple containing pixel size and diffraction space extent of the
datacube can be passed in. For example ([64,64],[1.2,1.2]) will output
diffraction patterns measuring 64 x 64 pixels and 1.2 x 1.2 inverse
Angstroms.</dd>
<dt><strong><code>datacube</code></strong> :&ensp;<code> (Ny, Nx, Y, X) array_like</code>, optional</dt>
<dd>datacube for 4D-STEM output, if None is passed (default) this will be
initialized in the function. If a datacube is passed then the result
will be added by the STEM routine (useful for multiple frozen phonon
iterations)</dd>
<dt><strong><code>STEM_image</code></strong> :&ensp;<code>(Ndet,Ny,Nx) array_like</code>, optional</dt>
<dd>Array that will contain the conventional STEM images, if not passed
will be initialized within the function. If it is passed then the result
will be accumulated within the function, which is useful for multiple
frozen phonon iterations.</dd>
<dt><strong><code>nstreams</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of streams (seperate transfers from CPU to GPU memory). If
None this will just be set to the product of the PRISM interpolation
factor</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Defocus in Angstrom</dd>
<dt><strong><code>aberrations</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>A list containing a set of the class aberration, pass an empty list for
an unaberrated contrast transfer function.</dd>
<dt><strong><code>ROI</code></strong> :&ensp;<code>(4,) array_like</code></dt>
<dd>Fraction of the unit cell to be scanned. Should contain [y0,x0,y1,x1]
where [x0,y0] and [x1,y1] are the bottom left and top right coordinates
of the region of interest (ROI) expressed as a fraction of the total
grid (or unit cell).</dd>
<dt><strong><code>device</code></strong> :&ensp;<code>torch.device</code>, optional</dt>
<dd>torch.device object which will determine which device (CPU or GPU) the
calculations will run on.</dd>
<dt><strong><code>scan_posn</code></strong> :&ensp;<code> (&hellip;,2) array_like</code>, optional</dt>
<dd>Array containing the STEM scan positions in fractional coordinates.
If provided scan_posn.shape[:-1] will give the shape of the STEM
image.</dd>
<dt><strong><code>showProgress</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Pass showProgress=False to disable progress bar.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def STEM_with_GPU_streaming(
    self,
    detectors=None,
    FourD_STEM=None,
    datacube=None,
    STEM_image=None,
    nstreams=None,
    df=0,
    aberrations=[],
    ROI=[0.0, 0.0, 1.0, 1.0],
    device=None,
    scan_posns=None,
    showProgress=True,
):
    &#34;&#34;&#34;
    Perform STEM with scattering matrix streamed between RAM and GPU memory.

    This allows much larger fields of view to be calculated with relatively
    modest graphics card memory. The STEM raster is segmented into spatially
    close clusters and the probe positions in these clusters are processed
    sequentially, with the relevant part of the scattering matrix streamed
    from CPU to GPU memory.

    Parameters
    ----------
    self : scattering_matrix
        The scattering matrix object.
    detectors : (Ndet, Y, X) array_like, optional
        Diffraction plane detectors to perform conventional STEM imaging. If
        None is passed then no conventional STEM images will be returned.
    fourD_STEM : bool or array_like, optional
        Pass fourD_STEM = True to perform 4D-STEM simulations. To save disk
        space a tuple containing pixel size and diffraction space extent of the
        datacube can be passed in. For example ([64,64],[1.2,1.2]) will output
        diffraction patterns measuring 64 x 64 pixels and 1.2 x 1.2 inverse
        Angstroms.
    datacube :  (Ny, Nx, Y, X) array_like, optional
        datacube for 4D-STEM output, if None is passed (default) this will be
        initialized in the function. If a datacube is passed then the result
        will be added by the STEM routine (useful for multiple frozen phonon
        iterations)
    STEM_image : (Ndet,Ny,Nx) array_like, optional
        Array that will contain the conventional STEM images, if not passed
        will be initialized within the function. If it is passed then the result
        will be accumulated within the function, which is useful for multiple
        frozen phonon iterations.
    nstreams : int, optional
        Number of streams (seperate transfers from CPU to GPU memory). If
        None this will just be set to the product of the PRISM interpolation
        factor
    df : float, optional
        Defocus in Angstrom
    aberrations : list, optional
        A list containing a set of the class aberration, pass an empty list for
        an unaberrated contrast transfer function.
    ROI : (4,) array_like
        Fraction of the unit cell to be scanned. Should contain [y0,x0,y1,x1]
        where [x0,y0] and [x1,y1] are the bottom left and top right coordinates
        of the region of interest (ROI) expressed as a fraction of the total
        grid (or unit cell).
    device : torch.device, optional
        torch.device object which will determine which device (CPU or GPU) the
        calculations will run on.
    scan_posn :  (...,2) array_like, optional
        Array containing the STEM scan positions in fractional coordinates.
        If provided scan_posn.shape[:-1] will give the shape of the STEM
        image.
    showProgress : bool, optional
        Pass showProgress=False to disable progress bar.
    &#34;&#34;&#34;
    device = get_device(device)

    # Get indices of PRISM cropping window
    crop_ = [x.cpu().numpy() for x in self.PRISM_crop_window()]

    # Make the STEM probe
    probe = focused_probe(
        self.gridshape,
        self.rsize[:2],
        self.eV,
        self.alpha_,
        df=df,
        aberrations=aberrations,
        app_units=&#34;invA&#34;,
    )
    probe = cx_from_numpy(probe, device=device, dtype=self.dtype)

    # Make scan positions if none already provided
    if scan_posns is None:
        scan_posns = generate_STEM_raster(
            self.rsize, self.eV, self.alpha_, tiling=self.tiling, ROI=ROI, invA=True
        )
    # Get scan (and STEM image) array shape and total number of scan positions
    scan_shape = scan_posns.shape[:-1]
    nscan = np.product(scan_shape)

    # Flatten scan positions to simplify iteration later on.
    scan_posns = scan_posns.reshape((nscan, 2))

    # Calculate default 4D-STEM diffraction pattern sampling
    if FourD_STEM is True:
        GS = self.stored_gridshape
        FourD_STEM = [GS, GS / self.rsize[:2]]

    # Allocate diffraction pattern and STEM images if not already provided
    if FourD_STEM:
        gridout = workout_4DSTEM_datacube_DP_size(
            FourD_STEM, self.rsize, self.gridshape
        )[0]
    if (datacube is None) and FourD_STEM:
        datacube = np.zeros((*scan_shape, *gridout))
    if not FourD_STEM:
        datacube = None

    # If detectors are provided then we are doing conventional STEM
    doConventionalSTEM = detectors is not None

    # Initialize STEM images if not provided
    if doConventionalSTEM:
        ndet = detectors.shape[0]
        if STEM_image is None:
            STEM_image = np.zeros((ndet, nscan))
        else:
            STEM_image = STEM_image.reshape((ndet, nscan))
    else:
        STEM_image = None

    if nstreams is None:
        # If the number of seperate streams is not suggested by the
        # user, make this equal to the product of the PRISM factor
        nstreams = int(np.product(self.PRISM_factor))

    # Divide up the scan positions into clusters based on Euclidean
    # distance
    from sklearn.cluster import Birch

    if nscan &gt; 1:
        model = Birch(threshold=0.01, n_clusters=nstreams)
        yhat = model.fit_predict(scan_posns)
        clusters = np.unique(yhat)
    else:
        yhat, clusters = [[0], [0]]

    # Now do STEM with each of the scan position clusters, streaming
    # only the necessary bits of the scattering matrix to the GPU.
    Datacube_segment = None
    STEM_image_segment = None
    FlatS = self.S.reshape((self.nbeams, np.prod(self.stored_gridshape), 2))

    # Loop over probe positions clusters. This would be a good candidate
    # for multi-GPU work.
    for cluster in tqdm(
        clusters, desc=&#34;Probe position clusters&#34;, disable=not showProgress
    ):
        # Get map of probe positions in cluster
        points = np.nonzero(yhat == cluster)[0]
        npoints = len(points)

        # Get segments of images to update
        if doConventionalSTEM:
            STEM_image_segment = STEM_image[:, points]
        if FourD_STEM:
            Datacube_segment = np.zeros((1, npoints, 1, *gridout))
        pix_posn = scan_posns[points] * np.asarray(self.stored_gridshape)

        # Work out bounds of the rectangular region of the scattering
        # matrix to stream to the GPU
        ymin, ymax = [
            int(np.floor(np.amin(pix_posn[:, 0]) + crop_[0][0])),
            int(np.ceil(np.amax(pix_posn[:, 0]) + crop_[0][-1])),
        ]
        xmin, xmax = [
            int(np.floor(np.amin(pix_posn[:, 1]) + crop_[1][0])),
            int(np.ceil(np.amax(pix_posn[:, 1]) + crop_[1][-1])),
        ]
        size = np.asarray([(ymax - ymin), (xmax - xmin)])

        # Get indices of region of scattering matrix to stream to GPU
        window = [np.arange(a, b) for a, b in zip([ymin, xmin], [ymax, xmax])]
        indices = crop_window_to_flattened_indices_torch(
            window, self.stored_gridshape
        )

        # Get segment of the scattering matrix to stream to GPU
        segmentshape = [len(x) for x in window]
        SegmentS = FlatS[:, indices, :].reshape((self.nbeams, *segmentshape, 2))

        # Define a function that will map probe positions for the global
        # scattering matrix to their correct place on the smaller scattering
        # matrix streamed to the GPU.
        gshape = torch.as_tensor(self.stored_gridshape).to(device).type(self.dtype)
        Origin = torch.as_tensor([ymin, xmin]).to(device).type(self.dtype)
        segment_size = torch.as_tensor(size).to(device).type(self.dtype)

        def scan_transform(posn):
            return (posn * gshape - Origin) / segment_size

        # Keyword arguments to be passed to the __call__ function by the
        # STEM routine
        kwargs = {&#34;Smat&#34;: SegmentS.to(device), &#34;scan_transform&#34;: scan_transform}

        # Calculate STEM images
        STEM(
            self.rsize,
            probe,
            self.__call__,
            [1],
            self.eV,
            self.alpha_,
            detectors=detectors,
            FourD_STEM=FourD_STEM,
            datacube=Datacube_segment,
            scan_posn=scan_posns[points].reshape((npoints, 1, 2)),
            STEM_image=STEM_image_segment,
            method_kwargs=kwargs,
            showProgress=False,
            device=device,
        )

        if doConventionalSTEM:
            STEM_image[:, points] += STEM_image_segment
        if FourD_STEM:
            for point, Dp in zip(points, Datacube_segment[0]):
                y, x = np.unravel_index(point, scan_shape)
                datacube[y, x] += Dp[0]

    # Unflatten 4D-STEM datacube scan dimensions, use numpy squeeze to
    # remove superfluous dimensions (ones with length 1)
    # if FourD_STEM:
    #     datacube = datacube.reshape(*scan_shape, *datacube.shape[-2:])

    if doConventionalSTEM:
        STEM_image = np.squeeze(STEM_image.reshape(ndet, *scan_shape))

    # Return STEM images and datacube as a dictionary. If either of these
    # objects were not calculated the dictionary will contain None for those
    # entries.
    return {&#34;STEM images&#34;: STEM_image, &#34;datacube&#34;: datacube}</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyms" href="index.html">pyms</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyms.py_multislice.STEM" href="#pyms.py_multislice.STEM">STEM</a></code></li>
<li><code><a title="pyms.py_multislice.STEM_phase_contrast_transfer_function" href="#pyms.py_multislice.STEM_phase_contrast_transfer_function">STEM_phase_contrast_transfer_function</a></code></li>
<li><code><a title="pyms.py_multislice.generate_STEM_raster" href="#pyms.py_multislice.generate_STEM_raster">generate_STEM_raster</a></code></li>
<li><code><a title="pyms.py_multislice.generate_probe_spread_plot" href="#pyms.py_multislice.generate_probe_spread_plot">generate_probe_spread_plot</a></code></li>
<li><code><a title="pyms.py_multislice.generate_slice_indices" href="#pyms.py_multislice.generate_slice_indices">generate_slice_indices</a></code></li>
<li><code><a title="pyms.py_multislice.make_detector" href="#pyms.py_multislice.make_detector">make_detector</a></code></li>
<li><code><a title="pyms.py_multislice.make_propagators" href="#pyms.py_multislice.make_propagators">make_propagators</a></code></li>
<li><code><a title="pyms.py_multislice.max_grid_resolution" href="#pyms.py_multislice.max_grid_resolution">max_grid_resolution</a></code></li>
<li><code><a title="pyms.py_multislice.multislice" href="#pyms.py_multislice.multislice">multislice</a></code></li>
<li><code><a title="pyms.py_multislice.nyquist_sampling" href="#pyms.py_multislice.nyquist_sampling">nyquist_sampling</a></code></li>
<li><code><a title="pyms.py_multislice.phase_from_com" href="#pyms.py_multislice.phase_from_com">phase_from_com</a></code></li>
<li><code><a title="pyms.py_multislice.second_moment" href="#pyms.py_multislice.second_moment">second_moment</a></code></li>
<li><code><a title="pyms.py_multislice.thickness_to_slices" href="#pyms.py_multislice.thickness_to_slices">thickness_to_slices</a></code></li>
<li><code><a title="pyms.py_multislice.tqdm_handler" href="#pyms.py_multislice.tqdm_handler">tqdm_handler</a></code></li>
<li><code><a title="pyms.py_multislice.unit_cell_shift" href="#pyms.py_multislice.unit_cell_shift">unit_cell_shift</a></code></li>
<li><code><a title="pyms.py_multislice.workout_4DSTEM_datacube_DP_size" href="#pyms.py_multislice.workout_4DSTEM_datacube_DP_size">workout_4DSTEM_datacube_DP_size</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyms.py_multislice.scattering_matrix" href="#pyms.py_multislice.scattering_matrix">scattering_matrix</a></code></h4>
<ul class="">
<li><code><a title="pyms.py_multislice.scattering_matrix.PRISM_crop_window" href="#pyms.py_multislice.scattering_matrix.PRISM_crop_window">PRISM_crop_window</a></code></li>
<li><code><a title="pyms.py_multislice.scattering_matrix.Propagate" href="#pyms.py_multislice.scattering_matrix.Propagate">Propagate</a></code></li>
<li><code><a title="pyms.py_multislice.scattering_matrix.STEM_with_GPU_streaming" href="#pyms.py_multislice.scattering_matrix.STEM_with_GPU_streaming">STEM_with_GPU_streaming</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>